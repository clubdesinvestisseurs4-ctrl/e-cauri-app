<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>E-Cauri App V2 - Paris Sportifs Intelligents</title>
    <!-- React -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Firebase Configuration - REMPLACER PAR VOS VALEURS -->
    <script>
        // Configuration Firebase pour le projet: football-opportunities
        // ‚ö†Ô∏è IMPORTANT: Remplacez ces valeurs par celles de votre projet Firebase
        // Trouvez-les dans: Firebase Console ‚Üí Param√®tres du projet ‚Üí Vos applications ‚Üí Web
         const firebaseConfig = {
            apiKey: "AIzaSyAoUl0RbzzolyuZ-TAd8v0i9O5X2w1Ywfg",
            authDomain: "football-opportunities.firebaseapp.com",
            projectId: "football-opportunities",
            storageBucket: "football-opportunities.firebasestorage.app",
            messagingSenderId: "374999604744",
            appId: "1:374999604744:web:321fc14e53ff57313efbbd"
        };
        
        // Initialiser Firebase seulement si la config est valide
        let firebaseApp = null;
        let firebaseAuth = null;
        
        if (firebaseConfig.apiKey && !firebaseConfig.apiKey.includes("VOTRE_")) {
            try {
                firebaseApp = firebase.initializeApp(firebaseConfig);
                firebaseAuth = firebase.auth();
                console.log("‚úÖ Firebase Auth initialized");
            } catch (error) {
                console.warn("‚ö†Ô∏è Firebase Auth init failed:", error.message);
            }
        } else {
            console.warn("‚ö†Ô∏è Firebase config not set - Auth will use mock mode");
            console.warn("   Modifiez firebaseConfig dans e-cauri-app-v2.html");
        }
    </script>
    
    <style>
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #111827;
            --bg-card: #1a2332;
            --bg-card-hover: #232f42;
            --accent-gold: #f59e0b;
            --accent-gold-light: #fbbf24;
            --accent-green: #10b981;
            --accent-green-light: #34d399;
            --accent-red: #ef4444;
            --accent-red-light: #f87171;
            --accent-blue: #3b82f6;
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --border-color: #374151;
            --gradient-gold: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            --gradient-green: linear-gradient(135deg, #10b981 0%, #059669 100%);
            --gradient-dark: linear-gradient(180deg, #0a0e17 0%, #111827 100%);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        #root { min-height: 100vh; display: flex; flex-direction: column; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes loading-bar { 
            0% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
            100% { transform: translateX(250%); }
        }

        .animate-fade-in { animation: fadeIn 0.4s ease-out forwards; }
        .animate-slide-up { animation: slideUp 0.5s ease-out forwards; }
        .delay-1 { animation-delay: 0.1s; opacity: 0; }
        .delay-2 { animation-delay: 0.2s; opacity: 0; }
        .delay-3 { animation-delay: 0.3s; opacity: 0; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-secondary); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }

        .app-container {
            max-width: 480px;
            margin: 0 auto;
            min-height: 100vh;
            background: var(--gradient-dark);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: rgba(10, 14, 23, 0.95);
            backdrop-filter: blur(10px);
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid rgba(55, 65, 81, 0.5);
        }

        .logo {
            font-family: 'Space Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            background: var(--gradient-gold);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -1px;
        }

        .header-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-card);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
        }

        .header-icon:hover { background: var(--bg-card-hover); border-color: var(--accent-gold); }
        .header-icon.connected { border-color: var(--accent-green); background: rgba(16, 185, 129, 0.15); }
        .header-icon svg { width: 20px; height: 20px; color: var(--text-secondary); }
        .header-icon.connected svg { color: var(--accent-green); }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: color 0.2s;
            background: none;
            border: none;
            font-family: inherit;
        }

        .back-btn:hover { color: var(--text-primary); }
        .back-btn svg { width: 20px; height: 20px; }
        .page-title { font-size: 1.1rem; font-weight: 600; color: var(--text-primary); }

        /* Main Content */
        .main-content { flex: 1; padding: 20px; padding-bottom: 100px; }

        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .card:hover { background: var(--bg-card-hover); transform: translateY(-2px); }
        .card-clickable { cursor: pointer; }

        .match-card {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .match-teams {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .team-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .team-logo {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: var(--bg-secondary);
            object-fit: contain;
        }

        .team-name { font-weight: 500; font-size: 0.95rem; }
        .match-meta { color: var(--text-muted); font-size: 0.8rem; margin-top: 8px; }
        .match-arrow { color: var(--text-muted); }

        /* Buttons */
        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 14px 24px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-family: inherit;
        }

        .btn svg { width: 20px; height: 20px; }

        .btn-primary {
            background: var(--gradient-gold);
            color: #000;
        }

        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(245, 158, 11, 0.3); }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover { background: var(--bg-card-hover); border-color: var(--accent-gold); }

        .btn-success {
            background: var(--gradient-green);
            color: #fff;
        }

        .btn-success:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(16, 185, 129, 0.3); }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: #fff;
        }

        .btn-danger:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(239, 68, 68, 0.3); }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Input */
        .input-group { margin-bottom: 20px; }
        .input-label { display: block; color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 8px; }

        .input {
            width: 100%;
            padding: 14px 16px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        .input:focus {
            outline: none;
            border-color: var(--accent-gold);
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.1);
        }

        .input::placeholder { color: var(--text-muted); }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border-color);
        }

        .stat-card.green { border-color: rgba(16, 185, 129, 0.3); background: rgba(16, 185, 129, 0.1); }
        .stat-card.red { border-color: rgba(239, 68, 68, 0.3); background: rgba(239, 68, 68, 0.1); }
        .stat-label { color: var(--text-muted); font-size: 0.8rem; margin-bottom: 4px; }
        .stat-value { font-family: 'Space Mono', monospace; font-size: 1.2rem; font-weight: 700; }
        .stat-value.green { color: var(--accent-green); }
        .stat-value.red { color: var(--accent-red); }

        /* Option Cards */
        .option-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option-card:hover { border-color: var(--accent-gold); }
        .option-card.selected { border-color: var(--accent-gold); background: rgba(245, 158, 11, 0.1); }

        .option-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .option-name { font-weight: 500; }
        .option-odds { font-family: 'Space Mono', monospace; color: var(--accent-gold); font-weight: 700; }
        .option-prob { color: var(--text-muted); font-size: 0.85rem; }

        /* Bottom Nav */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 480px;
            background: rgba(10, 14, 23, 0.98);
            backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: 12px 0;
            z-index: 100;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            color: var(--text-muted);
            cursor: pointer;
            transition: color 0.2s;
            background: none;
            border: none;
            font-family: inherit;
            padding: 8px 16px;
        }

        .nav-item:hover, .nav-item.active { color: var(--accent-gold); }
        .nav-item svg { width: 24px; height: 24px; }
        .nav-label { font-size: 0.7rem; }

        /* Loading */
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 40px auto;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 14, 23, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-text {
            color: var(--text-secondary);
            margin-top: 20px;
            font-size: 0.9rem;
        }

        /* AI Analysis Box */
        .analysis-box {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(245, 158, 11, 0.05) 100%);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .analysis-title {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--accent-gold);
            font-weight: 600;
            margin-bottom: 12px;
        }

        .analysis-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 500;
            z-index: 1001;
            animation: slideUp 0.3s ease-out;
        }

        .notification.success { background: var(--accent-green); color: #fff; }
        .notification.error { background: var(--accent-red); color: #fff; }
        .notification.info { background: var(--accent-blue); color: #fff; }

        /* Balance Display */
        .balance-display {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 24px;
            text-align: center;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .balance-label { color: var(--text-muted); font-size: 0.9rem; margin-bottom: 8px; }

        .balance-value {
            font-family: 'Space Mono', monospace;
            font-size: 2rem;
            font-weight: 700;
            background: var(--gradient-gold);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Chart */
        .chart-container {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .chart-title { color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 16px; }

        .chart-placeholder {
            height: 150px;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(16, 185, 129, 0.05) 100%);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .chart-line {
            position: absolute;
            bottom: 20%;
            left: 5%;
            width: 90%;
            height: 2px;
            background: var(--accent-green);
            transform-origin: left;
            transform: rotate(-10deg);
        }

        /* Recommendation Box */
        .recommendation-box {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(16, 185, 129, 0.05) 100%);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .recommendation-title {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--accent-green);
            font-weight: 600;
            margin-bottom: 12px;
        }

        .recommendation-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Section Title */
        .section-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .section-subtitle {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useContext, createContext, useCallback } = React;

        // ============== CONFIGURATION API ==============
        const API_BASE_URL = 'https://e-cauri-api.onrender.com/api';

        // ============== SERVICE NOTIFICATIONS NAVIGATEUR ==============
        // D√âSACTIV√â - L'API Notification n'est pas disponible dans ce contexte
        const NotificationService = {
            permission: 'denied',
            supported: false,
            
            init() {
                // Notifications d√©sactiv√©es
                console.log('üîî Notifications: d√©sactiv√©es (API non disponible)');
                return false;
            },
            
            async requestPermission() {
                return false;
            },
            
            async send(title, options = {}) {
                // Afficher dans la console √† la place
                console.log(`üì¢ [Notification] ${title}`, options.body || '');
                return null;
            },
            
            // Notifications sp√©cifiques - juste des logs
            analysisComplete(matchName) {
                console.log(`‚úÖ Analyse termin√©e: ${matchName}`);
                return null;
            },
            
            recommendationsReady() {
                console.log('üìä Recommandations disponibles');
                return null;
            },
            
            matchStarting(matchName, minutesUntil) {
                console.log(`‚öΩ ${matchName} commence dans ${minutesUntil} minutes`);
                return null;
            },
            
            matchResult(matchName, result, profit) {
                console.log(`üéØ R√©sultat ${matchName}: ${profit >= 0 ? 'Gain' : 'Perte'} de ${Math.abs(profit)} FCFA`);
                return null;
            }
        };

        // ============== IC√îNES ==============
        const Icons = {
            Home: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9,22 9,12 15,12 15,22"/></svg>,
            Tool: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>,
            Chart: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="20" x2="12" y2="10"/><line x1="18" y1="20" x2="18" y2="4"/><line x1="6" y1="20" x2="6" y2="16"/></svg>,
            TrendingUp: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="23,6 13.5,15.5 8.5,10.5 1,18"/><polyline points="17,6 23,6 23,12"/></svg>,
            Trending: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="23,6 13.5,15.5 8.5,10.5 1,18"/><polyline points="17,6 23,6 23,12"/></svg>,
            Brain: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 4.44-1.54"/><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-4.44-1.54"/></svg>,
            User: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>,
            ArrowLeft: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12,19 5,12 12,5"/></svg>,
            ArrowRight: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12,5 19,12 12,19"/></svg>,
            Check: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="20,6 9,17 4,12"/></svg>,
            Book: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>,
            Play: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="5,3 19,12 5,21 5,3"/></svg>,
            Lock: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>,
            Target: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>,
            Zap: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="13,2 3,14 12,14 11,22 21,10 12,10 13,2"/></svg>,
            AlertCircle: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>,
            Lightbulb: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="9" y1="18" x2="15" y2="18"/><line x1="10" y1="22" x2="14" y2="22"/><path d="M15.09 14c.18-.98.65-1.74 1.41-2.5A4.65 4.65 0 0 0 18 8 6 6 0 0 0 6 8c0 1 .23 2.23 1.5 3.5A4.61 4.61 0 0 1 8.91 14"/></svg>,
            DollarSign: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>,
            Shield: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>,
            Eye: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>,
            Bell: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg>,
            Refresh: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>,
            Calculator: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="4" y="2" width="16" height="20" rx="2"/><line x1="8" y1="6" x2="16" y2="6"/><line x1="8" y1="10" x2="8" y2="10.01"/><line x1="12" y1="10" x2="12" y2="10.01"/><line x1="16" y1="10" x2="16" y2="10.01"/><line x1="8" y1="14" x2="8" y2="14.01"/><line x1="12" y1="14" x2="12" y2="14.01"/><line x1="16" y1="14" x2="16" y2="14.01"/><line x1="8" y1="18" x2="8" y2="18.01"/><line x1="12" y1="18" x2="16" y2="18"/></svg>,
        };

        // ============== CONTEXTE ==============
        const AppContext = createContext(null);

        const AppProvider = ({ children }) => {
            const [currentPage, setCurrentPage] = useState('home');
            const [pageHistory, setPageHistory] = useState(['home']);
            const [user, setUser] = useState(null);
            const [pendingPage, setPendingPage] = useState(null);
            
            // Data state
            const [matches, setMatches] = useState([]);
            const [selectedMatch, setSelectedMatch] = useState(null);
            const [userBalance, setUserBalance] = useState(0);
            const [currentPrediction, setCurrentPrediction] = useState(null);
            const [activePredictions, setActivePredictions] = useState([]);
            const [selectedOptions, setSelectedOptions] = useState([]);
            
            // UI state - Loading states am√©lior√©s
            const [loading, setLoading] = useState(false);
            const [loadingMessage, setLoadingMessage] = useState('');
            const [notification, setNotification] = useState(null);
            const [notificationsEnabled, setNotificationsEnabled] = useState(false);

            // Demander permission notifications au chargement
            useEffect(() => {
                const initNotifications = async () => {
                    try {
                        // Initialiser le service
                        const supported = NotificationService.init();
                        if (!supported) {
                            console.log('‚ö†Ô∏è Notifications non support√©es dans ce contexte');
                            return;
                        }
                        
                        // Demander la permission
                        const granted = await NotificationService.requestPermission();
                        setNotificationsEnabled(granted);
                        if (granted) {
                            console.log('‚úÖ Notifications navigateur activ√©es');
                        }
                    } catch (error) {
                        console.warn('Erreur init notifications:', error);
                    }
                };
                initNotifications();
            }, []);

            const navigate = (page, params = {}) => {
                setPageHistory(prev => [...prev, page]);
                setCurrentPage(page);
            };

            const goBack = () => {
                if (pageHistory.length > 1) {
                    const newHistory = [...pageHistory];
                    newHistory.pop();
                    setPageHistory(newHistory);
                    setCurrentPage(newHistory[newHistory.length - 1]);
                }
            };

            const requireAuth = (targetPage) => {
                if (user) {
                    navigate(targetPage);
                } else {
                    setPendingPage(targetPage);
                    navigate('login');
                }
            };

            const login = async (email, password) => {
                setLoading(true);
                try {
                    if (firebaseAuth) {
                        // Firebase Auth r√©el
                        const userCredential = await firebaseAuth.signInWithEmailAndPassword(email, password);
                        const fbUser = userCredential.user;
                        
                        // R√©cup√©rer le token pour les appels API
                        const token = await fbUser.getIdToken();
                        localStorage.setItem('authToken', token);
                        
                        setUser({ 
                            uid: fbUser.uid,
                            email: fbUser.email, 
                            displayName: fbUser.displayName || email.split('@')[0]
                        });
                        showNotification('Connexion r√©ussie !', 'success');
                    } else {
                        // Mode d√©mo (sans Firebase)
                        await new Promise(r => setTimeout(r, 500));
                        const mockUser = { 
                            uid: 'demo_' + Date.now(),
                            email, 
                            displayName: email.split('@')[0] 
                        };
                        localStorage.setItem('authToken', 'demo_token_' + Date.now());
                        setUser(mockUser);
                        showNotification('Connexion d√©mo r√©ussie', 'info');
                    }
                    
                    setLoading(false);
                    if (pendingPage) {
                        navigate(pendingPage);
                        setPendingPage(null);
                    } else {
                        navigate('home');
                    }
                    return true;
                } catch (error) {
                    setLoading(false);
                    console.error('Login error:', error);
                    showNotification(getFirebaseErrorMessage(error.code), 'error');
                    return false;
                }
            };

            const register = async (email, password, displayName) => {
                setLoading(true);
                try {
                    if (firebaseAuth) {
                        // Cr√©er le compte Firebase
                        const userCredential = await firebaseAuth.createUserWithEmailAndPassword(email, password);
                        const fbUser = userCredential.user;
                        
                        // Mettre √† jour le profil
                        await fbUser.updateProfile({ displayName });
                        
                        // R√©cup√©rer le token
                        const token = await fbUser.getIdToken();
                        localStorage.setItem('authToken', token);
                        
                        // Cr√©er le profil utilisateur c√¥t√© backend
                        await fetch(`${API_BASE_URL}/user/profile`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify({
                                email,
                                displayName,
                                currentBalance: 0
                            })
                        });
                        
                        setUser({ 
                            uid: fbUser.uid,
                            email: fbUser.email, 
                            displayName 
                        });
                        showNotification('Compte cr√©√© avec succ√®s !', 'success');
                    } else {
                        // Mode d√©mo
                        await new Promise(r => setTimeout(r, 500));
                        const mockUser = { uid: 'demo_' + Date.now(), email, displayName };
                        localStorage.setItem('authToken', 'demo_token_' + Date.now());
                        setUser(mockUser);
                        showNotification('Compte d√©mo cr√©√©', 'info');
                    }
                    
                    setLoading(false);
                    if (pendingPage) {
                        navigate(pendingPage);
                        setPendingPage(null);
                    } else {
                        navigate('home');
                    }
                    return true;
                } catch (error) {
                    setLoading(false);
                    console.error('Register error:', error);
                    showNotification(getFirebaseErrorMessage(error.code), 'error');
                    return false;
                }
            };

            const logout = async () => {
                if (firebaseAuth) {
                    await firebaseAuth.signOut();
                }
                localStorage.removeItem('authToken');
                setUser(null);
                navigate('home');
                showNotification('D√©connexion r√©ussie', 'info');
            };

            // √âcouter les changements d'√©tat d'authentification Firebase
            useEffect(() => {
                if (firebaseAuth) {
                    const unsubscribe = firebaseAuth.onAuthStateChanged(async (fbUser) => {
                        if (fbUser) {
                            const token = await fbUser.getIdToken();
                            localStorage.setItem('authToken', token);
                            setUser({
                                uid: fbUser.uid,
                                email: fbUser.email,
                                displayName: fbUser.displayName || fbUser.email?.split('@')[0]
                            });
                        }
                    });
                    return () => unsubscribe();
                }
            }, []);

            // Helper pour obtenir un token valide (rafra√Æchi si n√©cessaire)
            const getValidToken = async (forceRefresh = false) => {
                try {
                    // Si Firebase Auth est disponible et un utilisateur est connect√©
                    if (firebaseAuth && firebaseAuth.currentUser) {
                        // Forcer le rafra√Æchissement du token
                        const freshToken = await firebaseAuth.currentUser.getIdToken(forceRefresh);
                        localStorage.setItem('authToken', freshToken);
                        if (forceRefresh) {
                            console.log('üîë Token rafra√Æchi avec succ√®s');
                        }
                        return freshToken;
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Impossible de rafra√Æchir le token:', error.message);
                }
                
                // Fallback: utiliser le token stock√©
                return localStorage.getItem('authToken');
            };

            // Helper pour les appels API avec gestion automatique du token expir√©
            const apiCallWithAuth = async (url, options = {}, retryCount = 0) => {
                // Obtenir un token valide
                const token = await getValidToken(retryCount > 0);
                
                if (!token) {
                    throw new Error('No auth token available');
                }
                
                const response = await fetch(url, {
                    ...options,
                    headers: {
                        ...options.headers,
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                // Si token expir√© (401), rafra√Æchir et r√©essayer une fois
                if (response.status === 401 && retryCount < 1) {
                    console.log('üîÑ Token expir√©, rafra√Æchissement en cours...');
                    return apiCallWithAuth(url, options, retryCount + 1);
                }
                
                return response;
            };

            // Charger les pr√©dictions de l'utilisateur depuis Firebase
            const fetchUserPredictions = async () => {
                const token = localStorage.getItem('authToken');
                if (!token) return;

                try {
                    const response = await apiCallWithAuth(`${API_BASE_URL}/predictions`);

                    if (response.ok) {
                        const data = await response.json();
                        const predictions = data.predictions || [];
                        
                        console.log('üìä Raw predictions from server:', predictions.length);
                        predictions.forEach((p, i) => {
                            console.log(`  ${i+1}. ${p.matchInfo?.homeTeam || p.meta?.homeTeam} vs ${p.matchInfo?.awayTeam || p.meta?.awayTeam}`);
                            console.log(`     Status: ${p.status}, selectedOptions: ${p.selectedOptions?.length || 0}`);
                        });
                        
                        // Les pr√©dictions sont d√©j√† filtr√©es et d√©dupliqu√©es c√¥t√© serveur
                        setActivePredictions(predictions);
                        console.log(`‚úÖ Loaded ${predictions.length} active predictions from Firebase`);
                    }
                } catch (error) {
                    console.warn('Could not fetch user predictions:', error);
                }
            };

            // Charger le capital de l'utilisateur depuis Firebase
            const fetchUserCapital = async () => {
                const token = localStorage.getItem('authToken');
                if (!token) return;

                try {
                    const response = await apiCallWithAuth(`${API_BASE_URL}/user/capital`);

                    if (response.ok) {
                        const data = await response.json();
                        if (data.capital?.currentBalance !== undefined) {
                            setUserBalance(data.capital.currentBalance);
                            console.log(`‚úÖ Loaded user balance: ${data.capital.currentBalance} FCFA`);
                        }
                    }
                } catch (error) {
                    console.warn('Could not fetch user capital:', error);
                }
            };

            // Charger les donn√©es utilisateur quand il se connecte
            useEffect(() => {
                if (user) {
                    console.log('üë§ User connected, loading data...');
                    fetchUserPredictions();
                    fetchUserCapital();
                } else {
                    // R√©initialiser les donn√©es si d√©connect√©
                    setActivePredictions([]);
                    setCurrentPrediction(null);
                }
            }, [user]);

            // ============== SYST√àME DE SUIVI AUTOMATIQUE DES MATCHS ==============
            const [livePollingActive, setLivePollingActive] = useState(false);
            
            // Fonction pour v√©rifier le statut live d'un match et agir automatiquement
            const checkMatchLiveStatus = async (prediction) => {
                if (!prediction || !prediction.matchInfo?.fixtureId) return null;
                
                const token = localStorage.getItem('authToken');
                if (!token) return null;
                
                try {
                    const response = await fetch(`${API_BASE_URL}/predictions/${prediction.id}/live-status`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    if (!response.ok) return null;
                    
                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.warn('Could not check live status:', error);
                    return null;
                }
            };
            
            // Fonction pour auto-finaliser un match termin√©
            const autoFinalizeMatch = async (predictionId) => {
                const token = localStorage.getItem('authToken');
                if (!token) return;
                
                try {
                    console.log(`üèÅ Auto-finalizing prediction ${predictionId}...`);
                    const response = await fetch(`${API_BASE_URL}/predictions/${predictionId}/auto-finalize`, {
                        method: 'POST',
                        headers: { 
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('‚úÖ Match finalized:', result);
                        
                        // Notification de r√©sultat
                        const profit = result.capitalUpdate?.change || 0;
                        if (profit >= 0) {
                            showNotification(`üéâ Victoire ! Gain de ${profit.toLocaleString()} FCFA`, 'success');
                        } else {
                            showNotification(`üòî D√©faite. Perte de ${Math.abs(profit).toLocaleString()} FCFA`, 'error');
                        }
                        
                        // Rafra√Æchir les donn√©es
                        fetchUserPredictions();
                        fetchUserCapital();
                    }
                } catch (error) {
                    console.error('Auto-finalize error:', error);
                }
            };
            
            // Polling automatique toutes les 60 secondes pour les matchs actifs
            useEffect(() => {
                if (!user || activePredictions.length === 0) {
                    setLivePollingActive(false);
                    return;
                }
                
                // V√©rifier s'il y a des matchs en cours (status = active ou analyzing)
                const liveMatches = activePredictions.filter(p => 
                    p.status === 'active' || p.status === 'validated'
                );
                
                if (liveMatches.length === 0) {
                    setLivePollingActive(false);
                    return;
                }
                
                setLivePollingActive(true);
                console.log(`üîÑ Starting live polling for ${liveMatches.length} match(es)`);
                
                const pollInterval = setInterval(async () => {
                    console.log('üîç Checking live status...');
                    
                    for (const prediction of liveMatches) {
                        const liveStatus = await checkMatchLiveStatus(prediction);
                        
                        if (!liveStatus) continue;
                        
                        // Match termin√© ‚Üí Auto-finaliser
                        if (liveStatus.isFinished) {
                            console.log(`üèÅ Match ${prediction.matchInfo?.homeTeam} vs ${prediction.matchInfo?.awayTeam} termin√©!`);
                            await autoFinalizeMatch(prediction.id);
                        }
                        // Mi-temps atteinte ‚Üí Sugg√©rer hedging
                        else if (liveStatus.canHedge && !prediction.hedgingSuggested) {
                            console.log(`‚öΩ Mi-temps atteinte pour ${prediction.matchInfo?.homeTeam} vs ${prediction.matchInfo?.awayTeam}`);
                            showNotification(
                                `‚öΩ Mi-temps ! ${prediction.matchInfo?.homeTeam} vs ${prediction.matchInfo?.awayTeam} - Score: ${liveStatus.score?.home || 0}-${liveStatus.score?.away || 0}. Voulez-vous couvrir ?`,
                                'warning'
                            );
                            // Marquer comme sugg√©r√© pour ne pas r√©p√©ter
                            prediction.hedgingSuggested = true;
                        }
                        // Match commenc√©
                        else if (liveStatus.hasStarted && !prediction.matchStarted) {
                            console.log(`üü¢ Match commenc√©: ${prediction.matchInfo?.homeTeam} vs ${prediction.matchInfo?.awayTeam}`);
                            showNotification(
                                `üü¢ Coup d'envoi ! ${prediction.matchInfo?.homeTeam} vs ${prediction.matchInfo?.awayTeam}`,
                                'info'
                            );
                            prediction.matchStarted = true;
                        }
                        
                        // Mettre √† jour le statut live dans la pr√©diction
                        setActivePredictions(prev => prev.map(p => 
                            p.id === prediction.id 
                                ? { ...p, liveStatus, hedgingSuggested: prediction.hedgingSuggested, matchStarted: prediction.matchStarted }
                                : p
                        ));
                    }
                }, 60000); // Toutes les 60 secondes
                
                // V√©rifier imm√©diatement au montage
                (async () => {
                    for (const prediction of liveMatches) {
                        const liveStatus = await checkMatchLiveStatus(prediction);
                        if (liveStatus) {
                            setActivePredictions(prev => prev.map(p => 
                                p.id === prediction.id ? { ...p, liveStatus } : p
                            ));
                        }
                    }
                })();
                
                return () => {
                    console.log('üõë Stopping live polling');
                    clearInterval(pollInterval);
                };
            }, [user, activePredictions.length]);
            // ==================================================================

            // Helper pour les messages d'erreur Firebase
            const getFirebaseErrorMessage = (code) => {
                const messages = {
                    'auth/invalid-email': 'Email invalide',
                    'auth/user-disabled': 'Compte d√©sactiv√©',
                    'auth/user-not-found': 'Aucun compte avec cet email',
                    'auth/wrong-password': 'Mot de passe incorrect',
                    'auth/email-already-in-use': 'Email d√©j√† utilis√©',
                    'auth/weak-password': 'Mot de passe trop faible (min 6 caract√®res)',
                    'auth/network-request-failed': 'Erreur r√©seau'
                };
                return messages[code] || 'Erreur de connexion';
            };

            const showNotification = (message, type = 'info') => {
                setNotification({ message, type });
                setTimeout(() => setNotification(null), 3000);
            };

            // Fetch opportunities from Firebase via API
            const fetchOpportunities = async () => {
                setLoading(true);
                try {
                    const response = await fetch(`${API_BASE_URL}/opportunities`);
                    const data = await response.json();
                    setMatches(data.opportunities || []);
                } catch (error) {
                    console.error('Error fetching opportunities:', error);
                    // Donn√©es de d√©mo si API indisponible
                    setMatches([
                        { id: '1', homeTeam: 'PSG', awayTeam: 'Marseille', fixtureId: 123456, league: 'Ligue 1', matchDate: new Date(Date.now() + 86400000).toISOString(), status: 'upcoming' },
                        { id: '2', homeTeam: 'Real Madrid', awayTeam: 'Barcelona', fixtureId: 234567, league: 'La Liga', matchDate: new Date(Date.now() + 172800000).toISOString(), status: 'upcoming' },
                        { id: '3', homeTeam: 'Man City', awayTeam: 'Liverpool', fixtureId: 345678, league: 'Premier League', matchDate: new Date(Date.now() + 259200000).toISOString(), status: 'upcoming' }
                    ]);
                }
                setLoading(false);
            };

            // Analyze prediction via API
            const analyzePrediction = async (opportunityId, balance, bookmaker = 'default') => {
                // V√©rifier le token d'authentification
                const token = localStorage.getItem('authToken');
                if (!token) {
                    showNotification("Vous devez √™tre connect√© pour analyser", "error");
                    requireAuth('balance-input');
                    return;
                }

                console.log('üîÆ Starting analysis...', { opportunityId, balance, bookmaker });

                // 1. Cr√©er imm√©diatement une pr√©diction avec statut "analyzing"
                const tempPrediction = {
                    id: `temp_${Date.now()}`,
                    matchId: opportunityId,
                    match: selectedMatch,
                    matchInfo: {
                        homeTeam: selectedMatch?.homeTeam || '√âquipe A',
                        awayTeam: selectedMatch?.awayTeam || '√âquipe B',
                        league: selectedMatch?.league || 'Championnat',
                        matchDate: selectedMatch?.matchDate || selectedMatch?.date,
                        fixtureId: selectedMatch?.fixtureId || opportunityId
                    },
                    meta: {
                        homeTeam: selectedMatch?.homeTeam,
                        awayTeam: selectedMatch?.awayTeam,
                        league: selectedMatch?.league
                    },
                    selectedBookmaker: bookmaker,
                    userBalance: balance,
                    status: 'analyzing',
                    createdAt: new Date().toISOString(),
                    isAnalyzing: true
                };

                // Ajouter aux pronostics actifs imm√©diatement
                setActivePredictions(prev => [tempPrediction, ...prev.filter(p => p.matchId !== opportunityId)]);
                
                // 2. Rediriger imm√©diatement vers "Pronos en cours"
                showNotification("üîÑ Analyse lanc√©e ! Vous pouvez suivre la progression.", "info");
                navigate('pronostics');

                // 3. Lancer l'analyse en arri√®re-plan
                try {
                    const response = await apiCallWithAuth(
                        `${API_BASE_URL}/predictions/analyze`,
                        {
                            method: 'POST',
                            body: JSON.stringify({ opportunityId, userBalance: balance, bookmaker })
                        }
                    );

                    console.log('üì° Response status:', response.status);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || `Erreur ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('‚úÖ Analysis result:', data);

                    if (data.prediction) {
                        // 4. Mettre √† jour la pr√©diction avec les r√©sultats
                        const completedPrediction = {
                            ...data.prediction,
                            id: data.prediction.id || tempPrediction.id,
                            matchId: opportunityId,
                            match: selectedMatch,
                            matchInfo: tempPrediction.matchInfo,
                            status: 'analyzed', // Nouveau statut: analyse termin√©e, en attente de validation
                            createdAt: tempPrediction.createdAt,
                            analyzedAt: new Date().toISOString(),
                            isAnalyzing: false
                        };
                        
                        // Remplacer la pr√©diction temporaire par la compl√®te
                        setActivePredictions(prev => prev.map(p => 
                            (p.id === tempPrediction.id || p.matchId === opportunityId) 
                                ? completedPrediction 
                                : p
                        ));
                        
                        setCurrentPrediction(completedPrediction);
                        setUserBalance(balance);
                        
                        showNotification("‚úÖ Analyse termin√©e ! Consultez les r√©sultats.", "success");
                        
                        // Notification navigateur
                        NotificationService.analysisComplete(
                            `${selectedMatch?.homeTeam || 'Match'} vs ${selectedMatch?.awayTeam || ''}`
                        );
                    } else {
                        throw new Error("R√©ponse invalide du serveur");
                    }
                } catch (error) {
                    console.error('‚ùå Error analyzing prediction:', error);
                    
                    // Fallback avec donn√©es de d√©mo si erreur
                    if (error.message.includes('fetch') || error.message.includes('network') || error.message.includes('Erreur')) {
                        console.log('üì¶ Using demo data...');
                        const demoData = generateDemoPrediction(selectedMatch, balance, bookmaker);
                        
                        const demoPrediction = {
                            ...demoData,
                            id: tempPrediction.id.replace('temp_', 'demo_'),
                            matchId: opportunityId,
                            match: selectedMatch,
                            matchInfo: tempPrediction.matchInfo,
                            status: 'analyzed',
                            createdAt: tempPrediction.createdAt,
                            analyzedAt: new Date().toISOString(),
                            isAnalyzing: false,
                            isDemo: true
                        };
                        
                        setActivePredictions(prev => prev.map(p => 
                            (p.id === tempPrediction.id || p.matchId === opportunityId) 
                                ? demoPrediction 
                                : p
                        ));
                        
                        setCurrentPrediction(demoPrediction);
                        setUserBalance(balance);
                        
                        showNotification("‚úÖ Analyse termin√©e (mode d√©mo)", "info");
                    } else {
                        // Marquer comme erreur
                        setActivePredictions(prev => prev.map(p => 
                            p.id === tempPrediction.id 
                                ? { ...p, status: 'error', error: error.message, isAnalyzing: false }
                                : p
                        ));
                        showNotification(`‚ùå Erreur: ${error.message}`, "error");
                    }
                }
            };

            // Fonction pour g√©n√©rer des donn√©es de d√©mo
            const generateDemoPrediction = (match, balance, bookmaker) => {
                const homeTeam = match?.homeTeam || '√âquipe A';
                const awayTeam = match?.awayTeam || '√âquipe B';
                
                return {
                    matchAnalysis: {
                        claude: {
                            enjeu: {
                                teamA: { description: "Match important pour le classement", motivation: "high" },
                                teamB: { description: "Cherche √† surprendre", motivation: "medium" }
                            },
                            btts: { 
                                probability: 0.65, 
                                prediction: "oui", 
                                analysis: "Les deux √©quipes ont des attaques performantes et des d√©fenses perfectibles. Historiquement, leurs confrontations produisent des buts des deux c√¥t√©s." 
                            },
                            winner: { 
                                teamA: { probability: 0.55, analysis: "Avantage du terrain et meilleure forme r√©cente" },
                                teamB: { probability: 0.25, analysis: "Difficult√©s √† l'ext√©rieur cette saison" },
                                draw: { probability: 0.20, analysis: "Possible si match serr√©" },
                                prediction: 'teamA',
                                confidence: 'medium'
                            },
                            totalGoals: { 
                                expected: 2.8, 
                                over15: 0.85,
                                over25: 0.68,
                                over35: 0.42,
                                analysis: "Moyenne de 2.8 buts par match entre ces √©quipes"
                            },
                            trend: {
                                globalAnalysis: "Match offensif attendu avec un l√©ger avantage pour l'√©quipe √† domicile",
                                scenarios: [
                                    { description: `Victoire ${homeTeam} 2-1`, probability: 0.22 },
                                    { description: `Victoire ${homeTeam} 2-0`, probability: 0.18 },
                                    { description: "Match nul 1-1", probability: 0.15 }
                                ]
                            },
                            _thinking: "[Mode d√©mo - Simulation de r√©flexion IA]"
                        },
                        deepseek: {
                            btts: { probability: 0.62 },
                            winner: { prediction: "teamA", confidence: "medium" },
                            _thinking: "[Mode d√©mo - Simulation de raisonnement]"
                        }
                    },
                    oddsAnalysis: {
                        recommendedOptions: [
                            { option: `Victoire ${homeTeam}`, odds: 1.45, estimatedProbability: 0.55, riskLevel: "low", value: 1.20, reasoning: "Cote sous-√©valu√©e par rapport √† notre estimation" },
                            { option: "Plus de 2.5 buts", odds: 1.70, estimatedProbability: 0.68, riskLevel: "medium", value: 1.15, reasoning: "Bon ratio risque/rendement" },
                            { option: "BTTS Oui", odds: 1.85, estimatedProbability: 0.65, riskLevel: "medium", value: 1.21, reasoning: "Value int√©ressante bas√©e sur l'historique" }
                        ],
                        bestValue: "BTTS Oui",
                        safestOption: `Victoire ${homeTeam}`
                    },
                    synthesis: {
                        synthesis: "Les deux IA s'accordent sur une victoire probable de l'√©quipe √† domicile avec des buts des deux c√¥t√©s",
                        consensusPoints: ["Victoire domicile probable", "Match avec des buts (Over 2.5)", "BTTS probable"],
                        divergencePoints: [],
                        coverageScore: 0.75,
                        valueScore: 0.82
                    },
                    stakes: {
                        totalBudget: Math.round(balance * 0.06),
                        maxBudgetAllowed: Math.round(balance * 0.06),
                        stakes: [
                            { option: `Victoire ${homeTeam}`, odds: 1.45, adjustedStake: Math.round(balance * 0.025), potentialReturn: Math.round(balance * 0.025 * 1.45), kellyPercentage: 2.5 },
                            { option: "Plus de 2.5 buts", odds: 1.70, adjustedStake: Math.round(balance * 0.02), potentialReturn: Math.round(balance * 0.02 * 1.70), kellyPercentage: 2.0 },
                            { option: "BTTS Oui", odds: 1.85, adjustedStake: Math.round(balance * 0.015), potentialReturn: Math.round(balance * 0.015 * 1.85), kellyPercentage: 1.5 }
                        ],
                        totalStake: Math.round(balance * 0.06),
                        expectedValue: Math.round(balance * 0.06 * 0.15),
                        riskLevel: "medium"
                    },
                    selectedBookmaker: {
                        key: bookmaker,
                        name: bookmaker.charAt(0).toUpperCase() + bookmaker.slice(1),
                        optionsCount: 15
                    },
                    meta: {
                        homeTeam,
                        awayTeam,
                        league: match?.league || 'Championnat',
                        aiEngines: {
                            primary: "Claude (Extended Thinking) - Mode D√©mo",
                            secondary: "DeepSeek (Reasoner) - Mode D√©mo"
                        },
                        generatedAt: new Date().toISOString()
                    }
                };
            };

            const value = {
                currentPage, navigate, goBack, requireAuth,
                user, login, logout, pendingPage, setPendingPage,
                matches, fetchOpportunities, selectedMatch, setSelectedMatch,
                userBalance, setUserBalance, currentPrediction, setCurrentPrediction,
                activePredictions, setActivePredictions,
                selectedOptions, setSelectedOptions,
                analyzePrediction,
                fetchUserPredictions, fetchUserCapital, getValidToken, apiCallWithAuth,
                loading, setLoading, loadingMessage, setLoadingMessage,
                notification, showNotification,
                livePollingActive,
                API_BASE_URL
            };

            return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
        };

        const useApp = () => useContext(AppContext);

        // ============== COMPOSANTS ==============
        
        const Header = ({ showBack = false, title = '' }) => {
            const { goBack, user, navigate, logout } = useApp();
            
            return (
                <header className="header">
                    {showBack ? (
                        <button className="back-btn" onClick={goBack}>
                            <Icons.ArrowLeft />
                            Retour
                        </button>
                    ) : (
                        <div className="logo">E-Cauri</div>
                    )}
                    
                    {title && <span className="page-title">{title}</span>}
                    
                    <div 
                        className={`header-icon ${user ? 'connected' : ''}`}
                        onClick={() => user ? logout() : navigate('login')}
                    >
                        <Icons.User />
                    </div>
                </header>
            );
        };

        const BottomNav = () => {
            const { currentPage, navigate, requireAuth } = useApp();
            
            const navItems = [
                { id: 'pronostics', label: 'Pronos', icon: Icons.Target },
                { id: 'outils', label: 'Outils', icon: Icons.Tool },
                { id: 'capital', label: 'Capital', icon: Icons.Chart },
                { id: 'formations', label: 'Formation', icon: Icons.Book, requireAuth: true }
            ];
            
            return (
                <nav className="bottom-nav">
                    {navItems.map(item => (
                        <button
                            key={item.id}
                            className={`nav-item ${currentPage === item.id ? 'active' : ''}`}
                            onClick={() => item.requireAuth ? requireAuth(item.id) : navigate(item.id)}
                        >
                            <item.icon />
                            <span className="nav-label">{item.label}</span>
                        </button>
                    ))}
                </nav>
            );
        };

        const LoadingOverlay = ({ text = "Analyse en cours..." }) => (
            <div className="loading-overlay">
                <div className="loading-spinner"></div>
                <div className="loading-text">{text}</div>
            </div>
        );

        // Composant de chargement global avec logo anim√©
        const GlobalLoader = ({ message }) => {
            if (!message) return null;
            
            return (
                <div style={{
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    background: 'rgba(10, 10, 10, 0.95)',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 9999
                }}>
                    {/* Logo anim√© */}
                    <div style={{
                        fontSize: '2.5rem',
                        fontWeight: 'bold',
                        marginBottom: '24px',
                        animation: 'pulse 1.5s ease-in-out infinite'
                    }}>
                        <span style={{ color: 'var(--accent-gold)' }}>E</span>
                        <span style={{ color: 'white' }}>-Cauri</span>
                    </div>
                    
                    {/* Spinner personnalis√© */}
                    <div style={{
                        width: '60px',
                        height: '60px',
                        border: '3px solid rgba(212, 175, 55, 0.2)',
                        borderTopColor: 'var(--accent-gold)',
                        borderRadius: '50%',
                        animation: 'spin 1s linear infinite',
                        marginBottom: '20px'
                    }}></div>
                    
                    {/* Message */}
                    <div style={{
                        color: 'var(--text-secondary)',
                        fontSize: '0.95rem',
                        textAlign: 'center',
                        maxWidth: '280px'
                    }}>
                        {message}
                    </div>
                    
                    {/* Barre de progression ind√©termin√©e */}
                    <div style={{
                        width: '200px',
                        height: '4px',
                        background: 'rgba(255,255,255,0.1)',
                        borderRadius: '2px',
                        marginTop: '16px',
                        overflow: 'hidden'
                    }}>
                        <div style={{
                            width: '40%',
                            height: '100%',
                            background: 'var(--accent-gold)',
                            borderRadius: '2px',
                            animation: 'loading-bar 1.5s ease-in-out infinite'
                        }}></div>
                    </div>
                </div>
            );
        };

        const Notification = ({ message, type }) => (
            <div className={`notification ${type}`}>{message}</div>
        );

        // ============== PAGES ==============

        const HomePage = () => {
            const { navigate, requireAuth, user } = useApp();
            
            return (
                <>
                    <Header />
                    <main className="main-content">
                        <div className="animate-fade-in" style={{ textAlign: 'center', marginBottom: '32px' }}>
                            <h1 style={{ fontSize: '2rem', marginBottom: '12px' }}>
                                Bienvenue sur <span style={{ color: 'var(--accent-gold)' }}>E-Cauri</span>
                            </h1>
                            <p style={{ color: 'var(--text-secondary)' }}>
                                Vos pronostics sportifs intelligents
                            </p>
                        </div>
                        
                        <div className="card card-clickable animate-fade-in delay-1" onClick={() => navigate('outils')}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                                <div style={{ background: 'var(--gradient-gold)', padding: '12px', borderRadius: '12px' }}>
                                    <Icons.Zap />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <h3>Predicator V1</h3>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.9rem' }}>
                                        Outil de pr√©diction IA
                                    </p>
                                </div>
                                <Icons.ArrowRight />
                            </div>
                        </div>

                        <div className="card card-clickable animate-fade-in delay-2" onClick={() => requireAuth('formations')}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                                <div style={{ background: 'var(--gradient-green)', padding: '12px', borderRadius: '12px', color: '#fff' }}>
                                    <Icons.Book />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <h3>Formations</h3>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.9rem' }}>
                                        Deviens un parieur pro
                                    </p>
                                </div>
                                {!user && <Icons.Lock />}
                                <Icons.ArrowRight />
                            </div>
                        </div>

                        <div className="card card-clickable animate-fade-in delay-3" onClick={() => navigate('capital')}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                                <div style={{ background: 'linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%)', padding: '12px', borderRadius: '12px', color: '#fff' }}>
                                    <Icons.TrendingUp />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <h3>Suivi Capital</h3>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.9rem' }}>
                                        √âvolution de vos gains
                                    </p>
                                </div>
                                <Icons.ArrowRight />
                            </div>
                        </div>
                    </main>
                    <BottomNav />
                </>
            );
        };

        const LoginPage = () => {
            const { login, goBack, loading, navigate, showNotification } = useApp();
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');

            const handleSubmit = async (e) => {
                e.preventDefault();
                await login(email, password);
            };

            return (
                <>
                    <Header showBack={true} title="Connexion" />
                    <main className="main-content">
                        <div className="animate-fade-in" style={{ textAlign: 'center', marginBottom: '32px' }}>
                            <div className="logo" style={{ fontSize: '2.5rem', marginBottom: '8px' }}>E-Cauri</div>
                            <p style={{ color: 'var(--text-secondary)' }}>
                                Connectez-vous pour continuer
                            </p>
                        </div>

                        <form onSubmit={handleSubmit}>
                            <div className="input-group animate-fade-in delay-1">
                                <label className="input-label">Email</label>
                                <input 
                                    type="email" 
                                    className="input" 
                                    placeholder="votre@email.com"
                                    value={email}
                                    onChange={(e) => setEmail(e.target.value)}
                                    required
                                />
                            </div>

                            <div className="input-group animate-fade-in delay-2">
                                <label className="input-label">Mot de passe</label>
                                <input 
                                    type="password" 
                                    className="input" 
                                    placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    required
                                    minLength={6}
                                />
                            </div>

                            <button 
                                type="submit" 
                                className="btn btn-primary animate-fade-in delay-3" 
                                style={{ width: '100%' }}
                                disabled={loading}
                            >
                                {loading ? 'Connexion...' : 'Se connecter'}
                            </button>
                        </form>

                        <div className="animate-fade-in delay-3" style={{ 
                            textAlign: 'center', 
                            marginTop: '24px',
                            padding: '16px',
                            borderTop: '1px solid var(--border-color)'
                        }}>
                            <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>
                                Pas encore de compte ? Contactez l'administrateur pour en cr√©er un.
                            </p>
                        </div>

                        {!firebaseAuth && (
                            <div className="animate-fade-in delay-3" style={{
                                marginTop: '24px',
                                padding: '12px',
                                background: 'rgba(251, 191, 36, 0.1)',
                                borderRadius: '8px',
                                border: '1px solid rgba(251, 191, 36, 0.3)'
                            }}>
                                <p style={{ color: 'var(--accent-gold)', fontSize: '0.85rem', textAlign: 'center' }}>
                                    ‚ö†Ô∏è Mode d√©mo - Firebase non configur√©
                                </p>
                            </div>
                        )}
                    </main>
                </>
            );
        };

        const OutilsPage = () => {
            const { navigate } = useApp();

            return (
                <>
                    <Header showBack={true} title="Outils" />
                    <main className="main-content">
                        <h2 className="section-title animate-fade-in">Outils disponibles</h2>
                        
                        <div className="card card-clickable animate-fade-in delay-1" onClick={() => navigate('matchs')}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                                <div style={{ background: 'var(--gradient-gold)', padding: '16px', borderRadius: '12px' }}>
                                    <Icons.Target />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <h3>PREDICATOR V1</h3>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.9rem' }}>
                                        Analyse IA des matchs avec recommandations de paris
                                    </p>
                                </div>
                                <Icons.ArrowRight />
                            </div>
                        </div>

                        <p className="section-subtitle animate-fade-in delay-2" style={{ marginTop: '24px' }}>
                            D'autres outils arrivent bient√¥t...
                        </p>
                    </main>
                    <BottomNav />
                </>
            );
        };

        const MatchsPage = () => {
            const { matches, fetchOpportunities, setSelectedMatch, navigate, loading } = useApp();

            useEffect(() => {
                fetchOpportunities();
            }, []);

            const handleSelectMatch = (match) => {
                setSelectedMatch(match);
                navigate('balance-input');
            };

            const formatDate = (dateStr, formattedDate) => {
                // Utiliser la date format√©e si disponible
                if (formattedDate) return formattedDate;
                
                const date = new Date(dateStr);
                return date.toLocaleDateString('fr-FR', { 
                    weekday: 'short', 
                    day: 'numeric', 
                    month: 'short',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            };

            return (
                <>
                    <Header showBack={true} title="Matchs √† venir" />
                    <main className="main-content">
                        <h2 className="section-title animate-fade-in">S√©lectionnez un match</h2>
                        <p className="section-subtitle animate-fade-in" style={{ marginBottom: '16px' }}>
                            {matches.length} match{matches.length > 1 ? 's' : ''} disponible{matches.length > 1 ? 's' : ''}
                        </p>
                        
                        {loading ? (
                            <div className="loading-spinner"></div>
                        ) : matches.length === 0 ? (
                            <div className="empty-state">
                                <Icons.AlertCircle />
                                <p>Aucun match disponible pour le moment</p>
                                <button className="btn btn-secondary" onClick={fetchOpportunities} style={{ marginTop: '16px' }}>
                                    Actualiser
                                </button>
                            </div>
                        ) : (
                            matches.map((match, index) => (
                                <div 
                                    key={match.id} 
                                    className={`card card-clickable animate-fade-in delay-${Math.min(index + 1, 5)}`}
                                    onClick={() => handleSelectMatch(match)}
                                >
                                    <div className="match-card">
                                        <div className="match-teams">
                                            <div className="team-row">
                                                {match.homeTeamLogo ? (
                                                    <img 
                                                        src={match.homeTeamLogo} 
                                                        alt={match.homeTeam}
                                                        className="team-logo"
                                                        style={{ width: '32px', height: '32px', objectFit: 'contain', background: 'white', borderRadius: '4px', padding: '2px' }}
                                                        onError={(e) => { e.target.style.display = 'none'; }}
                                                    />
                                                ) : (
                                                    <div className="team-logo" style={{ background: 'var(--bg-secondary)', width: '32px', height: '32px', borderRadius: '4px' }}></div>
                                                )}
                                                <span className="team-name">{match.homeTeam}</span>
                                                <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginLeft: 'auto' }}>DOM</span>
                                            </div>
                                            <div className="team-row">
                                                {match.awayTeamLogo ? (
                                                    <img 
                                                        src={match.awayTeamLogo} 
                                                        alt={match.awayTeam}
                                                        className="team-logo"
                                                        style={{ width: '32px', height: '32px', objectFit: 'contain', background: 'white', borderRadius: '4px', padding: '2px' }}
                                                        onError={(e) => { e.target.style.display = 'none'; }}
                                                    />
                                                ) : (
                                                    <div className="team-logo" style={{ background: 'var(--bg-secondary)', width: '32px', height: '32px', borderRadius: '4px' }}></div>
                                                )}
                                                <span className="team-name">{match.awayTeam}</span>
                                                <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginLeft: 'auto' }}>EXT</span>
                                            </div>
                                            <div className="match-meta" style={{ display: 'flex', flexDirection: 'column', gap: '4px', marginTop: '8px' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                    {match.leagueLogo && (
                                                        <img src={match.leagueLogo} alt="" style={{ width: '16px', height: '16px' }} />
                                                    )}
                                                    <span>{match.league}</span>
                                                    {match.round && <span style={{ color: 'var(--text-muted)' }}>‚Ä¢ {match.round}</span>}
                                                </div>
                                                <div style={{ color: 'var(--accent-gold)' }}>
                                                    üìÖ {formatDate(match.matchDate, match.matchDateFormatted)}
                                                    {match.matchTime && ` √† ${match.matchTime}`}
                                                </div>
                                                {match.venue && (
                                                    <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>
                                                        üèüÔ∏è {match.venue}{match.city && `, ${match.city}`}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                        <div className="match-arrow">
                                            <Icons.ArrowRight />
                                        </div>
                                    </div>
                                </div>
                            ))
                        )}
                    </main>
                    <BottomNav />
                </>
            );
        };

        const BalanceInputPage = () => {
            const { selectedMatch, analyzePrediction, loading, user, requireAuth, showNotification } = useApp();
            const [balance, setBalance] = useState('');
            const [bookmaker, setBookmaker] = useState('1xbet');
            const [bookmakers, setBookmakers] = useState({ popular: [], available: [] });
            const [loadingBookmakers, setLoadingBookmakers] = useState(true);

            // Charger les bookmakers disponibles pour ce match
            useEffect(() => {
                const fetchBookmakers = async () => {
                    setLoadingBookmakers(true);
                    try {
                        // Charger les bookmakers sp√©cifiques au match si disponible
                        if (selectedMatch?.id) {
                            const response = await fetch(`${API_BASE_URL}/opportunities/${selectedMatch.id}/bookmakers`);
                            if (response.ok) {
                                const data = await response.json();
                                setBookmakers({
                                    available: data.available || [],
                                    popular: data.popular || []
                                });
                                // S√©lectionner le premier bookmaker disponible par d√©faut
                                if (data.available?.length > 0) {
                                    setBookmaker(data.available[0].key);
                                }
                                setLoadingBookmakers(false);
                                return;
                            }
                        }
                        
                        // Fallback: charger la liste g√©n√©rale
                        const response = await fetch(`${API_BASE_URL}/bookmakers`);
                        if (response.ok) {
                            const data = await response.json();
                            setBookmakers({
                                available: [],
                                popular: data.popular || []
                            });
                        }
                    } catch (error) {
                        console.error('Error fetching bookmakers:', error);
                        // Liste par d√©faut en cas d'erreur
                        setBookmakers({
                            available: [],
                            popular: [
                                { key: '1xbet', name: '1xBet', popular: true },
                                { key: 'betway', name: 'Betway', popular: true },
                                { key: '22bet', name: '22bet', popular: true },
                                { key: 'melbet', name: 'Melbet', popular: true },
                                { key: 'bet365', name: 'Bet365', popular: true },
                                { key: 'sportybet', name: 'SportyBet', popular: true },
                                { key: 'betwinner', name: 'BetWinner', popular: true },
                                { key: '1win', name: '1win', popular: true }
                            ]
                        });
                    }
                    setLoadingBookmakers(false);
                };
                fetchBookmakers();
            }, [selectedMatch?.id]);

            const handleSubmit = async () => {
                if (!user) {
                    requireAuth('balance-input');
                    return;
                }
                if (!balance) {
                    showNotification("Veuillez entrer votre solde", "error");
                    return;
                }
                if (selectedMatch) {
                    await analyzePrediction(selectedMatch.id, parseInt(balance), bookmaker);
                }
            };

            // Grouper les bookmakers pour l'affichage
            const getBookmakerOptions = () => {
                const options = [];
                
                // D'abord les bookmakers avec cotes disponibles pour ce match
                if (bookmakers.available?.length > 0) {
                    options.push({ label: 'üìä Cotes disponibles pour ce match', options: bookmakers.available });
                }
                
                // Ensuite les bookmakers populaires en Afrique
                if (bookmakers.popular?.length > 0) {
                    const popularNotAvailable = bookmakers.popular.filter(
                        p => !bookmakers.available?.some(a => a.key === p.key)
                    );
                    if (popularNotAvailable.length > 0) {
                        options.push({ label: '‚≠ê Bookmakers populaires', options: popularNotAvailable });
                    }
                }
                
                return options;
            };

            return (
                <>
                    <Header showBack={true} title="Votre capital" />
                    <main className="main-content">
                        {selectedMatch && (
                            <div className="card animate-fade-in">
                                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                    {selectedMatch.homeTeamLogo && (
                                        <img src={selectedMatch.homeTeamLogo} alt="" style={{ width: '32px', height: '32px' }} />
                                    )}
                                    <div style={{ flex: 1 }}>
                                        <h3 style={{ marginBottom: '4px' }}>
                                            {selectedMatch.homeTeam} vs {selectedMatch.awayTeam}
                                        </h3>
                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>
                                            {selectedMatch.league} ‚Ä¢ {selectedMatch.matchDateFormatted || 'Date √† confirmer'}
                                        </p>
                                    </div>
                                    {selectedMatch.awayTeamLogo && (
                                        <img src={selectedMatch.awayTeamLogo} alt="" style={{ width: '32px', height: '32px' }} />
                                    )}
                                </div>
                            </div>
                        )}

                        <div className="input-group animate-fade-in delay-1">
                            <label className="input-label">Quel est votre solde actuel ?</label>
                            <input
                                type="number"
                                className="input"
                                placeholder="Ex: 50000"
                                value={balance}
                                onChange={(e) => setBalance(e.target.value)}
                                style={{ fontFamily: 'Space Mono, monospace', fontSize: '1.5rem', textAlign: 'center' }}
                            />
                            <span style={{ display: 'block', textAlign: 'center', color: 'var(--text-muted)', marginTop: '8px' }}>FCFA</span>
                        </div>

                        <div className="input-group animate-fade-in delay-2">
                            <label className="input-label">
                                Votre bookmaker
                                {bookmakers.available?.length > 0 && (
                                    <span style={{ 
                                        marginLeft: '8px', 
                                        fontSize: '0.75rem', 
                                        background: 'var(--accent-green)', 
                                        padding: '2px 8px', 
                                        borderRadius: '10px',
                                        color: 'white'
                                    }}>
                                        {bookmakers.available.length} avec cotes
                                    </span>
                                )}
                            </label>
                            
                            {loadingBookmakers ? (
                                <div className="input" style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '16px' }}>
                                    <span style={{ color: 'var(--text-muted)' }}>Chargement des bookmakers...</span>
                                </div>
                            ) : (
                                <select 
                                    className="input"
                                    value={bookmaker}
                                    onChange={(e) => setBookmaker(e.target.value)}
                                    style={{ padding: '12px 16px' }}
                                >
                                    {getBookmakerOptions().map((group, groupIndex) => (
                                        <optgroup key={groupIndex} label={group.label}>
                                            {group.options.map((bm) => (
                                                <option key={bm.key} value={bm.key}>
                                                    {bm.name} {bm.optionsCount ? `(${bm.optionsCount} cotes)` : ''}
                                                </option>
                                            ))}
                                        </optgroup>
                                    ))}
                                    
                                    {/* Si aucun groupe, afficher une liste simple */}
                                    {getBookmakerOptions().length === 0 && (
                                        <>
                                            <option value="1xbet">1xBet</option>
                                            <option value="betway">Betway</option>
                                            <option value="22bet">22bet</option>
                                            <option value="bet365">Bet365</option>
                                            <option value="sportybet">SportyBet</option>
                                            <option value="melbet">Melbet</option>
                                        </>
                                    )}
                                </select>
                            )}
                            
                            <p style={{ 
                                color: 'var(--text-muted)', 
                                fontSize: '0.8rem', 
                                marginTop: '8px',
                                textAlign: 'center'
                            }}>
                                Les cotes du bookmaker s√©lectionn√© seront utilis√©es pour l'analyse
                            </p>
                        </div>

                        {/* Info sur les moteurs IA */}
                        <div className="animate-fade-in delay-2" style={{
                            background: 'rgba(59, 130, 246, 0.1)',
                            border: '1px solid rgba(59, 130, 246, 0.3)',
                            borderRadius: '12px',
                            padding: '16px',
                            marginTop: '16px'
                        }}>
                            <p style={{ color: 'var(--accent-blue)', fontSize: '0.85rem', marginBottom: '8px', fontWeight: '600' }}>
                                üß† Analyse IA avanc√©e
                            </p>
                            <p style={{ color: 'var(--text-secondary)', fontSize: '0.8rem', lineHeight: '1.5' }}>
                                ‚Ä¢ <strong>Claude</strong> (Extended Thinking) - Analyse approfondie<br/>
                                ‚Ä¢ <strong>DeepSeek</strong> (Reasoner) - Validation crois√©e<br/>
                                ‚Ä¢ Calcul des mises optimales (Crit√®re de Kelly)
                            </p>
                        </div>

                        <button 
                            className="btn btn-primary animate-fade-in delay-3" 
                            style={{ width: '100%', marginTop: '24px' }}
                            onClick={handleSubmit}
                            disabled={!balance || loading || loadingBookmakers}
                        >
                            {loading ? 'üîÆ Analyse en cours...' : 'Analyser le match'}
                            {!loading && <Icons.Zap />}
                        </button>
                        
                        {balance && parseInt(balance) > 0 && (
                            <p className="animate-fade-in" style={{ 
                                textAlign: 'center', 
                                color: 'var(--text-muted)', 
                                fontSize: '0.85rem',
                                marginTop: '12px'
                            }}>
                                Budget max recommand√©: <strong style={{ color: 'var(--accent-gold)' }}>
                                    {Math.round(parseInt(balance) * 0.06).toLocaleString()} FCFA
                                </strong> (6% du capital)
                            </p>
                        )}
                    </main>
                    <BottomNav />
                    {loading && <LoadingOverlay text="üß† Analyse IA avec Claude & DeepSeek..." />}
                </>
            );
        };

        const StrategyPage = () => {
            const { currentPrediction, selectedMatch, userBalance, selectedOptions, setSelectedOptions, navigate, showNotification, activePredictions, setActivePredictions, API_BASE_URL, apiCallWithAuth } = useApp();

            // V√©rifier si les options ont d√©j√† √©t√© valid√©es (mode lecture seule)
            const alreadyValidated = currentPrediction?.selectedOptions && currentPrediction.selectedOptions.length > 0;
            const isReadOnly = alreadyValidated || currentPrediction?.status === 'active' || currentPrediction?.status === 'won' || currentPrediction?.status === 'lost';

            // Charger les options existantes si elles existent
            useEffect(() => {
                if (currentPrediction?.selectedOptions?.length > 0 && selectedOptions.length === 0) {
                    console.log('üìã Loading existing selected options:', currentPrediction.selectedOptions);
                    setSelectedOptions(currentPrediction.selectedOptions);
                }
            }, [currentPrediction?.id]);

            // R√©cup√©rer les stakes pour fusionner avec les options
            const stakes = currentPrediction?.stakes;

            const toggleOption = (option) => {
                // Bloquer si en mode lecture seule
                if (isReadOnly) {
                    showNotification("Les options ont d√©j√† √©t√© valid√©es et ne peuvent plus √™tre modifi√©es", "warning");
                    return;
                }

                // Chercher dans stakes.stakes
                const stakeInfo = stakes?.stakes?.find(s => s.option === option.option);
                
                // Calculer la stake si non disponible
                const prob = option.estimatedProbability || option.probability || 0.5;
                const odds = option.odds || 1.5;
                let stake = stakeInfo?.adjustedStake || stakeInfo?.stake || 0;
                
                if (stake === 0 && userBalance > 0) {
                    const b = odds - 1;
                    const q = 1 - prob;
                    let kellyFraction = Math.max(0, (prob * b - q) / b);
                    kellyFraction = Math.min(kellyFraction, 0.05);
                    stake = Math.round(userBalance * kellyFraction) || Math.round(userBalance * 0.02);
                }
                
                const optionWithStake = {
                    option: option.option,
                    odds: odds,
                    stake: stake,
                    adjustedStake: stake,
                    potentialReturn: Math.round(stake * odds),
                    probability: prob,
                    kellyPercentage: stakeInfo?.kellyPercentage || Math.round((stake / userBalance) * 100 * 10) / 10
                };

                console.log('üîÑ Toggle option:', optionWithStake);

                setSelectedOptions(prev => {
                    const exists = prev.find(o => o.option === option.option);
                    if (exists) {
                        return prev.filter(o => o.option !== option.option);
                    } else {
                        return [...prev, optionWithStake];
                    }
                });
            };

            const isSelected = (option) => {
                // En mode lecture seule, utiliser les options d√©j√† valid√©es
                if (isReadOnly && currentPrediction?.selectedOptions) {
                    return currentPrediction.selectedOptions.some(o => o.option === option.option);
                }
                return selectedOptions.some(o => o.option === option.option);
            };

            const handleValidate = async () => {
                if (isReadOnly) {
                    showNotification("Les options ont d√©j√† √©t√© valid√©es", "info");
                    navigate('pronostics');
                    return;
                }

                if (selectedOptions.length === 0) {
                    showNotification("S√©lectionnez au moins une option", "error");
                    return;
                }
                
                // S'assurer que chaque option a les infos de stake correctes
                const stakesList = stakes?.stakes || [];
                const optionsWithStakes = selectedOptions.map(opt => {
                    const stakeInfo = stakesList.find(s => s.option === opt.option);
                    return {
                        option: opt.option,
                        odds: opt.odds || stakeInfo?.odds || 0,
                        stake: opt.stake || opt.adjustedStake || stakeInfo?.adjustedStake || stakeInfo?.stake || 0,
                        adjustedStake: opt.adjustedStake || stakeInfo?.adjustedStake || stakeInfo?.stake || 0,
                        potentialReturn: opt.potentialReturn || stakeInfo?.potentialReturn || 
                            ((opt.stake || stakeInfo?.adjustedStake || 0) * (opt.odds || stakeInfo?.odds || 1)),
                        kellyPercentage: opt.kellyPercentage || stakeInfo?.kellyPercentage
                    };
                });
                
                console.log('üì§ Validating options with stakes:', optionsWithStakes);
                
                // Sauvegarder sur Firebase
                if (currentPrediction?.id) {
                    try {
                        // Envoyer les donn√©es compl√®tes de la pr√©diction pour le cas o√π le document n'existe pas
                        const predictionData = {
                            matchInfo: currentPrediction.matchInfo,
                            userBalance: currentPrediction.userBalance,
                            bookmaker: currentPrediction.bookmaker,
                            aiAnalysis: currentPrediction.aiAnalysis,
                            oddsAnalysis: currentPrediction.oddsAnalysis,
                            synthesis: currentPrediction.synthesis,
                            stakes: currentPrediction.stakes,
                            opportunityId: currentPrediction.opportunityId || currentPrediction.matchId
                        };
                        
                        const response = await apiCallWithAuth(
                            `${API_BASE_URL}/predictions/${currentPrediction.id}/validate`,
                            {
                                method: 'POST',
                                body: JSON.stringify({ 
                                    selectedOptions: optionsWithStakes,
                                    predictionData  // Donn√©es compl√®tes pour cr√©er le doc si n√©cessaire
                                })
                            }
                        );
                        
                        if (response.ok) {
                            console.log('‚úÖ Options validated and saved to Firebase');
                        } else {
                            console.warn('‚ö†Ô∏è Could not save to Firebase:', await response.text());
                        }
                    } catch (error) {
                        console.warn('Could not save to Firebase:', error);
                    }
                }

                // Mettre √† jour le statut du pronostic actif localement
                if (currentPrediction) {
                    setActivePredictions(prev => prev.map(p => 
                        p.id === currentPrediction.id 
                            ? { ...p, status: 'active', selectedOptions: optionsWithStakes, validatedAt: new Date().toISOString() }
                            : p
                    ));
                }
                
                showNotification("Options valid√©es ! Pr√™t pour le suivi live", "success");
                navigate('pronostics');
            };

            if (!currentPrediction) {
                return (
                    <>
                        <Header showBack={true} title="Strat√©gie" />
                        <main className="main-content">
                            <div className="empty-state">
                                <Icons.AlertCircle />
                                <p>Aucune analyse disponible</p>
                                <button 
                                    className="btn btn-primary" 
                                    style={{ marginTop: '16px' }}
                                    onClick={() => navigate('home')}
                                >
                                    S√©lectionner un match
                                </button>
                            </div>
                        </main>
                        <BottomNav />
                    </>
                );
            }

            // Adapter aux deux structures possibles (claude ou chatgpt pour r√©trocompatibilit√©)
            const analysis = currentPrediction.matchAnalysis?.claude || currentPrediction.matchAnalysis?.chatgpt || currentPrediction.aiAnalysis?.claude;
            const deepseekAnalysis = currentPrediction.matchAnalysis?.deepseek;
            
            // Chercher les options dans plusieurs sources possibles
            const getRecommendedOptions = () => {
                // 1. oddsAnalysis.recommendedOptions (source principale)
                if (currentPrediction.oddsAnalysis?.recommendedOptions?.length > 0) {
                    console.log('üìã Options from oddsAnalysis.recommendedOptions');
                    return currentPrediction.oddsAnalysis.recommendedOptions;
                }
                
                // 2. stakes.stakes (si les options sont l√†)
                if (stakes?.stakes?.length > 0) {
                    console.log('üìã Options from stakes.stakes');
                    return stakes.stakes.map(s => ({
                        option: s.option,
                        odds: s.odds,
                        estimatedProbability: s.probability || 0.5,
                        riskLevel: s.riskLevel || 'medium',
                        value: (s.probability || 0.5) * (s.odds || 1)
                    }));
                }
                
                // 3. G√©n√©rer des options par d√©faut bas√©es sur l'analyse IA
                if (analysis) {
                    console.log('üìã Generating options from AI analysis');
                    const homeTeam = currentPrediction.matchInfo?.homeTeam || currentPrediction.meta?.homeTeam || '√âquipe A';
                    const generatedOptions = [];
                    
                    // Option victoire
                    if (analysis.winner) {
                        const winProb = analysis.winner.teamA?.probability || 0.5;
                        generatedOptions.push({
                            option: `Victoire ${homeTeam}`,
                            odds: winProb > 0 ? Math.round((1 / winProb) * 100) / 100 : 1.50,
                            estimatedProbability: winProb,
                            riskLevel: winProb > 0.6 ? 'low' : winProb > 0.4 ? 'medium' : 'high'
                        });
                    }
                    
                    // Option BTTS
                    if (analysis.btts) {
                        const bttsProb = analysis.btts.probability || 0.5;
                        generatedOptions.push({
                            option: 'BTTS Oui',
                            odds: bttsProb > 0 ? Math.round((1 / bttsProb) * 100) / 100 : 1.80,
                            estimatedProbability: bttsProb,
                            riskLevel: 'medium'
                        });
                    }
                    
                    // Option Over 2.5
                    if (analysis.totalGoals?.over25) {
                        const overProb = analysis.totalGoals.over25;
                        generatedOptions.push({
                            option: 'Plus de 2.5 buts',
                            odds: overProb > 0 ? Math.round((1 / overProb) * 100) / 100 : 1.70,
                            estimatedProbability: overProb,
                            riskLevel: 'medium'
                        });
                    }
                    
                    if (generatedOptions.length > 0) {
                        return generatedOptions;
                    }
                }
                
                console.log('‚ö†Ô∏è No options found');
                return [];
            };
            
            const options = getRecommendedOptions();
            console.log('üìä Final options:', options.length, options);
            
            // stakes d√©j√† d√©clar√© plus haut
            const synthesis = currentPrediction.synthesis;
            const bookmaker = currentPrediction.selectedBookmaker || currentPrediction.bookmaker;
            const meta = currentPrediction.meta || currentPrediction.matchInfo;

            // R√©cup√©rer les probabilit√©s (adapt√©es aux diff√©rentes structures)
            const bttsProb = analysis?.btts?.probability || 0;
            const over25Prob = analysis?.totalGoals?.over25 || 0;
            const winnerProb = analysis?.winner?.teamA?.probability || 0;

            return (
                <>
                    <Header showBack={true} title="R√©sum√© & Pronos" />
                    <main className="main-content">
                        {/* Info Match */}
                        {(selectedMatch || meta) && (
                            <div className="card animate-fade-in">
                                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                    <div style={{ flex: 1 }}>
                                        <h3 style={{ marginBottom: '4px' }}>
                                            {selectedMatch?.homeTeam || meta?.homeTeam} vs {selectedMatch?.awayTeam || meta?.awayTeam}
                                        </h3>
                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>
                                            {selectedMatch?.league || meta?.league}
                                            {bookmaker && ` ‚Ä¢ Cotes ${typeof bookmaker === 'object' ? bookmaker.name : bookmaker}`}
                                        </p>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Moteurs IA utilis√©s */}
                        <div className="animate-fade-in" style={{
                            display: 'flex',
                            gap: '8px',
                            marginBottom: '16px',
                            flexWrap: 'wrap'
                        }}>
                            <span style={{
                                background: 'rgba(139, 92, 246, 0.2)',
                                color: '#a78bfa',
                                padding: '4px 12px',
                                borderRadius: '20px',
                                fontSize: '0.75rem',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '4px'
                            }}>
                                üß† Claude {analysis?._thinking ? '‚úì' : ''}
                            </span>
                            <span style={{
                                background: 'rgba(59, 130, 246, 0.2)',
                                color: '#60a5fa',
                                padding: '4px 12px',
                                borderRadius: '20px',
                                fontSize: '0.75rem',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '4px'
                            }}>
                                üîÆ DeepSeek {deepseekAnalysis?._thinking ? '‚úì' : ''}
                            </span>
                        </div>

                        {/* Analyse IA */}
                        <div className="analysis-box animate-fade-in delay-1">
                            <div className="analysis-title">
                                <Icons.Zap />
                                Analyse IA
                            </div>
                            <div className="analysis-text">
                                {analysis?.btts?.analysis || analysis?.trend?.globalAnalysis || "L'analyse sugg√®re que ce match devrait √™tre disput√© avec plusieurs opportunit√©s."}
                            </div>
                            
                            {/* Probabilit√©s */}
                            <div style={{ marginTop: '16px', display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '12px' }}>
                                <div style={{ textAlign: 'center' }}>
                                    <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem', display: 'block' }}>Victoire Dom.</span>
                                    <div style={{ fontFamily: 'Space Mono', color: 'var(--accent-green)', fontSize: '1.2rem', fontWeight: 'bold' }}>
                                        {Math.round(winnerProb * 100)}%
                                    </div>
                                </div>
                                <div style={{ textAlign: 'center' }}>
                                    <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem', display: 'block' }}>BTTS</span>
                                    <div style={{ fontFamily: 'Space Mono', color: 'var(--accent-gold)', fontSize: '1.2rem', fontWeight: 'bold' }}>
                                        {Math.round(bttsProb * 100)}%
                                    </div>
                                </div>
                                <div style={{ textAlign: 'center' }}>
                                    <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem', display: 'block' }}>+2.5 buts</span>
                                    <div style={{ fontFamily: 'Space Mono', color: 'var(--accent-blue)', fontSize: '1.2rem', fontWeight: 'bold' }}>
                                        {Math.round(over25Prob * 100)}%
                                    </div>
                                </div>
                            </div>

                            {/* Enjeu du match */}
                            {analysis?.enjeu && (
                                <div style={{ marginTop: '16px', padding: '12px', background: 'rgba(255,255,255,0.03)', borderRadius: '8px' }}>
                                    <p style={{ fontSize: '0.8rem', color: 'var(--text-muted)', marginBottom: '8px' }}>üìä Enjeu du match</p>
                                    <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>
                                        <strong style={{ color: 'var(--accent-green)' }}>Dom:</strong> {analysis.enjeu.teamA?.description || 'N/A'}
                                    </p>
                                    <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginTop: '4px' }}>
                                        <strong style={{ color: 'var(--accent-red)' }}>Ext:</strong> {analysis.enjeu.teamB?.description || 'N/A'}
                                    </p>
                                </div>
                            )}
                        </div>

                        {/* Synth√®se des 2 IA */}
                        {synthesis && (
                            <div className="animate-fade-in delay-1" style={{
                                background: 'rgba(16, 185, 129, 0.1)',
                                border: '1px solid rgba(16, 185, 129, 0.3)',
                                borderRadius: '12px',
                                padding: '16px',
                                marginBottom: '16px'
                            }}>
                                <p style={{ color: 'var(--accent-green)', fontSize: '0.85rem', marginBottom: '8px', fontWeight: '600' }}>
                                    ü§ù Consensus des IA
                                </p>
                                <p style={{ color: 'var(--text-secondary)', fontSize: '0.85rem' }}>
                                    {synthesis.synthesis || synthesis.finalRecommendation}
                                </p>
                                {synthesis.consensusPoints?.length > 0 && (
                                    <div style={{ marginTop: '8px', display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                                        {synthesis.consensusPoints.slice(0, 3).map((point, i) => (
                                            <span key={i} style={{
                                                background: 'rgba(16, 185, 129, 0.2)',
                                                padding: '2px 8px',
                                                borderRadius: '10px',
                                                fontSize: '0.75rem',
                                                color: 'var(--accent-green-light)'
                                            }}>‚úì {point}</span>
                                        ))}
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Banni√®re mode lecture seule */}
                        {isReadOnly && (
                            <div className="animate-fade-in delay-2" style={{
                                background: 'rgba(59, 130, 246, 0.1)',
                                border: '1px solid rgba(59, 130, 246, 0.3)',
                                borderRadius: '12px',
                                padding: '12px 16px',
                                marginBottom: '16px',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '10px'
                            }}>
                                <span style={{ fontSize: '1.2rem' }}>üîí</span>
                                <div>
                                    <p style={{ color: 'var(--accent-blue)', fontSize: '0.85rem', margin: 0, fontWeight: '600' }}>
                                        Options valid√©es
                                    </p>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.75rem', margin: 0 }}>
                                        Les paris ont √©t√© enregistr√©s et ne peuvent plus √™tre modifi√©s
                                    </p>
                                </div>
                            </div>
                        )}

                        <h3 className="section-title animate-fade-in delay-2">
                            {isReadOnly ? 'Options s√©lectionn√©es ‚úì' : 'Options recommand√©es'}
                        </h3>
                        {!isReadOnly && options.length > 0 && (
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                <p className="section-subtitle" style={{ margin: 0 }}>
                                    S√©lectionnez vos paris ({selectedOptions.length} s√©lectionn√©{selectedOptions.length > 1 ? 's' : ''})
                                </p>
                                <button 
                                    className="btn btn-secondary"
                                    style={{ padding: '6px 12px', fontSize: '0.75rem' }}
                                    onClick={() => {
                                        // Calculer les stakes si non disponibles
                                        let stakesList = stakes?.stakes || [];
                                        
                                        if (stakesList.length === 0 && userBalance > 0) {
                                            const maxBudget = Math.round(userBalance * 0.06);
                                            stakesList = options.slice(0, 3).map((opt, idx) => {
                                                const prob = opt.estimatedProbability || opt.probability || 0.5;
                                                const odds = opt.odds || 1.5;
                                                const b = odds - 1;
                                                const q = 1 - prob;
                                                let kellyFraction = Math.max(0, (prob * b - q) / b);
                                                kellyFraction = Math.min(kellyFraction, 0.05);
                                                const stake = Math.round(userBalance * kellyFraction) || Math.round(maxBudget / options.length);
                                                
                                                return {
                                                    option: opt.option,
                                                    odds: odds,
                                                    adjustedStake: stake,
                                                    stake: stake,
                                                    potentialReturn: Math.round(stake * odds),
                                                    kellyPercentage: Math.round(kellyFraction * 100 * 10) / 10
                                                };
                                            });
                                        }
                                        
                                        // S√©lectionner toutes les options avec leurs stakes
                                        const allOptions = options.map(opt => {
                                            const stakeInfo = stakesList.find(s => s.option === opt.option);
                                            const prob = opt.estimatedProbability || opt.probability || 0.5;
                                            const odds = opt.odds || 1.5;
                                            
                                            // Calculer la stake si non trouv√©e
                                            let stake = stakeInfo?.adjustedStake || stakeInfo?.stake || 0;
                                            if (stake === 0 && userBalance > 0) {
                                                const b = odds - 1;
                                                const q = 1 - prob;
                                                let kellyFraction = Math.max(0, (prob * b - q) / b);
                                                kellyFraction = Math.min(kellyFraction, 0.05);
                                                stake = Math.round(userBalance * kellyFraction) || Math.round(userBalance * 0.02);
                                            }
                                            
                                            return {
                                                option: opt.option,
                                                odds: odds,
                                                stake: stake,
                                                adjustedStake: stake,
                                                potentialReturn: Math.round(stake * odds),
                                                kellyPercentage: stakeInfo?.kellyPercentage || Math.round((stake / userBalance) * 100 * 10) / 10,
                                                probability: prob
                                            };
                                        });
                                        
                                        console.log('üì§ All options selected with stakes:', allOptions);
                                        setSelectedOptions(allOptions);
                                        showNotification(`${allOptions.length} options s√©lectionn√©es avec mises calcul√©es`, "success");
                                    }}
                                >
                                    ‚úÖ Tout s√©lectionner
                                </button>
                            </div>
                        )}

                        {/* Message si aucune option */}
                        {options.length === 0 && !isReadOnly && (
                            <div style={{ 
                                padding: '20px', 
                                textAlign: 'center', 
                                background: 'rgba(239, 68, 68, 0.1)',
                                borderRadius: '12px',
                                marginBottom: '16px'
                            }}>
                                <Icons.AlertCircle style={{ color: 'var(--accent-red)', marginBottom: '8px' }} />
                                <p style={{ color: 'var(--accent-red)', margin: 0 }}>
                                    Aucune option recommand√©e disponible
                                </p>
                                <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem', marginTop: '8px' }}>
                                    L'analyse n'a pas pu g√©n√©rer d'options. Veuillez r√©essayer.
                                </p>
                            </div>
                        )}

                        {options.map((option, index) => {
                            const prob = option.estimatedProbability || option.probability || 0;
                            const value = option.value || (prob * option.odds);
                            const stakeInfo = stakes?.stakes?.find(s => s.option === option.option);
                            const selected = isSelected(option);
                            
                            // En mode lecture seule, n'afficher que les options s√©lectionn√©es
                            if (isReadOnly && !selected) return null;
                            
                            return (
                                <div 
                                    key={option.option}
                                    className={`option-card animate-fade-in delay-${Math.min(index + 2, 5)} ${selected ? 'selected' : ''}`}
                                    onClick={() => toggleOption(option)}
                                    style={{ cursor: isReadOnly ? 'default' : 'pointer' }}
                                >
                                    <div className="option-header">
                                        <span className="option-name">{option.option}</span>
                                        <span className="option-odds">{option.odds?.toFixed(2) || 'N/A'}</span>
                                    </div>
                                    <div className="option-prob">
                                        Probabilit√©: {Math.round(prob * 100)}% ‚Ä¢ 
                                        Value: {typeof value === 'number' ? value.toFixed(2) : 'N/A'}
                                        {option.riskLevel && (
                                            <span style={{
                                                marginLeft: '8px',
                                                padding: '2px 6px',
                                                borderRadius: '4px',
                                                fontSize: '0.7rem',
                                                background: option.riskLevel === 'low' ? 'var(--accent-green)' : 
                                                           option.riskLevel === 'high' ? 'var(--accent-red)' : 'var(--accent-gold)',
                                                color: 'white'
                                            }}>
                                                {option.riskLevel === 'low' ? 'üü¢ S√ªr' : option.riskLevel === 'high' ? 'üî¥ Risqu√©' : 'üü° Mod√©r√©'}
                                            </span>
                                        )}
                                    </div>
                                    {stakeInfo && (
                                        <div style={{ marginTop: '8px', fontSize: '0.8rem', color: 'var(--accent-gold)' }}>
                                            üí∞ Mise: {(stakeInfo.adjustedStake || stakeInfo.stake)?.toLocaleString()} FCFA
                                        </div>
                                    )}
                                    {option.reasoning && !isReadOnly && (
                                        <div style={{ marginTop: '6px', fontSize: '0.75rem', color: 'var(--text-muted)', fontStyle: 'italic' }}>
                                            {option.reasoning}
                                        </div>
                                    )}
                                </div>
                            );
                        })}

                        {/* Mises recommand√©es */}
                        {(() => {
                            // Calculer les stakes avec fallback
                            let stakesList = stakes?.stakes || [];
                            
                            // Si pas de stakes mais des options, calculer les stakes
                            if (stakesList.length === 0 && options.length > 0 && userBalance > 0) {
                                console.log('üìä Calculating stakes from options...');
                                const maxBudget = Math.round(userBalance * 0.06);
                                
                                stakesList = options.slice(0, 3).map((opt, idx) => {
                                    const prob = opt.estimatedProbability || opt.probability || 0.5;
                                    const odds = opt.odds || 1.5;
                                    
                                    // Kelly simplifi√©
                                    const b = odds - 1;
                                    const q = 1 - prob;
                                    let kellyFraction = Math.max(0, (prob * b - q) / b);
                                    kellyFraction = Math.min(kellyFraction, 0.05);
                                    
                                    const stake = Math.round(userBalance * kellyFraction) || Math.round(maxBudget / options.length);
                                    
                                    return {
                                        option: opt.option,
                                        odds: odds,
                                        stake: stake,
                                        adjustedStake: stake,
                                        potentialReturn: Math.round(stake * odds),
                                        kellyPercentage: Math.round(kellyFraction * 100 * 10) / 10
                                    };
                                });
                                
                                console.log('üìä Calculated stakes:', stakesList);
                            }
                            
                            const totalBudget = stakes?.totalBudget || stakes?.totalStake || 
                                stakesList.reduce((sum, s) => sum + (s.adjustedStake || s.stake || 0), 0) ||
                                Math.round((userBalance || 0) * 0.06);
                            
                            console.log('üìä Stakes debug:', { stakesFromPred: stakes?.stakes?.length, calculatedStakes: stakesList.length, totalBudget, userBalance });
                            
                            if (stakesList.length === 0 && options.length === 0) return null;
                            
                            return (
                                <div className="recommendation-box animate-fade-in delay-4">
                                    <div className="recommendation-title">
                                        <Icons.DollarSign />
                                        Mises recommand√©es (Kelly)
                                    </div>
                                    <div style={{ color: 'var(--text-secondary)', fontSize: '0.9rem', marginBottom: '12px' }}>
                                        Budget total: <span style={{ color: 'var(--accent-gold)', fontFamily: 'Space Mono', fontWeight: 'bold' }}>
                                            {totalBudget?.toLocaleString() || '0'} FCFA
                                        </span>
                                        <span style={{ color: 'var(--text-muted)' }}> (6% de {userBalance?.toLocaleString() || '0'} FCFA)</span>
                                    </div>
                                    
                                    {stakesList.length > 0 ? (
                                        stakesList.map((stake, i) => {
                                            const stakeAmount = stake.adjustedStake || stake.stake || 0;
                                            const odds = stake.odds || 1;
                                            const potentialReturn = stake.potentialReturn || Math.round(stakeAmount * odds);
                                            
                                            return (
                                                <div key={i} style={{ 
                                                    display: 'flex', 
                                                    justifyContent: 'space-between', 
                                                    alignItems: 'center',
                                                    padding: '8px 0',
                                                    borderBottom: i < stakesList.length - 1 ? '1px solid var(--border-color)' : 'none'
                                                }}>
                                                    <div>
                                                        <span style={{ color: 'var(--text-primary)' }}>{stake.option}</span>
                                                        <span style={{ 
                                                            marginLeft: '8px', 
                                                            color: 'var(--accent-gold)', 
                                                            fontSize: '0.8rem',
                                                            fontFamily: 'Space Mono'
                                                        }}>
                                                            @{odds.toFixed(2)}
                                                        </span>
                                                        {stake.kellyPercentage && (
                                                            <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginLeft: '8px' }}>
                                                                ({stake.kellyPercentage}%)
                                                            </span>
                                                        )}
                                                    </div>
                                                    <div style={{ textAlign: 'right' }}>
                                                        <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-green)', fontWeight: 'bold' }}>
                                                            {stakeAmount.toLocaleString()} FCFA
                                                        </span>
                                                        <span style={{ display: 'block', fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                                            ‚Üí {potentialReturn.toLocaleString()} FCFA
                                                        </span>
                                                    </div>
                                                </div>
                                            );
                                        })
                                    ) : (
                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem', textAlign: 'center', padding: '12px 0' }}>
                                            S√©lectionnez des options pour voir les mises recommand√©es
                                        </p>
                                    )}
                                    
                                    {stakes?.expectedValue && (
                                        <div style={{ marginTop: '12px', padding: '8px', background: 'rgba(16, 185, 129, 0.1)', borderRadius: '8px' }}>
                                            <span style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>Expected Value: </span>
                                            <span style={{ color: 'var(--accent-green)', fontFamily: 'Space Mono' }}>
                                                +{stakes.expectedValue?.toLocaleString()} FCFA
                                            </span>
                                        </div>
                                    )}
                                </div>
                            );
                        })()}

                        {/* Bouton Valider ou Retour */}
                        {isReadOnly ? (
                            <button 
                                className="btn btn-secondary animate-fade-in delay-5" 
                                style={{ width: '100%', marginTop: '20px', marginBottom: '20px' }}
                                onClick={() => navigate('pronostics')}
                            >
                                <Icons.ArrowLeft />
                                Retour aux pronostics
                            </button>
                        ) : (
                            <button 
                                className="btn btn-primary animate-fade-in delay-5" 
                                style={{ width: '100%', marginTop: '20px', marginBottom: '20px' }}
                                onClick={handleValidate}
                                disabled={selectedOptions.length === 0}
                            >
                                {selectedOptions.length === 0 ? 'S√©lectionnez des options' : `Valider ${selectedOptions.length} option${selectedOptions.length > 1 ? 's' : ''}`}
                                <Icons.Check />
                            </button>
                        )}
                    </main>
                    <BottomNav />
                </>
            );
        };

        const PronosticsPage = () => {
            const { activePredictions, navigate, user, requireAuth, setCurrentPrediction, currentPrediction, selectedOptions, setSelectedOptions, fetchUserPredictions, showNotification, livePollingActive, API_BASE_URL, apiCallWithAuth } = useApp();

            // Fonction pour demander le hedging
            const requestHedging = async (prediction) => {
                try {
                    const response = await apiCallWithAuth(
                        `${API_BASE_URL}/hedging/strategy`,
                        {
                            method: 'POST',
                            body: JSON.stringify({ predictionId: prediction.id })
                        }
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        setCurrentPrediction({ ...prediction, hedgingStrategy: data.strategy });
                        navigate('cashout');
                    } else {
                        const error = await response.json();
                        showNotification(error.message || 'Hedging non disponible', 'warning');
                    }
                } catch (error) {
                    showNotification('Erreur lors de la demande de hedging', 'error');
                }
            };

            // Extraire les infos du match depuis diff√©rentes structures possibles
            const getMatchInfo = (pred) => {
                const match = pred.match || pred.matchInfo || {};
                return {
                    homeTeam: match.homeTeam || pred.meta?.homeTeam || '√âquipe A',
                    awayTeam: match.awayTeam || pred.meta?.awayTeam || '√âquipe B',
                    league: match.league || pred.meta?.league || 'Championnat'
                };
            };

            // Extraire les options (valid√©es ou recommand√©es)
            const getOptions = (pred) => {
                console.log('üìã getOptions called for:', pred.id, {
                    selectedOptions: pred.selectedOptions?.length || 0,
                    stakesStakes: pred.stakes?.stakes?.length || 0,
                    recommendedOptions: pred.oddsAnalysis?.recommendedOptions?.length || 0
                });
                
                // 1. D'abord chercher les options VALID√âES par l'utilisateur
                if (pred.selectedOptions && pred.selectedOptions.length > 0) {
                    const stakesList = pred.stakes?.stakes || [];
                    
                    return pred.selectedOptions.map(opt => {
                        const stakeInfo = stakesList.find(s => s.option === opt.option);
                        // Essayer plusieurs sources pour la mise
                        const stake = opt.stake || opt.adjustedStake || stakeInfo?.adjustedStake || stakeInfo?.stake || 0;
                        const odds = opt.odds || stakeInfo?.odds || 0;
                        
                        console.log(`  Option "${opt.option}": stake=${stake}, odds=${odds}`);
                        
                        return {
                            option: opt.option,
                            stake: stake,
                            odds: odds,
                            potentialReturn: opt.potentialReturn || stakeInfo?.potentialReturn || Math.round(stake * odds),
                            isValidated: true
                        };
                    });
                }
                
                // 2. Sinon, retourner les options recommand√©es (pour permettre validation)
                if (pred.stakes?.stakes && pred.stakes.stakes.length > 0) {
                    return pred.stakes.stakes.map(s => ({
                        option: s.option,
                        stake: s.adjustedStake || s.stake || 0,
                        odds: s.odds || 0,
                        potentialReturn: s.potentialReturn || Math.round((s.adjustedStake || s.stake || 0) * (s.odds || 1)),
                        isValidated: false
                    }));
                }
                
                // 3. Ou depuis oddsAnalysis
                if (pred.oddsAnalysis?.recommendedOptions && pred.oddsAnalysis.recommendedOptions.length > 0) {
                    return pred.oddsAnalysis.recommendedOptions.map(opt => ({
                        option: opt.option,
                        stake: 0,
                        odds: opt.odds || 0,
                        potentialReturn: 0,
                        isValidated: false
                    }));
                }
                
                return [];
            };

            // V√©rifier si l'utilisateur a valid√© des options
            const hasValidatedOptions = (pred) => {
                return pred.selectedOptions && pred.selectedOptions.length > 0;
            };
            
            // V√©rifier si des options recommand√©es existent
            const hasRecommendedOptions = (pred) => {
                return (pred.stakes?.stakes?.length > 0) || 
                       (pred.oddsAnalysis?.recommendedOptions?.length > 0);
            };

            // V√©rifier si le match est termin√©
            const isMatchFinished = (pred) => {
                // V√©rifier via le statut live
                if (pred.liveStatus?.matchStatus?.isFinished) {
                    return true;
                }
                // V√©rifier via le statut de la pr√©diction
                const status = pred.status?.toLowerCase();
                if (status === 'won' || status === 'lost' || status === 'finished') {
                    return true;
                }
                return false;
            };

            const handleHedging = (pred) => {
                // V√©rifier si le match a commenc√© avant d'autoriser
                if (!isMatchStarted(pred)) {
                    showNotification("Le match n'a pas encore commenc√©. La couverture sera disponible apr√®s le coup d'envoi.", "warning");
                    return;
                }
                setCurrentPrediction(pred);
                navigate('cashout');
            };

            // Fonction pour calculer le break-even (sortir position)
            const handleBreakEven = (pred) => {
                setCurrentPrediction({ ...pred, breakEvenMode: true });
                navigate('cashout');
            };

            const handleViewDetails = (pred) => {
                // R√©initialiser les options s√©lectionn√©es pour charger celles de la pr√©diction
                setSelectedOptions([]);
                setCurrentPrediction(pred);
                navigate('strategy');
            };

            // Rafra√Æchir les pr√©dictions
            const handleRefresh = async () => {
                showNotification('Actualisation...', 'info');
                await fetchUserPredictions();
                showNotification('Liste actualis√©e', 'success');
            };

            // Filtrer et d√©dupliquer les pr√©dictions
            // Afficher: pr√©dictions non termin√©es, d√©dupliqu√©es par match (garder celle avec options valid√©es)
            const activePreds = (() => {
                const filtered = activePredictions.filter(p => {
                    // Exclure les matchs termin√©s
                    const status = p.status?.toLowerCase();
                    if (status === 'won' || status === 'lost' || status === 'finished' || status === 'cancelled') {
                        return false;
                    }
                    
                    // V√©rifier le statut live s'il existe
                    if (p.liveStatus?.matchStatus?.isFinished) {
                        return false;
                    }
                    
                    return true;
                });
                
                // D√©dupliquer par MATCH (pas seulement par ID)
                // Utiliser fixtureId ou combinaison homeTeam+awayTeam comme cl√© unique
                const matchMap = new Map();
                
                filtered.forEach(pred => {
                    // Cr√©er une cl√© unique pour le match
                    const homeTeam = pred.matchInfo?.homeTeam || pred.meta?.homeTeam || pred.match?.homeTeam || '';
                    const awayTeam = pred.matchInfo?.awayTeam || pred.meta?.awayTeam || pred.match?.awayTeam || '';
                    const fixtureId = pred.matchInfo?.fixtureId || pred.meta?.matchId || pred.opportunityId || '';
                    
                    // Cl√© unique: fixtureId si disponible, sinon homeTeam vs awayTeam
                    const matchKey = fixtureId ? `fixture_${fixtureId}` : `${homeTeam}_vs_${awayTeam}`.toLowerCase();
                    
                    if (!matchMap.has(matchKey)) {
                        matchMap.set(matchKey, pred);
                    } else {
                        const existing = matchMap.get(matchKey);
                        
                        // Garder la pr√©diction la plus avanc√©e:
                        // 1. Celle avec selectedOptions valid√©es (status: 'active')
                        // 2. Celle avec le plus d'options s√©lectionn√©es
                        // 3. Celle avec le statut le plus avanc√©
                        // 4. La plus r√©cente
                        
                        const existingHasOptions = existing.selectedOptions?.length > 0;
                        const newHasOptions = pred.selectedOptions?.length > 0;
                        
                        // Priorit√© 1: Celle avec options valid√©es
                        if (newHasOptions && !existingHasOptions) {
                            matchMap.set(matchKey, pred);
                        }
                        // Priorit√© 2: Si les deux ont des options, garder celle avec plus d'options
                        else if (newHasOptions && existingHasOptions) {
                            if (pred.selectedOptions.length > existing.selectedOptions.length) {
                                matchMap.set(matchKey, pred);
                            }
                        }
                        // Priorit√© 3: Statut 'active' > 'analyzed' > autres
                        else if (!newHasOptions && !existingHasOptions) {
                            const statusPriority = { 'active': 3, 'analyzed': 2, 'analyzing': 1 };
                            const existingPriority = statusPriority[existing.status] || 0;
                            const newPriority = statusPriority[pred.status] || 0;
                            
                            if (newPriority > existingPriority) {
                                matchMap.set(matchKey, pred);
                            }
                            // Priorit√© 4: La plus r√©cente (validatedAt ou analyzedAt)
                            else if (newPriority === existingPriority) {
                                const existingTime = new Date(existing.validatedAt || existing.analyzedAt || existing.createdAt || 0).getTime();
                                const newTime = new Date(pred.validatedAt || pred.analyzedAt || pred.createdAt || 0).getTime();
                                if (newTime > existingTime) {
                                    matchMap.set(matchKey, pred);
                                }
                            }
                        }
                    }
                });
                
                console.log(`üìã Deduplicated: ${filtered.length} ‚Üí ${matchMap.size} predictions`);
                
                return Array.from(matchMap.values());
            })();

            // D√©terminer si un match est commenc√©
            const isMatchStarted = (pred) => {
                // V√©rifier le statut live s'il existe
                if (pred.liveStatus?.matchStatus?.hasStarted) {
                    return true;
                }
                // Sinon v√©rifier la date
                const matchDate = pred.matchInfo?.matchDate || pred.meta?.matchDate || pred.match?.matchDate;
                if (!matchDate) return false;
                
                // G√©rer diff√©rents formats de date (Firestore timestamp, ISO string, etc.)
                let date;
                if (matchDate._seconds) {
                    // Firestore Timestamp
                    date = new Date(matchDate._seconds * 1000);
                } else if (matchDate.seconds) {
                    // Firestore Timestamp (autre format)
                    date = new Date(matchDate.seconds * 1000);
                } else {
                    date = new Date(matchDate);
                }
                
                return date <= new Date();
            };

            // Formater la date du match
            const formatMatchDate = (pred) => {
                const matchDate = pred.matchInfo?.matchDate || pred.meta?.matchDate || pred.match?.matchDate;
                if (!matchDate) return null;
                
                // G√©rer diff√©rents formats de date
                let date;
                if (matchDate._seconds) {
                    date = new Date(matchDate._seconds * 1000);
                } else if (matchDate.seconds) {
                    date = new Date(matchDate.seconds * 1000);
                } else {
                    date = new Date(matchDate);
                }
                
                // V√©rifier si la date est valide
                if (isNaN(date.getTime())) return null;
                
                const now = new Date();
                
                if (date > now) {
                    // Match √† venir
                    const diffMs = date - now;
                    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                    const diffDays = Math.floor(diffHours / 24);
                    
                    if (diffDays > 0) {
                        return `Dans ${diffDays}j`;
                    } else if (diffHours > 0) {
                        return `Dans ${diffHours}h`;
                    } else {
                        const diffMins = Math.floor(diffMs / (1000 * 60));
                        return `Dans ${diffMins}min`;
                    }
                } else {
                    return 'En cours';
                }
            };

            // Formater la date de cr√©ation
            const formatCreatedAt = (createdAt) => {
                if (!createdAt) return null;
                
                let date;
                if (createdAt._seconds) {
                    date = new Date(createdAt._seconds * 1000);
                } else if (createdAt.seconds) {
                    date = new Date(createdAt.seconds * 1000);
                } else {
                    date = new Date(createdAt);
                }
                
                if (isNaN(date.getTime())) return null;
                
                return date.toLocaleDateString('fr-FR', { 
                    day: 'numeric', 
                    month: 'short',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            };

            return (
                <>
                    <Header showBack={false} title="Pronostics en cours" />
                    <main className="main-content">
                        {/* Indicateur de suivi live */}
                        {livePollingActive && (
                            <div className="animate-fade-in" style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px',
                                padding: '8px 12px',
                                marginBottom: '12px',
                                background: 'rgba(34, 197, 94, 0.1)',
                                border: '1px solid rgba(34, 197, 94, 0.3)',
                                borderRadius: '8px'
                            }}>
                                <div style={{
                                    width: '10px',
                                    height: '10px',
                                    borderRadius: '50%',
                                    background: '#22c55e',
                                    animation: 'pulse 1.5s ease-in-out infinite'
                                }}></div>
                                <span style={{ color: '#22c55e', fontSize: '0.85rem', fontWeight: '500' }}>
                                    üì° Suivi live actif - Mise √† jour auto toutes les 60s
                                </span>
                            </div>
                        )}
                        
                        {/* Bouton refresh */}
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
                            <p style={{ color: 'var(--text-muted)', margin: 0 }}>
                                {activePreds.length} pronostic{activePreds.length > 1 ? 's' : ''} actif{activePreds.length > 1 ? 's' : ''}
                            </p>
                            <button 
                                className="btn btn-secondary" 
                                style={{ padding: '6px 12px', fontSize: '0.8rem' }}
                                onClick={handleRefresh}
                            >
                                üîÑ Actualiser
                            </button>
                        </div>

                        {activePreds.length === 0 ? (
                            <div className="empty-state animate-fade-in">
                                <Icons.Target />
                                <p>Aucun pronostic en cours</p>
                                <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem', marginTop: '8px' }}>
                                    Analysez un match pour commencer
                                </p>
                                <button 
                                    className="btn btn-primary" 
                                    style={{ marginTop: '20px' }}
                                    onClick={() => navigate('home')}
                                >
                                    <Icons.Zap />
                                    S√©lectionner un match
                                </button>
                            </div>
                        ) : (
                            <>
                                {activePreds.map((pred, index) => {
                                    const matchInfo = getMatchInfo(pred);
                                    const options = getOptions(pred);
                                    const totalStake = options.reduce((sum, opt) => sum + (opt.stake || 0), 0);
                                    const matchStarted = isMatchStarted(pred);
                                    const matchDateDisplay = formatMatchDate(pred);
                                    const fixtureId = pred.matchInfo?.fixtureId || pred.meta?.matchId || pred.opportunityId;
                                    
                                    // D√©terminer le statut et les couleurs
                                    const getStatusDisplay = () => {
                                        switch(pred.status) {
                                            case 'analyzing':
                                                return { label: 'üîÑ Analyse en cours', bg: 'var(--accent-blue)', color: '#fff' };
                                            case 'analyzed':
                                                return { label: '‚úÖ Analyse termin√©e', bg: 'var(--accent-gold)', color: '#000' };
                                            case 'active':
                                                return { label: 'üü¢ Valid√©', bg: 'var(--accent-green)', color: '#000' };
                                            case 'error':
                                                return { label: '‚ùå Erreur', bg: 'var(--accent-red)', color: '#fff' };
                                            default:
                                                return { label: '‚ö™ En attente', bg: 'rgba(107, 114, 128, 0.3)', color: '#fff' };
                                        }
                                    };
                                    const statusDisplay = getStatusDisplay();
                                    
                                    return (
                                        <div key={pred.id || index} className={`card animate-fade-in delay-${Math.min(index + 1, 5)}`} style={{ marginBottom: '16px' }}>
                                            {/* Header */}
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '12px' }}>
                                                <div>
                                                    <h3 style={{ marginBottom: '4px' }}>{matchInfo.homeTeam} vs {matchInfo.awayTeam}</h3>
                                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>{matchInfo.league}</p>
                                                </div>
                                                <div style={{ textAlign: 'right' }}>
                                                    <span style={{ 
                                                        background: statusDisplay.bg,
                                                        color: statusDisplay.color,
                                                        padding: '4px 12px',
                                                        borderRadius: '20px',
                                                        fontSize: '0.7rem',
                                                        fontWeight: '600',
                                                        whiteSpace: 'nowrap',
                                                        display: 'inline-block'
                                                    }}>
                                                        {statusDisplay.label}
                                                    </span>
                                                    {matchDateDisplay && (
                                                        <p style={{ 
                                                            color: matchStarted ? 'var(--accent-green)' : 'var(--text-muted)', 
                                                            fontSize: '0.7rem', 
                                                            marginTop: '4px' 
                                                        }}>
                                                            {matchStarted ? '‚öΩ En cours' : `‚è∞ ${matchDateDisplay}`}
                                                        </p>
                                                    )}
                                                </div>
                                            </div>

                                            {/* === STATUT: ANALYZING === */}
                                            {pred.status === 'analyzing' && (
                                                <div style={{ marginBottom: '16px' }}>
                                                    <div style={{ 
                                                        padding: '20px', 
                                                        background: 'rgba(59, 130, 246, 0.1)', 
                                                        borderRadius: '12px',
                                                        textAlign: 'center'
                                                    }}>
                                                        <div className="loading-spinner" style={{ margin: '0 auto 12px' }}></div>
                                                        <p style={{ color: 'var(--accent-blue)', fontWeight: '500', margin: 0 }}>
                                                            Analyse IA en cours...
                                                        </p>
                                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem', marginTop: '8px' }}>
                                                            Les r√©sultats seront disponibles sous peu
                                                        </p>
                                                    </div>
                                                </div>
                                            )}

                                            {/* === STATUT: ANALYZED (en attente de validation) === */}
                                            {pred.status === 'analyzed' && (
                                                <div style={{ marginBottom: '16px' }}>
                                                    <div style={{ 
                                                        padding: '16px', 
                                                        background: 'rgba(245, 158, 11, 0.1)', 
                                                        borderRadius: '12px',
                                                        marginBottom: '12px'
                                                    }}>
                                                        <p style={{ color: 'var(--accent-gold)', fontWeight: '500', margin: '0 0 8px' }}>
                                                            üìã Analyse termin√©e - En attente de validation
                                                        </p>
                                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem', margin: 0 }}>
                                                            Consultez les options recommand√©es et validez vos choix
                                                        </p>
                                                    </div>
                                                    
                                                    {/* Aper√ßu des options recommand√©es */}
                                                    {options.length > 0 && (
                                                        <div style={{ marginTop: '12px' }}>
                                                            <p style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginBottom: '8px' }}>
                                                                üìä {options.length} option{options.length > 1 ? 's' : ''} recommand√©e{options.length > 1 ? 's' : ''}
                                                            </p>
                                                            {options.slice(0, 2).map((opt, i) => (
                                                                <div key={i} style={{ 
                                                                    display: 'flex', 
                                                                    justifyContent: 'space-between',
                                                                    padding: '6px 0',
                                                                    opacity: 0.8
                                                                }}>
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.85rem' }}>{opt.option}</span>
                                                                    <span style={{ color: 'var(--accent-gold)', fontSize: '0.85rem' }}>@{opt.odds?.toFixed(2)}</span>
                                                                </div>
                                                            ))}
                                                            {options.length > 2 && (
                                                                <p style={{ color: 'var(--text-muted)', fontSize: '0.75rem' }}>
                                                                    +{options.length - 2} autres...
                                                                </p>
                                                            )}
                                                        </div>
                                                    )}
                                                    
                                                    <button 
                                                        className="btn btn-primary" 
                                                        style={{ width: '100%', marginTop: '12px' }}
                                                        onClick={() => handleViewDetails(pred)}
                                                    >
                                                        <Icons.Eye />
                                                        Voir les r√©sultats et valider
                                                    </button>
                                                </div>
                                            )}

                                            {/* === STATUT: ERROR === */}
                                            {pred.status === 'error' && (
                                                <div style={{ marginBottom: '16px' }}>
                                                    <div style={{ 
                                                        padding: '16px', 
                                                        background: 'rgba(239, 68, 68, 0.1)', 
                                                        borderRadius: '12px',
                                                        textAlign: 'center'
                                                    }}>
                                                        <Icons.AlertCircle style={{ color: 'var(--accent-red)', marginBottom: '8px' }} />
                                                        <p style={{ color: 'var(--accent-red)', fontWeight: '500', margin: '0 0 8px' }}>
                                                            Erreur lors de l'analyse
                                                        </p>
                                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem', margin: 0 }}>
                                                            {pred.error || "Une erreur est survenue"}
                                                        </p>
                                                    </div>
                                                </div>
                                            )}

                                            {/* === STATUT: ACTIVE (valid√© et verrouill√©) === */}
                                            {pred.status === 'active' && (
                                                <>
                                                    {/* Info live si disponible */}
                                                    {pred.liveStatus?.matchStatus && (
                                                        <div style={{ 
                                                            marginBottom: '12px', 
                                                            padding: '8px 12px', 
                                                            background: 'rgba(59, 130, 246, 0.1)', 
                                                            borderRadius: '8px',
                                                            display: 'flex',
                                                            justifyContent: 'space-between',
                                                            alignItems: 'center'
                                                        }}>
                                                            <span style={{ color: 'var(--accent-blue)', fontSize: '0.8rem' }}>üìä Live</span>
                                                            <div style={{ textAlign: 'right' }}>
                                                                <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-gold)' }}>
                                                                    {pred.liveStatus.matchStatus.score?.home ?? 0} - {pred.liveStatus.matchStatus.score?.away ?? 0}
                                                                </span>
                                                                {pred.liveStatus.matchStatus.elapsed && (
                                                                    <span style={{ marginLeft: '8px', color: 'var(--text-muted)', fontSize: '0.8rem' }}>
                                                                        ({pred.liveStatus.matchStatus.elapsed}')
                                                                    </span>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}

                                                    {/* Badge Verrouill√© */}
                                                    <div style={{ 
                                                        display: 'flex', 
                                                        alignItems: 'center', 
                                                        gap: '8px',
                                                        padding: '8px 12px',
                                                        background: 'rgba(16, 185, 129, 0.1)',
                                                        borderRadius: '8px',
                                                        marginBottom: '12px'
                                                    }}>
                                                        <Icons.Lock style={{ color: 'var(--accent-green)', width: '16px', height: '16px' }} />
                                                        <span style={{ color: 'var(--accent-green)', fontSize: '0.8rem', fontWeight: '500' }}>
                                                            Pronostic valid√© et verrouill√©
                                                        </span>
                                                    </div>

                                                    {/* Bookmaker */}
                                                    {pred.selectedBookmaker && (
                                                        <div style={{ 
                                                            marginBottom: '12px', 
                                                            padding: '8px 12px', 
                                                            background: 'rgba(255,255,255,0.03)', 
                                                            borderRadius: '8px',
                                                            display: 'flex',
                                                            justifyContent: 'space-between'
                                                        }}>
                                                            <span style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>Bookmaker</span>
                                                            <span style={{ color: 'var(--accent-blue)', fontSize: '0.85rem', fontWeight: '500' }}>
                                                                {typeof pred.selectedBookmaker === 'object' ? pred.selectedBookmaker.name : pred.selectedBookmaker}
                                                            </span>
                                                        </div>
                                                    )}

                                                    {/* Options valid√©es */}
                                                    {hasValidatedOptions(pred) && (
                                                        <div style={{ marginBottom: '16px' }}>
                                                            <p style={{ color: 'var(--accent-green)', fontSize: '0.75rem', marginBottom: '8px' }}>
                                                                ‚úÖ Options valid√©es
                                                            </p>
                                                            {options.map((opt, i) => (
                                                                <div key={i} style={{ 
                                                                    display: 'flex', 
                                                                    justifyContent: 'space-between',
                                                                    alignItems: 'center',
                                                                    padding: '10px 0',
                                                                    borderBottom: i < options.length - 1 ? '1px solid var(--border-color)' : 'none'
                                                                }}>
                                                                    <div>
                                                                        <span style={{ color: 'var(--text-primary)' }}>{opt.option}</span>
                                                                        <span style={{ 
                                                                            marginLeft: '8px', 
                                                                            color: 'var(--accent-gold)', 
                                                                            fontFamily: 'Space Mono',
                                                                            fontSize: '0.85rem'
                                                                        }}>
                                                                            @{opt.odds?.toFixed(2)}
                                                                        </span>
                                                                    </div>
                                                                    <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-green)' }}>
                                                                        {opt.stake?.toLocaleString()} FCFA
                                                                    </span>
                                                                </div>
                                                            ))}
                                                            
                                                            {/* Total */}
                                                            <div style={{ 
                                                                display: 'flex', 
                                                                justifyContent: 'space-between',
                                                                marginTop: '12px',
                                                                paddingTop: '12px',
                                                                borderTop: '2px solid var(--border-color)'
                                                            }}>
                                                                <span style={{ fontWeight: '600' }}>Total mis√©</span>
                                                                <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-gold)', fontWeight: 'bold' }}>
                                                                    {totalStake.toLocaleString()} FCFA
                                                                </span>
                                                            </div>
                                                        </div>
                                                    )}

                                                    {/* Boutons pour pronostic valid√© */}
                                                    <div style={{ display: 'flex', gap: '8px' }}>
                                                        <button 
                                                            className="btn btn-secondary" 
                                                            style={{ flex: 1 }}
                                                            onClick={() => handleViewDetails(pred)}
                                                        >
                                                            <Icons.Eye />
                                                            D√©tails
                                                        </button>
                                                        
                                                        {/* Afficher "Couverture" si pas encore analys√©, "Sortir position" sinon */}
                                                        {pred.hedgingAnalyzed ? (
                                                            <button 
                                                                className="btn btn-primary"
                                                                style={{ flex: 1, background: 'linear-gradient(135deg, var(--accent-gold) 0%, #f59e0b 100%)' }}
                                                                onClick={() => handleBreakEven(pred)}
                                                                title="Calculer les mises de couverture pour sortir √† z√©ro"
                                                            >
                                                                <Icons.DollarSign />
                                                                Sortir position
                                                            </button>
                                                        ) : (
                                                            <button 
                                                                className={`btn ${matchStarted ? 'btn-primary' : 'btn-secondary'}`}
                                                                style={{ 
                                                                    flex: 1,
                                                                    opacity: matchStarted ? 1 : 0.6,
                                                                    cursor: matchStarted ? 'pointer' : 'not-allowed'
                                                                }}
                                                                onClick={() => handleHedging(pred)}
                                                                disabled={!matchStarted}
                                                                title={matchStarted ? 'Analyser la strat√©gie de couverture' : 'Disponible apr√®s le coup d\'envoi'}
                                                            >
                                                                {matchStarted ? <Icons.Shield /> : <Icons.Lock />}
                                                                {matchStarted ? 'Couverture' : 'En attente'}
                                                            </button>
                                                        )}
                                                    </div>
                                                </>
                                            )}

                                            {/* Timestamp */}
                                            {formatCreatedAt(pred.createdAt) && (
                                                <p style={{ 
                                                    color: 'var(--text-muted)', 
                                                    fontSize: '0.7rem', 
                                                    textAlign: 'right',
                                                    marginTop: '12px'
                                                }}>
                                                    Cr√©√© le {formatCreatedAt(pred.createdAt)}
                                                </p>
                                            )}
                                        </div>
                                    );
                                })}
                            </>
                        )}
                    </main>
                    <BottomNav />
                </>
            );
        };

        const CashoutPage = () => {
            const { navigate, showNotification, currentPrediction, setCurrentPrediction, selectedOptions: globalSelectedOptions, loading, setLoading, API_BASE_URL, user, goBack, getValidToken, apiCallWithAuth, activePredictions, setActivePredictions } = useApp();
            const [cashouts, setCashouts] = useState({});
            const [liveData, setLiveData] = useState({ score: '0 - 0', minute: '0', stats: {} });
            const [matchStatus, setMatchStatus] = useState(null);
            const [canHedge, setCanHedge] = useState(false);
            const [statusMessage, setStatusMessage] = useState('');
            const [checkingStatus, setCheckingStatus] = useState(true);
            const [evaluatedOptions, setEvaluatedOptions] = useState([]);
            const [trackingData, setTrackingData] = useState(null);
            const [autoRefresh, setAutoRefresh] = useState(true);
            const [hedgingStrategy, setHedgingStrategy] = useState(null);
            const [calculatingStrategy, setCalculatingStrategy] = useState(false);
            const [liveOdds, setLiveOdds] = useState({});
            const [breakEvenMode, setBreakEvenMode] = useState(currentPrediction?.breakEvenMode || false);
            const [breakEvenBets, setBreakEvenBets] = useState([]);
            const [breakEvenSummary, setBreakEvenSummary] = useState(null);
            const [loadingBreakEven, setLoadingBreakEven] = useState(false);

            // V√©rifier si une strat√©gie a d√©j√† √©t√© g√©n√©r√©e
            const hasExistingStrategy = currentPrediction?.hedgingStrategy || currentPrediction?.hedgingStrategyGenerated || currentPrediction?.hedgingAnalyzed;

            // ========== FONCTION POUR CALCULER BREAK-EVEN ==========
            const fetchBreakEven = async () => {
                if (!currentPrediction?.id) return;
                
                setLoadingBreakEven(true);
                try {
                    const response = await apiCallWithAuth(
                        `${API_BASE_URL}/hedging/break-even`,
                        {
                            method: 'POST',
                            body: JSON.stringify({ predictionId: currentPrediction.id })
                        }
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        setBreakEvenBets(data.breakEvenBets || []);
                        setBreakEvenSummary(data.summary || null);
                        setLiveOdds(data.liveOdds || {});
                        
                        if (data.matchStatus) {
                            setLiveData({
                                score: `${data.matchStatus.score?.home ?? 0} - ${data.matchStatus.score?.away ?? 0}`,
                                minute: data.matchStatus.elapsed || '0',
                                status: data.matchStatus.status
                            });
                        }
                        
                        showNotification("‚úÖ Calcul break-even termin√©", "success");
                    } else {
                        const error = await response.json();
                        showNotification(error.error || "Erreur lors du calcul", "error");
                    }
                } catch (error) {
                    console.error("Break-even error:", error);
                    showNotification("Erreur lors du calcul du break-even", "error");
                } finally {
                    setLoadingBreakEven(false);
                }
            };

            // Charger automatiquement le break-even si on est en mode break-even
            useEffect(() => {
                if (currentPrediction?.breakEvenMode && !breakEvenBets.length) {
                    setBreakEvenMode(true);
                    fetchBreakEven();
                }
            }, [currentPrediction?.breakEvenMode]);

            // R√©cup√©rer les options valid√©es depuis PLUSIEURS sources possibles
            const getValidatedOptions = () => {
                // 1. selectedOptions (source principale)
                if (currentPrediction?.selectedOptions?.length > 0) {
                    console.log('üìã Cashout: Options from selectedOptions');
                    return currentPrediction.selectedOptions;
                }
                
                // 2. stakes.stakes (options avec mises calcul√©es)
                if (currentPrediction?.stakes?.stakes?.length > 0) {
                    console.log('üìã Cashout: Options from stakes.stakes');
                    return currentPrediction.stakes.stakes.map(s => ({
                        option: s.option,
                        odds: s.odds,
                        stake: s.adjustedStake || s.stake || 0,
                        potentialReturn: s.potentialReturn || Math.round((s.adjustedStake || s.stake || 0) * (s.odds || 1))
                    }));
                }
                
                // 3. oddsAnalysis.recommendedOptions (options recommand√©es par l'IA)
                if (currentPrediction?.oddsAnalysis?.recommendedOptions?.length > 0) {
                    console.log('üìã Cashout: Options from oddsAnalysis.recommendedOptions');
                    const totalBudget = currentPrediction?.userBalance || 10000;
                    const stakePerOption = Math.round(totalBudget * 0.05); // 5% par option
                    return currentPrediction.oddsAnalysis.recommendedOptions.map(opt => ({
                        option: opt.option,
                        odds: opt.odds,
                        stake: stakePerOption,
                        potentialReturn: Math.round(stakePerOption * (opt.odds || 1))
                    }));
                }
                
                console.log('‚ö†Ô∏è Cashout: No options found');
                return [];
            };

            const options = getValidatedOptions();
            const hasValidatedOptions = options.length > 0;

            const fixtureId = currentPrediction?.matchInfo?.fixtureId || currentPrediction?.meta?.matchId || currentPrediction?.opportunityId;
            const predictionId = currentPrediction?.id;

            // ========== CALCUL BREAK-EVEN ==========
            // Formule: Pour sortir √† 0 (break-even), on doit parier sur l'oppos√©
            // Mise de couverture = (Mise initiale √ó Cote initiale) / Cote oppos√©e
            const calculateBreakEven = (liveOddsData) => {
                const bets = [];
                const totalInvested = options.reduce((sum, opt) => sum + (opt.stake || 0), 0);
                
                for (const opt of options) {
                    const stake = opt.stake || 0;
                    const originalOdds = opt.odds || 1.5;
                    const potentialReturn = stake * originalOdds;
                    
                    // Trouver la cote oppos√©e dans les cotes live
                    let oppositeOdds = null;
                    let oppositeBet = null;
                    
                    const optLower = (opt.option || '').toLowerCase();
                    
                    // Logique pour trouver l'oppos√©
                    if (optLower.includes('plus de') || optLower.includes('over')) {
                        // Oppos√© = Moins de (Under)
                        const goals = optLower.match(/(\d+\.?\d*)/);
                        if (goals) {
                            oppositeBet = `Moins de ${goals[1]} buts`;
                            oppositeOdds = liveOddsData?.under?.[goals[1]] || liveOddsData?.goals?.under || 2.0;
                        }
                    } else if (optLower.includes('moins de') || optLower.includes('under')) {
                        // Oppos√© = Plus de (Over)
                        const goals = optLower.match(/(\d+\.?\d*)/);
                        if (goals) {
                            oppositeBet = `Plus de ${goals[1]} buts`;
                            oppositeOdds = liveOddsData?.over?.[goals[1]] || liveOddsData?.goals?.over || 2.0;
                        }
                    } else if (optLower.includes('btts') || optLower.includes('deux √©quipes marquent')) {
                        // Oppos√© = BTTS Non
                        oppositeBet = 'Les deux √©quipes ne marquent pas';
                        oppositeOdds = liveOddsData?.bttsNo || 1.8;
                    } else if (optLower.includes('victoire') && optLower.includes('domicile')) {
                        // Oppos√© = Double chance X2
                        oppositeBet = 'Match nul ou Victoire ext√©rieur (X2)';
                        oppositeOdds = liveOddsData?.doubleChance?.X2 || liveOddsData?.x2 || 1.5;
                    } else if (optLower.includes('victoire') && optLower.includes('ext√©rieur')) {
                        // Oppos√© = Double chance 1X
                        oppositeBet = 'Victoire domicile ou Match nul (1X)';
                        oppositeOdds = liveOddsData?.doubleChance?.['1X'] || liveOddsData?.['1x'] || 1.4;
                    } else if (optLower.includes('nul') || optLower.includes('draw')) {
                        // Oppos√© = 1 ou 2 (pas nul)
                        oppositeBet = 'Pas de match nul (1 ou 2)';
                        oppositeOdds = liveOddsData?.noDrawOdds || 1.3;
                    }
                    
                    if (oppositeOdds && oppositeBet) {
                        // Formule break-even: Mise = (Mise initiale √ó Cote initiale) / Cote oppos√©e
                        const hedgeStake = Math.ceil(potentialReturn / oppositeOdds);
                        const guaranteedReturn = hedgeStake * oppositeOdds;
                        
                        // Calcul du r√©sultat dans chaque sc√©nario
                        const scenarioOriginalWins = potentialReturn - stake - hedgeStake; // Original gagne, hedge perd
                        const scenarioHedgeWins = guaranteedReturn - stake - hedgeStake; // Hedge gagne, original perd
                        
                        bets.push({
                            originalOption: opt.option,
                            originalStake: stake,
                            originalOdds: originalOdds,
                            oppositeBet,
                            oppositeOdds,
                            hedgeStake,
                            guaranteedReturn: Math.round(guaranteedReturn),
                            scenarioOriginalWins: Math.round(scenarioOriginalWins),
                            scenarioHedgeWins: Math.round(scenarioHedgeWins),
                            breakEvenAchieved: Math.abs(scenarioOriginalWins - scenarioHedgeWins) < 100
                        });
                    }
                }
                
                setBreakEvenBets(bets);
                return bets;
            };

            // NE PAS rediriger automatiquement - juste afficher un message si pas d'options
            // L'utilisateur peut retourner manuellement

            // V√©rifier le statut du match et suivre les options
            const checkMatchStatus = async () => {
                // Obtenir un token frais
                const token = await getValidToken();
                if (!token) {
                    console.warn('‚ö†Ô∏è Pas de token disponible');
                    setCheckingStatus(false);
                    setStatusMessage("‚ö†Ô∏è Session expir√©e - Reconnectez-vous");
                    return;
                }
                
                // Si on a un predictionId, utiliser l'endpoint de tracking complet
                if (predictionId && user) {
                    try {
                        const trackResponse = await fetch(`${API_BASE_URL}/predictions/${predictionId}/track`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (trackResponse.ok) {
                            const trackData = await trackResponse.json();
                            setTrackingData(trackData.tracking);
                            
                            if (trackData.tracking?.matchStatus) {
                                const ms = trackData.tracking.matchStatus;
                                setMatchStatus(ms);
                                setCanHedge(ms.canHedge || false);
                                
                                // Message bas√© sur le statut r√©el
                                if (!ms.hasStarted) {
                                    setStatusMessage(`Le match n'a pas encore commenc√©. Coup d'envoi pr√©vu.`);
                                } else if (!ms.canHedge) {
                                    const waitTime = Math.max(0, 40 - (ms.elapsed || 0));
                                    setStatusMessage(`Match en cours (${ms.elapsed}'). Hedging disponible dans ${waitTime} min ou √† la mi-temps.`);
                                } else {
                                    setStatusMessage("‚úÖ Strat√©gie de couverture disponible!");
                                }
                                
                                // Score live
                                if (ms.score) {
                                    setLiveData({
                                        score: `${ms.score.home ?? 0} - ${ms.score.away ?? 0}`,
                                        minute: ms.elapsed || '0',
                                        status: ms.statusLong || ms.status
                                    });
                                }
                            }
                            
                            // Options √©valu√©es
                            if (trackData.tracking?.options) {
                                setEvaluatedOptions(trackData.tracking.options);
                            }
                            
                            setCheckingStatus(false);
                            return;
                        }
                    } catch (error) {
                        console.warn("Tracking error:", error);
                    }
                }

                // Fallback: utiliser l'endpoint de statut simple si on a un fixtureId
                if (fixtureId) {
                    try {
                        const response = await fetch(`${API_BASE_URL}/live/${fixtureId}/status`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            setMatchStatus(data.status);
                            setCanHedge(data.status?.canHedge || false);
                            setStatusMessage(data.status?.message || '');
                            
                            if (data.status?.score) {
                                setLiveData({
                                    score: `${data.status.score.home ?? 0} - ${data.status.score.away ?? 0}`,
                                    minute: data.status.elapsed || '0',
                                    status: data.status.statusLong || data.status.status
                                });
                            }
                            setCheckingStatus(false);
                            return;
                        }
                    } catch (error) {
                        console.warn("Status check error:", error);
                    }
                }

                // Mode d√©mo si pas de donn√©es live disponibles
                setCheckingStatus(false);
                setStatusMessage("‚ö†Ô∏è Donn√©es live non disponibles - Mode d√©mo");
                setCanHedge(true);
            };

            // Effet pour le chargement initial et le rafra√Æchissement automatique
            useEffect(() => {
                checkMatchStatus();
                
                // Rafra√Æchir automatiquement
                let interval;
                if (autoRefresh) {
                    interval = setInterval(() => {
                        checkMatchStatus();
                    }, 30000); // Toutes les 30 secondes
                }

                return () => {
                    if (interval) clearInterval(interval);
                };
            }, [fixtureId, predictionId, autoRefresh]);

            // Initialiser les cashouts √† 0 pour chaque option
            useEffect(() => {
                const initialCashouts = {};
                options.forEach((opt, i) => {
                    initialCashouts[`option_${i}`] = '';
                });
                setCashouts(initialCashouts);
            }, [options.length]);

            const handleSubmit = async (withCashouts = true) => {
                if (!canHedge && matchStatus && !matchStatus.canHedge) {
                    showNotification(statusMessage || "La strat√©gie de couverture n'est pas encore disponible", "error");
                    return;
                }

                if (withCashouts) {
                    const hasAnyCashout = Object.values(cashouts).some(v => v && v !== '');
                    if (!hasAnyCashout) {
                        showNotification("Entrez au moins un cashout ou cliquez sur 'Strat√©gie rapide'", "warning");
                        return;
                    }
                }
                
                setCalculatingStrategy(true);
                setLoading(true);
                showNotification("üß† Calcul de la strat√©gie de couverture...", "info");
                
                try {
                    // Obtenir un token frais
                    const token = await getValidToken();
                    if (!token) {
                        throw new Error("Session expir√©e - Reconnectez-vous");
                    }
                    
                    // Pr√©parer les donn√©es de la requ√™te
                    const requestData = {
                        predictionId: currentPrediction?.id,
                        options: options.map((opt, i) => ({
                            option: opt.option,
                            odds: opt.odds,
                            stake: opt.stake || opt.adjustedStake || 0,
                            cashout: withCashouts && cashouts[`option_${i}`] ? parseFloat(cashouts[`option_${i}`]) : null
                        })),
                        liveScore: {
                            home: matchStatus?.score?.home || 0,
                            away: matchStatus?.score?.away || 0,
                            elapsed: matchStatus?.elapsed || 0
                        },
                        withCashouts
                    };
                    
                    console.log('üì° Hedging request:', requestData);
                    
                    const response = await fetch(`${API_BASE_URL}/hedging/strategy`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(requestData)
                    });

                    const data = await response.json();
                    console.log('üì° Hedging response:', data);

                    if (response.status === 403 && data.error === 'hedging_not_available') {
                        showNotification(data.message, "warning");
                        setCanHedge(false);
                        setStatusMessage(data.message);
                        setMatchStatus(data.matchStatus);
                    } else if (response.ok) {
                        showNotification("‚úÖ Strat√©gie calcul√©e!", "success");
                        setHedgingStrategy(data.strategy);
                        // Stocker la strat√©gie dans currentPrediction pour la page suivante
                        // ET marquer comme hedgingAnalyzed pour verrouiller
                        if (data.strategy) {
                            const updatedPrediction = {
                                ...currentPrediction, 
                                hedgingStrategy: data.strategy, 
                                hedgingStrategyGenerated: true,
                                hedgingAnalyzed: true,  // VERROUILLAGE
                                hedgingLiveData: data.liveData || null
                            };
                            setCurrentPrediction(updatedPrediction);
                            
                            // Mettre √† jour aussi dans activePredictions pour la persistance
                            if (typeof setActivePredictions === 'function' && activePredictions) {
                                const updatedPreds = activePredictions.map(p => 
                                    p.id === currentPrediction.id ? updatedPrediction : p
                                );
                                setActivePredictions(updatedPreds);
                            }
                        }
                        navigate('coverage-strategy');
                    } else if (response.status === 401) {
                        // Token invalide - essayer de rafra√Æchir
                        console.warn("‚ö†Ô∏è Token invalide (401) - Tentative de rafra√Æchissement...");
                        showNotification("Session expir√©e, rafra√Æchissement...", "warning");
                        
                        // Forcer un rafra√Æchissement du token
                        if (firebaseAuth && firebaseAuth.currentUser) {
                            const newToken = await firebaseAuth.currentUser.getIdToken(true);
                            localStorage.setItem('authToken', newToken);
                            showNotification("Token rafra√Æchi ! R√©essayez.", "info");
                        } else {
                            // Mode d√©mo si pas de Firebase
                            throw new Error("Mode d√©mo activ√©");
                        }
                    } else {
                        throw new Error(data.error || "Erreur lors du calcul");
                    }
                } catch (error) {
                    console.warn("Hedging API error:", error);
                    // Mode d√©mo - simuler une strat√©gie intelligente bas√©e sur les donn√©es disponibles
                    console.log("üìä Mode d√©mo - g√©n√©ration d'une strat√©gie simul√©e");
                    
                    const homeScore = matchStatus?.score?.home || 0;
                    const awayScore = matchStatus?.score?.away || 0;
                    const elapsed = matchStatus?.elapsed || 45;
                    
                    // Logique de recommandation bas√©e sur le score
                    let recommendation = "hold";
                    let summary = "Continuez √† suivre le match. Vos paris sont bien positionn√©s.";
                    
                    if (elapsed >= 75) {
                        // Fin de match proche
                        if (homeScore !== awayScore) {
                            recommendation = "secure";
                            summary = `Score ${homeScore}-${awayScore} √† la ${elapsed}'. Pensez √† s√©curiser vos gains si possible.`;
                        }
                    } else if (elapsed >= 60) {
                        recommendation = "monitor";
                        summary = `Match en cours (${elapsed}'). Surveillez l'√©volution du score avant de prendre une d√©cision.`;
                    }
                    
                    const demoStrategy = {
                        recommendation,
                        analysis: `üéØ Analyse √† la ${elapsed}' - Score: ${homeScore} - ${awayScore}

üìä Situation actuelle:
‚Ä¢ ${options.length} option(s) en cours de suivi
‚Ä¢ Temps restant estim√©: ${90 - elapsed} minutes

üí° Recommandation: ${recommendation === 'hold' ? 'MAINTENIR' : recommendation === 'secure' ? 'S√âCURISER' : 'SURVEILLER'}

${summary}`,
                        options: options.map((opt, i) => {
                            const stake = opt.stake || opt.adjustedStake || 1000;
                            const odds = opt.odds || 1.5;
                            const cashoutVal = cashouts[`option_${i}`] ? parseFloat(cashouts[`option_${i}`]) : null;
                            
                            // D√©terminer le statut probable de l'option
                            let currentStatus = "pending";
                            let optRecommendation = "hold";
                            
                            const optLower = (opt.option || '').toLowerCase();
                            if (optLower.includes('plus de 2.5') || optLower.includes('over 2.5')) {
                                if (homeScore + awayScore > 2) currentStatus = "winning";
                                else if (homeScore + awayScore === 2 && elapsed > 60) currentStatus = "pending";
                                else if (elapsed > 70 && homeScore + awayScore < 2) currentStatus = "losing";
                            } else if (optLower.includes('btts') || optLower.includes('deux √©quipes')) {
                                if (homeScore > 0 && awayScore > 0) currentStatus = "won";
                                else if (elapsed > 75 && (homeScore === 0 || awayScore === 0)) currentStatus = "losing";
                            }
                            
                            if (cashoutVal && cashoutVal > stake * 0.9) {
                                optRecommendation = "consider_cashout";
                            }
                            
                            return {
                                option: opt.option,
                                currentStatus,
                                recommendation: optRecommendation,
                                stake,
                                odds,
                                potentialProfit: Math.round(stake * (odds - 1)),
                                cashoutValue: cashoutVal,
                                analysis: cashoutVal 
                                    ? `Cashout propos√©: ${cashoutVal} FCFA (${Math.round(cashoutVal/stake*100)}% de la mise)`
                                    : "Pas de cashout renseign√©"
                            };
                        }),
                        summary,
                        confidence: 0.7,
                        isDemo: true,
                        generatedAt: new Date().toISOString()
                    };
                    
                    setHedgingStrategy(demoStrategy);
                    // Verrouiller la strat√©gie
                    const updatedPrediction = {
                        ...currentPrediction, 
                        hedgingStrategy: demoStrategy, 
                        hedgingStrategyGenerated: true,
                        hedgingAnalyzed: true  // VERROUILLAGE
                    };
                    setCurrentPrediction(updatedPrediction);
                    
                    // Mettre √† jour aussi dans activePredictions pour la persistance
                    if (typeof setActivePredictions === 'function' && activePredictions) {
                        const updatedPreds = activePredictions.map(p => 
                            p.id === currentPrediction.id ? updatedPrediction : p
                        );
                        setActivePredictions(updatedPreds);
                    }
                    showNotification("‚úÖ Strat√©gie g√©n√©r√©e (mode d√©mo)", "success");
                    navigate('coverage-strategy');
                } finally {
                    setCalculatingStrategy(false);
                    setLoading(false);
                }
            };

            const matchInfo = currentPrediction?.match || currentPrediction?.matchInfo || currentPrediction?.meta;

            // Composant de statut
            const StatusBanner = () => {
                if (checkingStatus) {
                    return (
                        <div className="card animate-fade-in" style={{ marginBottom: '16px', textAlign: 'center' }}>
                            <div className="spinner" style={{ margin: '0 auto 8px' }}></div>
                            <p style={{ color: 'var(--text-muted)' }}>V√©rification du statut du match...</p>
                        </div>
                    );
                }

                if (!canHedge && matchStatus && !matchStatus.canHedge) {
                    return (
                        <div className="card animate-fade-in" style={{ 
                            marginBottom: '16px', 
                            background: 'rgba(239, 68, 68, 0.1)',
                            border: '1px solid rgba(239, 68, 68, 0.3)'
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                                <span style={{ fontSize: '1.5rem' }}>‚è≥</span>
                                <h4 style={{ color: 'var(--accent-red)' }}>Strat√©gie de couverture non disponible</h4>
                            </div>
                            <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem', lineHeight: '1.5' }}>
                                {statusMessage}
                            </p>
                            {matchStatus && (
                                <div style={{ 
                                    marginTop: '12px', 
                                    padding: '8px 12px', 
                                    background: 'rgba(0,0,0,0.2)', 
                                    borderRadius: '8px',
                                    fontSize: '0.85rem'
                                }}>
                                    <span style={{ color: 'var(--text-muted)' }}>Statut: </span>
                                    <span style={{ color: 'var(--text-primary)' }}>{matchStatus.statusLong || matchStatus.status}</span>
                                    {matchStatus.elapsed > 0 && (
                                        <span style={{ marginLeft: '8px', color: 'var(--accent-gold)' }}>({matchStatus.elapsed}')</span>
                                    )}
                                </div>
                            )}
                        </div>
                    );
                }

                return (
                    <div className="card animate-fade-in" style={{ 
                        marginBottom: '16px', 
                        background: 'rgba(16, 185, 129, 0.1)',
                        border: '1px solid rgba(16, 185, 129, 0.3)'
                    }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                            <span style={{ fontSize: '1.5rem' }}>‚úÖ</span>
                            <span style={{ color: 'var(--accent-green)' }}>
                                {statusMessage || 'Strat√©gie de couverture disponible'}
                            </span>
                        </div>
                    </div>
                );
            };

            return (
                <>
                    <Header showBack={true} title="Cashouts & Live" />
                    <main className="main-content">
                        {/* Info match */}
                        {matchInfo && (
                            <div className="card animate-fade-in" style={{ marginBottom: '16px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                    <div>
                                        <h3 style={{ fontSize: '1rem' }}>{matchInfo.homeTeam} vs {matchInfo.awayTeam}</h3>
                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>{matchInfo.league}</p>
                                    </div>
                                    <div style={{ textAlign: 'right' }}>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.5rem', color: 'var(--accent-gold)' }}>
                                            {liveData.score}
                                        </div>
                                        <span style={{ 
                                            background: matchStatus?.hasStarted ? 'var(--accent-green)' : 'var(--text-muted)', 
                                            color: '#000', 
                                            padding: '2px 8px', 
                                            borderRadius: '10px',
                                            fontSize: '0.7rem'
                                        }}>
                                            {matchStatus?.hasStarted ? `‚è±Ô∏è ${liveData.minute}'` : '‚è∏Ô∏è Non commenc√©'}
                                        </span>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Banni√®re de statut */}
                        <StatusBanner />

                        {options.length === 0 ? (
                            <div className="empty-state animate-fade-in">
                                <Icons.AlertCircle />
                                <p>Aucune option s√©lectionn√©e</p>
                                <button 
                                    className="btn btn-primary" 
                                    style={{ marginTop: '16px' }}
                                    onClick={() => navigate('pronostics')}
                                >
                                    Retour aux pronostics
                                </button>
                            </div>
                        ) : hasExistingStrategy ? (
                            /* ========== MODE STRAT√âGIE D√âJ√Ä G√âN√âR√âE ========== */
                            <div className="animate-fade-in">
                                {/* Bandeau de verrouillage */}
                                <div style={{
                                    background: 'rgba(139, 92, 246, 0.1)',
                                    border: '1px solid rgba(139, 92, 246, 0.3)',
                                    borderRadius: '12px',
                                    padding: '16px',
                                    marginBottom: '16px'
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '8px' }}>
                                        <span style={{ fontSize: '1.5rem' }}>üîí</span>
                                        <h4 style={{ color: '#a78bfa' }}>Strat√©gie d√©j√† g√©n√©r√©e</h4>
                                    </div>
                                    <p style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', lineHeight: '1.5' }}>
                                        Vous avez d√©j√† g√©n√©r√© une strat√©gie de couverture pour ce match. 
                                        Consultez les r√©sultats ou utilisez le mode "Sortir des options" pour calculer un break-even.
                                    </p>
                                </div>

                                {/* R√©sum√© de la strat√©gie existante */}
                                <div className="card" style={{ marginBottom: '16px' }}>
                                    <h4 style={{ marginBottom: '12px', color: 'var(--accent-gold)' }}>üìã Votre strat√©gie</h4>
                                    <div style={{ 
                                        padding: '12px', 
                                        background: 'rgba(16, 185, 129, 0.1)', 
                                        borderRadius: '8px',
                                        marginBottom: '12px'
                                    }}>
                                        <span style={{ fontWeight: '600', color: 'var(--accent-green)' }}>
                                            Recommandation: {(currentPrediction.hedgingStrategy?.recommendation || 'hold').toUpperCase()}
                                        </span>
                                    </div>
                                    <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', whiteSpace: 'pre-line' }}>
                                        {currentPrediction.hedgingStrategy?.summary || currentPrediction.hedgingStrategy?.analysis?.substring(0, 200) || 'Consultez la page de strat√©gie pour plus de d√©tails.'}
                                    </p>
                                </div>

                                {/* Boutons d'action */}
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                                    <button 
                                        className="btn btn-primary"
                                        style={{ width: '100%' }}
                                        onClick={() => navigate('coverage-strategy')}
                                    >
                                        <Icons.Eye />
                                        Voir la strat√©gie compl√®te
                                    </button>

                                    <button 
                                        className="btn btn-secondary"
                                        style={{ 
                                            width: '100%',
                                            background: breakEvenMode ? 'rgba(239, 68, 68, 0.2)' : 'rgba(245, 158, 11, 0.2)',
                                            border: breakEvenMode ? '1px solid rgba(239, 68, 68, 0.5)' : '1px solid rgba(245, 158, 11, 0.5)'
                                        }}
                                        onClick={() => {
                                            if (!breakEvenMode) {
                                                setBreakEvenMode(true);
                                                // R√©cup√©rer automatiquement les cotes live depuis l'API
                                                fetchBreakEven();
                                            } else {
                                                setBreakEvenMode(false);
                                                setBreakEvenBets([]);
                                            }
                                        }}
                                        disabled={loadingBreakEven}
                                    >
                                        {loadingBreakEven ? (
                                            <>üîÑ Calcul en cours...</>
                                        ) : (
                                            <>
                                                <Icons.Calculator />
                                                {breakEvenMode ? '‚ùå Fermer le mode Break-Even' : 'üéØ Sortir des options (Break-Even)'}
                                            </>
                                        )}
                                    </button>
                                </div>

                                {/* ========== MODE BREAK-EVEN ========== */}
                                {breakEvenMode && (
                                    <div className="card animate-fade-in" style={{ marginTop: '16px' }}>
                                        <h4 style={{ marginBottom: '16px', color: 'var(--accent-gold)' }}>
                                            üéØ Calcul Break-Even (Sortir √† 0)
                                        </h4>
                                        
                                        <div style={{
                                            background: 'rgba(245, 158, 11, 0.1)',
                                            border: '1px solid rgba(245, 158, 11, 0.3)',
                                            borderRadius: '8px',
                                            padding: '12px',
                                            marginBottom: '16px',
                                            fontSize: '0.8rem'
                                        }}>
                                            <p style={{ color: 'var(--accent-gold)', marginBottom: '8px', fontWeight: '600' }}>
                                                üí° Comment √ßa marche ?
                                            </p>
                                            <p style={{ color: 'var(--text-secondary)', lineHeight: '1.5' }}>
                                                Le break-even vous permet de <strong>sortir de vos paris sans perte ni gain</strong>. 
                                                Placez les mises ci-dessous sur les options oppos√©es pour neutraliser vos positions.
                                            </p>
                                        </div>

                                        {/* Bouton pour r√©cup√©rer les cotes live */}
                                        <button
                                            className="btn btn-primary"
                                            style={{ width: '100%', marginBottom: '16px' }}
                                            onClick={fetchBreakEven}
                                            disabled={loadingBreakEven}
                                        >
                                            {loadingBreakEven ? 'üîÑ R√©cup√©ration des cotes live...' : 'üì° R√©cup√©rer les cotes LIVE'}
                                        </button>

                                        {/* R√©sum√© si disponible */}
                                        {breakEvenSummary && (
                                            <div style={{
                                                background: 'rgba(16, 185, 129, 0.1)',
                                                border: '1px solid rgba(16, 185, 129, 0.3)',
                                                borderRadius: '8px',
                                                padding: '12px',
                                                marginBottom: '16px'
                                            }}>
                                                <h5 style={{ marginBottom: '8px', color: 'var(--accent-green)' }}>üìä R√©sum√©</h5>
                                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', fontSize: '0.85rem' }}>
                                                    <div>
                                                        <span style={{ color: 'var(--text-muted)' }}>Total investi:</span>
                                                        <span style={{ marginLeft: '8px', fontWeight: '600', color: 'var(--text-primary)' }}>
                                                            {breakEvenSummary.totalInvested?.toLocaleString()} FCFA
                                                        </span>
                                                    </div>
                                                    <div>
                                                        <span style={{ color: 'var(--text-muted)' }}>Couverture requise:</span>
                                                        <span style={{ marginLeft: '8px', fontWeight: '600', color: 'var(--accent-gold)' }}>
                                                            {breakEvenSummary.totalHedgeRequired?.toLocaleString()} FCFA
                                                        </span>
                                                    </div>
                                                    <div>
                                                        <span style={{ color: 'var(--text-muted)' }}>Pire sc√©nario:</span>
                                                        <span style={{ marginLeft: '8px', fontWeight: '600', color: breakEvenSummary.worstCaseWithHedge >= 0 ? 'var(--accent-green)' : 'var(--accent-red)' }}>
                                                            {breakEvenSummary.worstCaseWithHedge >= 0 ? '+' : ''}{breakEvenSummary.worstCaseWithHedge?.toLocaleString()} FCFA
                                                        </span>
                                                    </div>
                                                    <div>
                                                        <span style={{ color: 'var(--text-muted)' }}>Meilleur sc√©nario:</span>
                                                        <span style={{ marginLeft: '8px', fontWeight: '600', color: 'var(--accent-green)' }}>
                                                            +{breakEvenSummary.bestCaseWithHedge?.toLocaleString()} FCFA
                                                        </span>
                                                    </div>
                                                </div>
                                                {!breakEvenSummary.liveOddsAvailable && (
                                                    <p style={{ color: 'var(--accent-gold)', fontSize: '0.75rem', marginTop: '8px' }}>
                                                        ‚ö†Ô∏è Cotes live non disponibles - Utilisation de cotes estim√©es
                                                    </p>
                                                )}
                                            </div>
                                        )}

                                        {/* R√©sultats du calcul */}
                                        {breakEvenBets.length > 0 && (
                                            <div>
                                                <h5 style={{ marginBottom: '12px', color: 'var(--text-primary)' }}>
                                                    üìã Mises de couverture √† placer:
                                                </h5>
                                                
                                                {breakEvenBets.map((bet, i) => (
                                                    <div key={i} style={{
                                                        background: 'rgba(0,0,0,0.2)',
                                                        borderRadius: '8px',
                                                        padding: '12px',
                                                        marginBottom: '12px',
                                                        border: bet.error ? '1px solid rgba(239, 68, 68, 0.3)' : '1px solid rgba(255,255,255,0.1)'
                                                    }}>
                                                        {/* Option originale */}
                                                        <div style={{ marginBottom: '8px', paddingBottom: '8px', borderBottom: '1px solid var(--border-color)' }}>
                                                            <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem' }}>Votre pari:</span>
                                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                                <span style={{ fontWeight: '500' }}>{bet.originalOption}</span>
                                                                <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-blue)' }}>
                                                                    {bet.originalStake?.toLocaleString()} FCFA @{bet.originalOdds?.toFixed(2)}
                                                                </span>
                                                            </div>
                                                        </div>
                                                        
                                                        {bet.error ? (
                                                            <div style={{ color: 'var(--accent-red)', fontSize: '0.85rem' }}>
                                                                ‚ùå {bet.error}
                                                            </div>
                                                        ) : (
                                                            <>
                                                                {/* Pari de couverture */}
                                                                <div style={{ 
                                                                    background: 'rgba(245, 158, 11, 0.1)',
                                                                    borderRadius: '6px',
                                                                    padding: '10px',
                                                                    marginBottom: '8px'
                                                                }}>
                                                                    <span style={{ color: 'var(--accent-gold)', fontWeight: '600', display: 'block', marginBottom: '4px' }}>
                                                                        ‚û°Ô∏è Parier sur: {bet.oppositeBet}
                                                                    </span>
                                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                                        <span style={{ color: 'var(--text-secondary)' }}>Cote live:</span>
                                                                        <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-gold)' }}>
                                                                            @{bet.oppositeOdds?.toFixed(2)}
                                                                        </span>
                                                                    </div>
                                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '4px' }}>
                                                                        <span style={{ color: 'var(--text-primary)', fontWeight: '600' }}>Mise √† placer:</span>
                                                                        <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-green)', fontWeight: '700', fontSize: '1.1rem' }}>
                                                                            {bet.hedgeStake?.toLocaleString()} FCFA
                                                                        </span>
                                                                    </div>
                                                                </div>
                                                                
                                                                {/* Sc√©narios */}
                                                                <div style={{ fontSize: '0.8rem' }}>
                                                                    <div style={{ display: 'flex', justifyContent: 'space-between', color: 'var(--text-muted)' }}>
                                                                        <span>Si pari initial gagne:</span>
                                                                        <span style={{ color: bet.scenarios?.originalWins >= 0 ? 'var(--accent-green)' : 'var(--accent-red)' }}>
                                                                            {bet.scenarios?.originalWins >= 0 ? '+' : ''}{bet.scenarios?.originalWins?.toLocaleString()} FCFA
                                                                        </span>
                                                                    </div>
                                                                    <div style={{ display: 'flex', justifyContent: 'space-between', color: 'var(--text-muted)' }}>
                                                                        <span>Si couverture gagne:</span>
                                                                        <span style={{ color: bet.scenarios?.hedgeWins >= 0 ? 'var(--accent-green)' : 'var(--accent-red)' }}>
                                                                            {bet.scenarios?.hedgeWins >= 0 ? '+' : ''}{bet.scenarios?.hedgeWins?.toLocaleString()} FCFA
                                                                        </span>
                                                                    </div>
                                                                </div>
                                                            </>
                                                        )}
                                                    </div>
                                                ))}
                                                
                                                {/* Bouton pour actualiser */}
                                                <button
                                                    className="btn btn-secondary"
                                                    style={{ width: '100%', marginTop: '8px' }}
                                                    onClick={fetchBreakEven}
                                                    disabled={loadingBreakEven}
                                                >
                                                    üîÑ Actualiser les cotes
                                                </button>
                                            </div>
                                        )}

                                        {/* Message si pas de r√©sultats */}
                                        {breakEvenBets.length === 0 && !loadingBreakEven && (
                                            <div style={{ textAlign: 'center', padding: '20px', color: 'var(--text-muted)' }}>
                                                <p>Cliquez sur "R√©cup√©rer les cotes LIVE" pour calculer les mises de couverture</p>
                                            </div>
                                        )}
                                    </div>
                                )}

                                <button 
                                    className="btn btn-secondary"
                                    style={{ width: '100%', marginTop: '16px' }}
                                    onClick={() => navigate('pronostics')}
                                >
                                    ‚Üê Retour aux pronostics
                                </button>
                            </div>
                        ) : (
                            <>
                                {/* Section Suivi Live des Options */}
                                {evaluatedOptions.length > 0 && matchStatus?.hasStarted && (
                                    <div className="card animate-fade-in" style={{ 
                                        marginBottom: '16px',
                                        background: 'rgba(59, 130, 246, 0.1)',
                                        border: '1px solid rgba(59, 130, 246, 0.3)'
                                    }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ color: 'var(--accent-blue)' }}>üìä Suivi Live des Paris</h4>
                                            <label style={{ display: 'flex', alignItems: 'center', gap: '8px', fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                                <input 
                                                    type="checkbox" 
                                                    checked={autoRefresh} 
                                                    onChange={(e) => setAutoRefresh(e.target.checked)}
                                                    style={{ accentColor: 'var(--accent-gold)' }}
                                                />
                                                Auto-refresh
                                            </label>
                                        </div>
                                        {evaluatedOptions.map((evalOpt, index) => {
                                            const getStatusStyle = (status) => {
                                                switch(status) {
                                                    case 'won': return { bg: 'rgba(16, 185, 129, 0.2)', color: 'var(--accent-green)', icon: '‚úÖ', text: 'GAGN√â' };
                                                    case 'winning': return { bg: 'rgba(16, 185, 129, 0.15)', color: 'var(--accent-green-light)', icon: 'üìà', text: 'En gain' };
                                                    case 'lost': return { bg: 'rgba(239, 68, 68, 0.2)', color: 'var(--accent-red)', icon: '‚ùå', text: 'PERDU' };
                                                    case 'losing': return { bg: 'rgba(239, 68, 68, 0.15)', color: 'var(--accent-red-light)', icon: 'üìâ', text: 'En perte' };
                                                    default: return { bg: 'rgba(245, 158, 11, 0.15)', color: 'var(--accent-gold)', icon: '‚è≥', text: 'En cours' };
                                                }
                                            };
                                            const style = getStatusStyle(evalOpt.currentStatus);
                                            
                                            return (
                                                <div key={index} style={{
                                                    padding: '10px 12px',
                                                    marginBottom: index < evaluatedOptions.length - 1 ? '8px' : 0,
                                                    background: style.bg,
                                                    borderRadius: '8px',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center'
                                                }}>
                                                    <div>
                                                        <div style={{ fontSize: '0.85rem', marginBottom: '4px' }}>{evalOpt.option}</div>
                                                        <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                                            Mise: {(evalOpt.stake || evalOpt.adjustedStake || 0).toLocaleString()} F @ {evalOpt.odds?.toFixed(2)}
                                                        </div>
                                                    </div>
                                                    <div style={{ textAlign: 'right' }}>
                                                        <div style={{ 
                                                            display: 'flex', 
                                                            alignItems: 'center', 
                                                            gap: '6px',
                                                            color: style.color,
                                                            fontWeight: '600',
                                                            fontSize: '0.9rem'
                                                        }}>
                                                            <span>{style.icon}</span>
                                                            <span>{style.text}</span>
                                                        </div>
                                                        {evalOpt.currentProfit !== undefined && evalOpt.currentProfit !== 0 && (
                                                            <div style={{ 
                                                                fontSize: '0.8rem', 
                                                                fontFamily: 'Space Mono',
                                                                color: evalOpt.currentProfit > 0 ? 'var(--accent-green)' : 'var(--accent-red)'
                                                            }}>
                                                                {evalOpt.currentProfit > 0 ? '+' : ''}{evalOpt.currentProfit.toLocaleString()} F
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                        <div style={{ marginTop: '12px', fontSize: '0.7rem', color: 'var(--text-muted)', textAlign: 'center' }}>
                                            Derni√®re mise √† jour: {trackingData?.evaluatedAt ? new Date(trackingData.evaluatedAt).toLocaleTimeString('fr-FR') : 'N/A'}
                                        </div>
                                    </div>
                                )}

                                {/* Formulaire de Cashout */}
                                <h4 style={{ marginBottom: '8px', marginTop: '16px' }}>üí∞ Entrez vos cashouts</h4>
                                <p style={{ 
                                    fontSize: '0.75rem', 
                                    color: 'var(--text-muted)', 
                                    marginBottom: '12px',
                                    lineHeight: '1.4'
                                }}>
                                    Vous pouvez entrer les valeurs de cashout propos√©es par votre bookmaker √† tout moment. 
                                    La strat√©gie sera calculable √† partir de la 40√®me minute ou √† la mi-temps.
                                </p>
                                {options.map((opt, index) => {
                                    const stake = opt.adjustedStake || opt.stake || 0;
                                    // Trouver l'option √©valu√©e correspondante
                                    const evalOpt = evaluatedOptions.find(e => e.option === opt.option);
                                    const statusBadge = evalOpt?.currentStatus ? (
                                        <span style={{
                                            padding: '2px 6px',
                                            borderRadius: '8px',
                                            fontSize: '0.65rem',
                                            marginLeft: '8px',
                                            background: evalOpt.currentStatus === 'won' || evalOpt.currentStatus === 'winning' ? 'rgba(16, 185, 129, 0.2)' :
                                                       evalOpt.currentStatus === 'lost' || evalOpt.currentStatus === 'losing' ? 'rgba(239, 68, 68, 0.2)' : 'rgba(245, 158, 11, 0.2)',
                                            color: evalOpt.currentStatus === 'won' || evalOpt.currentStatus === 'winning' ? 'var(--accent-green)' :
                                                   evalOpt.currentStatus === 'lost' || evalOpt.currentStatus === 'losing' ? 'var(--accent-red)' : 'var(--accent-gold)'
                                        }}>
                                            {evalOpt.currentStatus === 'won' ? '‚úÖ Gagn√©' : 
                                             evalOpt.currentStatus === 'winning' ? 'üìà En gain' :
                                             evalOpt.currentStatus === 'lost' ? '‚ùå Perdu' :
                                             evalOpt.currentStatus === 'losing' ? 'üìâ En perte' : '‚è≥ En cours'}
                                        </span>
                                    ) : null;
                                    
                                    return (
                                        <div key={index} className={`input-group animate-fade-in delay-${index + 1}`}>
                                            <label className="input-label">
                                                {opt.option}
                                                {statusBadge}
                                                <span style={{ float: 'right', color: 'var(--text-muted)', fontWeight: 'normal' }}>
                                                    Mise: {stake.toLocaleString()} FCFA @ {opt.odds?.toFixed(2)}
                                                </span>
                                            </label>
                                            <input
                                                type="number"
                                                className="input"
                                                placeholder={`Cashout actuel (ex: ${Math.round(stake * 0.9)})`}
                                                value={cashouts[`option_${index}`] || ''}
                                                onChange={(e) => setCashouts({...cashouts, [`option_${index}`]: e.target.value})}
                                            />
                                            <div style={{ 
                                                display: 'flex', 
                                                justifyContent: 'space-between', 
                                                marginTop: '4px',
                                                fontSize: '0.75rem',
                                                color: 'var(--text-muted)'
                                            }}>
                                                <span>Gain potentiel: {Math.round(stake * (opt.odds || 1.5)).toLocaleString()} FCFA</span>
                                                <span>FCFA</span>
                                            </div>
                                        </div>
                                    );
                                })}

                                {/* Donn√©es live */}
                                <div className="card animate-fade-in" style={{ marginTop: '16px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                        <h4 style={{ color: 'var(--accent-blue)' }}>üìä Statut du Match</h4>
                                        <span style={{ 
                                            fontSize: '0.7rem', 
                                            padding: '4px 8px', 
                                            borderRadius: '8px',
                                            background: matchStatus?.hasStarted ? 'rgba(16, 185, 129, 0.2)' : 'rgba(107, 114, 128, 0.2)',
                                            color: matchStatus?.hasStarted ? 'var(--accent-green)' : 'var(--text-muted)'
                                        }}>
                                            {liveData.status || (matchStatus?.hasStarted ? 'En cours' : 'Non commenc√©')}
                                        </span>
                                    </div>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
                                        <div>
                                            <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem' }}>Score</span>
                                            <div style={{ fontFamily: 'Space Mono', fontSize: '1.2rem', color: 'var(--accent-gold)' }}>{liveData.score}</div>
                                        </div>
                                        <div>
                                            <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem' }}>Temps</span>
                                            <div style={{ fontFamily: 'Space Mono', fontSize: '1.2rem' }}>{liveData.minute}'</div>
                                        </div>
                                    </div>
                                    {fixtureId && (
                                        <div style={{ marginTop: '12px', fontSize: '0.7rem', color: 'var(--text-muted)' }}>
                                            Match ID: {fixtureId} ‚Ä¢ Donn√©es via API-Football
                                        </div>
                                    )}
                                </div>

                                {/* Boutons d'action */}
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '12px', marginTop: '20px' }}>
                                    {/* Bouton Strat√©gie rapide (sans cashouts) */}
                                    <button 
                                        className={`btn ${canHedge ? 'btn-primary' : 'btn-secondary'} animate-fade-in`}
                                        style={{ width: '100%', opacity: canHedge ? 1 : 0.5 }}
                                        onClick={() => handleSubmit(false)}
                                        disabled={calculatingStrategy || (!canHedge && matchStatus && !matchStatus.canHedge)}
                                    >
                                        {calculatingStrategy ? 'üß† Calcul en cours...' : (canHedge ? '‚ö° Strat√©gie rapide (IA)' : 'En attente du match...')}
                                        {!calculatingStrategy && <Icons.Zap />}
                                    </button>
                                    
                                    {/* Bouton avec cashouts */}
                                    <button 
                                        className={`btn btn-secondary animate-fade-in`}
                                        style={{ width: '100%', opacity: canHedge ? 1 : 0.5 }}
                                        onClick={() => handleSubmit(true)}
                                        disabled={calculatingStrategy || (!canHedge && matchStatus && !matchStatus.canHedge)}
                                    >
                                        {calculatingStrategy ? 'üß† Calcul...' : 'üí∞ Calculer avec cashouts'}
                                        {!calculatingStrategy && <Icons.Calculator />}
                                    </button>
                                </div>

                                <p style={{ 
                                    fontSize: '0.75rem', 
                                    color: 'var(--text-muted)', 
                                    textAlign: 'center', 
                                    marginTop: '12px' 
                                }}>
                                    üí° "Strat√©gie rapide" analyse vos paris sans cashouts. 
                                    Pour une analyse personnalis√©e, entrez les valeurs de cashout propos√©es par votre bookmaker.
                                </p>
                            </>
                        )}
                    </main>
                    <BottomNav />
                    {(loading || calculatingStrategy) && <LoadingOverlay text="üõ°Ô∏è Analyse de couverture avec Claude..." />}
                </>
            );
        };

        const CoverageStrategyPage = () => {
            const { navigate, currentPrediction, selectedOptions, showNotification } = useApp();
            
            const matchInfo = currentPrediction?.match || currentPrediction?.matchInfo || currentPrediction?.meta;
            
            // R√©cup√©rer la strat√©gie g√©n√©r√©e
            const strategy = currentPrediction?.hedgingStrategy;
            
            // Options depuis la strat√©gie ou fallback
            const strategyOptions = strategy?.options || [];
            const options = strategyOptions.length > 0 
                ? strategyOptions
                : (selectedOptions.length > 0 
                    ? selectedOptions 
                    : currentPrediction?.stakes?.stakes || []);
            
            // Calcul des totaux
            const totalStake = options.reduce((sum, opt) => sum + (opt.stake || opt.adjustedStake || 0), 0);
            const totalPotentialProfit = options.reduce((sum, opt) => sum + (opt.potentialProfit || 0), 0);
            const totalCashout = options.reduce((sum, opt) => sum + (opt.cashoutValue || 0), 0);

            const handleApply = () => {
                showNotification("Strat√©gie not√©e ! Continuez √† suivre le match.", "success");
                navigate('pronostics');
            };

            // Couleur selon la recommandation
            const getRecommendationStyle = (rec) => {
                switch(rec) {
                    case 'secure':
                    case 'cashout':
                        return { bg: 'rgba(239, 68, 68, 0.1)', color: 'var(--accent-red)', icon: 'üîí', text: 'S√âCURISER' };
                    case 'hold':
                        return { bg: 'rgba(16, 185, 129, 0.1)', color: 'var(--accent-green)', icon: '‚úä', text: 'MAINTENIR' };
                    case 'monitor':
                        return { bg: 'rgba(245, 158, 11, 0.1)', color: 'var(--accent-gold)', icon: 'üëÅÔ∏è', text: 'SURVEILLER' };
                    case 'consider_cashout':
                        return { bg: 'rgba(59, 130, 246, 0.1)', color: 'var(--accent-blue)', icon: 'üí≠', text: '√Ä CONSID√âRER' };
                    default:
                        return { bg: 'rgba(107, 114, 128, 0.1)', color: 'var(--text-secondary)', icon: '‚è≥', text: 'EN COURS' };
                }
            };

            return (
                <>
                    <Header showBack={true} title="Strat√©gie de couverture" />
                    <main className="main-content">
                        {/* Match info */}
                        {matchInfo && (
                            <div className="card animate-fade-in" style={{ marginBottom: '16px' }}>
                                <h3>{matchInfo.homeTeam} vs {matchInfo.awayTeam}</h3>
                                <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>{matchInfo.league}</p>
                            </div>
                        )}

                        {/* Badge mode d√©mo si applicable */}
                        {strategy?.isDemo && (
                            <div style={{ 
                                background: 'rgba(245, 158, 11, 0.1)', 
                                border: '1px solid rgba(245, 158, 11, 0.3)',
                                borderRadius: '8px',
                                padding: '8px 12px',
                                marginBottom: '16px',
                                fontSize: '0.8rem',
                                color: 'var(--accent-gold)'
                            }}>
                                ‚ö†Ô∏è Mode d√©monstration - Strat√©gie simul√©e bas√©e sur les donn√©es disponibles
                            </div>
                        )}

                        {/* Recommandation principale */}
                        <div className="recommendation-box animate-fade-in delay-1">
                            <div className="recommendation-title">
                                <Icons.Shield />
                                {strategy?.recommendation ? 
                                    `Recommandation: ${getRecommendationStyle(strategy.recommendation).text}` : 
                                    'Recommandation IA'}
                            </div>
                            <div className="recommendation-text" style={{ whiteSpace: 'pre-line' }}>
                                {strategy?.analysis || 
                                    "Bas√© sur l'analyse et les cotes actuelles, voici notre strat√©gie de couverture optimale."}
                            </div>
                            {strategy?.summary && (
                                <div style={{ 
                                    marginTop: '12px', 
                                    padding: '10px', 
                                    background: 'rgba(16, 185, 129, 0.1)', 
                                    borderRadius: '8px',
                                    fontSize: '0.9rem'
                                }}>
                                    üí° {strategy.summary}
                                </div>
                            )}
                        </div>

                        {/* Actions par option */}
                        <div className="card animate-fade-in delay-2">
                            <h4 style={{ marginBottom: '16px', color: 'var(--accent-gold)' }}>üìã D√©tail par option</h4>
                            
                            {options.map((opt, index) => {
                                const recStyle = getRecommendationStyle(opt.recommendation);
                                const statusStyle = getRecommendationStyle(opt.currentStatus);
                                const stake = opt.stake || opt.adjustedStake || 0;
                                const profit = opt.potentialProfit || Math.round(stake * ((opt.odds || 1.5) - 1));
                                
                                return (
                                    <div key={index} style={{ 
                                        marginBottom: '16px',
                                        paddingBottom: index < options.length - 1 ? '16px' : '0',
                                        borderBottom: index < options.length - 1 ? '1px solid var(--border-color)' : 'none'
                                    }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                                            <span style={{ fontWeight: '500' }}>{opt.option}</span>
                                            <span style={{ 
                                                padding: '4px 10px', 
                                                borderRadius: '12px', 
                                                background: recStyle.bg,
                                                color: recStyle.color, 
                                                fontWeight: '600', 
                                                fontSize: '0.75rem' 
                                            }}>
                                                {recStyle.icon} {recStyle.text}
                                            </span>
                                        </div>
                                        
                                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', marginBottom: '8px' }}>
                                            <div style={{ fontSize: '0.8rem' }}>
                                                <span style={{ color: 'var(--text-muted)' }}>Mise: </span>
                                                <span style={{ fontFamily: 'Space Mono' }}>{stake.toLocaleString()} F</span>
                                            </div>
                                            <div style={{ fontSize: '0.8rem' }}>
                                                <span style={{ color: 'var(--text-muted)' }}>Cote: </span>
                                                <span style={{ fontFamily: 'Space Mono' }}>{(opt.odds || 1.5).toFixed(2)}</span>
                                            </div>
                                            <div style={{ fontSize: '0.8rem' }}>
                                                <span style={{ color: 'var(--text-muted)' }}>Gain potentiel: </span>
                                                <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-green)' }}>+{profit.toLocaleString()} F</span>
                                            </div>
                                            {opt.cashoutValue && (
                                                <div style={{ fontSize: '0.8rem' }}>
                                                    <span style={{ color: 'var(--text-muted)' }}>Cashout: </span>
                                                    <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-gold)' }}>{opt.cashoutValue.toLocaleString()} F</span>
                                                </div>
                                            )}
                                        </div>
                                        
                                        {/* Statut actuel */}
                                        {opt.currentStatus && opt.currentStatus !== 'pending' && (
                                            <div style={{ 
                                                padding: '6px 10px', 
                                                borderRadius: '6px', 
                                                background: statusStyle.bg,
                                                fontSize: '0.8rem',
                                                marginBottom: '8px'
                                            }}>
                                                <span style={{ color: statusStyle.color }}>{statusStyle.icon} Statut: {statusStyle.text}</span>
                                            </div>
                                        )}
                                        
                                        {opt.analysis && (
                                            <p style={{ fontSize: '0.8rem', color: 'var(--text-muted)', fontStyle: 'italic' }}>
                                                {opt.analysis}
                                            </p>
                                        )}
                                    </div>
                                );
                            })}
                        </div>

                        {/* R√©sum√© des totaux */}
                        <div className="card animate-fade-in delay-3">
                            <h4 style={{ marginBottom: '16px' }}>üìä R√©sum√©</h4>
                            
                            <div style={{ 
                                display: 'flex', 
                                justifyContent: 'space-between', 
                                padding: '12px 0',
                                borderBottom: '1px solid var(--border-color)'
                            }}>
                                <span style={{ color: 'var(--text-secondary)' }}>üí∞ Total mis√©</span>
                                <span style={{ fontFamily: 'Space Mono', fontWeight: 'bold' }}>
                                    {totalStake.toLocaleString()} FCFA
                                </span>
                            </div>
                            
                            <div style={{ 
                                display: 'flex', 
                                justifyContent: 'space-between', 
                                padding: '12px 0',
                                borderBottom: '1px solid var(--border-color)'
                            }}>
                                <span style={{ color: 'var(--text-secondary)' }}>üéØ Gain potentiel max</span>
                                <span style={{ color: 'var(--accent-green)', fontFamily: 'Space Mono', fontWeight: 'bold' }}>
                                    +{totalPotentialProfit.toLocaleString()} FCFA
                                </span>
                            </div>
                            
                            {totalCashout > 0 && (
                                <div style={{ 
                                    display: 'flex', 
                                    justifyContent: 'space-between', 
                                    padding: '12px 0',
                                    borderBottom: '1px solid var(--border-color)'
                                }}>
                                    <span style={{ color: 'var(--text-secondary)' }}>üíµ Total cashouts dispo</span>
                                    <span style={{ color: 'var(--accent-gold)', fontFamily: 'Space Mono', fontWeight: 'bold' }}>
                                        {totalCashout.toLocaleString()} FCFA
                                    </span>
                                </div>
                            )}
                            
                            <div style={{ 
                                display: 'flex', 
                                justifyContent: 'space-between', 
                                padding: '12px 0'
                            }}>
                                <span style={{ color: 'var(--text-secondary)' }}>üíÄ Perte max (sans hedge)</span>
                                <span style={{ color: 'var(--accent-red)', fontFamily: 'Space Mono', fontWeight: 'bold' }}>
                                    -{totalStake.toLocaleString()} FCFA
                                </span>
                            </div>
                            
                            {/* Confiance de la strat√©gie */}
                            {strategy?.confidence && (
                                <div style={{ 
                                    display: 'flex', 
                                    justifyContent: 'space-between', 
                                    alignItems: 'center',
                                    padding: '12px',
                                    background: 'rgba(16, 185, 129, 0.1)',
                                    borderRadius: '8px',
                                    marginTop: '12px'
                                }}>
                                    <span style={{ color: 'var(--accent-green)', fontWeight: '600' }}>üìä Confiance analyse</span>
                                    <span style={{ fontFamily: 'Space Mono', fontWeight: 'bold' }}>
                                        {Math.round(strategy.confidence * 100)}%
                                    </span>
                                </div>
                            )}
                        </div>

                        {/* Note IA */}
                        <div className="animate-fade-in delay-4" style={{
                            background: 'rgba(139, 92, 246, 0.1)',
                            border: '1px solid rgba(139, 92, 246, 0.3)',
                            borderRadius: '12px',
                            padding: '16px',
                            marginTop: '16px'
                        }}>
                            <p style={{ color: '#a78bfa', fontSize: '0.85rem', marginBottom: '8px', fontWeight: '600' }}>
                                üß† {strategy?.isDemo ? 'Analyse Simul√©e' : 'Analyse Claude AI'}
                            </p>
                            <p style={{ color: 'var(--text-secondary)', fontSize: '0.8rem', lineHeight: '1.5' }}>
                                {strategy?.isDemo 
                                    ? "Cette recommandation est g√©n√©r√©e en mode d√©monstration. Pour une analyse compl√®te avec l'IA Claude, assurez-vous que le serveur est connect√©."
                                    : "Cette recommandation est bas√©e sur l'√©volution du match, les cotes live et votre profil de risque. La strat√©gie vise √† optimiser vos gains tout en minimisant les risques."
                                }
                            </p>
                            {strategy?.generatedAt && (
                                <p style={{ color: 'var(--text-muted)', fontSize: '0.7rem', marginTop: '8px' }}>
                                    G√©n√©r√©e le {new Date(strategy.generatedAt).toLocaleString('fr-FR')}
                                </p>
                            )}
                        </div>

                        <button 
                            className="btn btn-success animate-fade-in delay-5" 
                            style={{ width: '100%', marginTop: '20px', marginBottom: '20px' }}
                            onClick={handleApply}
                        >
                            <Icons.Check />
                            Compris, retour aux pronostics
                        </button>
                    </main>
                    <BottomNav />
                </>
            );
        };

        const CapitalPage = () => {
            const { user, requireAuth, navigate, API_BASE_URL, showNotification } = useApp();
            const [stats, setStats] = useState(null);
            const [history, setHistory] = useState([]);
            const [loading, setLoading] = useState(true);
            const [adjustmentModal, setAdjustmentModal] = useState(false);
            const [adjustmentData, setAdjustmentData] = useState({ amount: '', reason: '', type: 'deposit' });
            const [recalculating, setRecalculating] = useState(false);

            // Fonction pour recalculer toutes les pr√©dictions
            const handleRecalculateAll = async () => {
                if (!user) {
                    showNotification("Connectez-vous pour recalculer", "error");
                    return;
                }

                setRecalculating(true);
                try {
                    const token = localStorage.getItem('authToken');
                    const response = await fetch(`${API_BASE_URL}/user/capital/recalculate-all`, {
                        method: 'POST',
                        headers: { 
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        showNotification(data.message || "Recalcul termin√©!", "success");
                        
                        // Mettre √† jour les stats localement
                        if (data.stats) {
                            setStats(prev => ({
                                ...prev,
                                currentBalance: data.stats.newBalance,
                                totalGains: data.stats.totalGains,
                                totalLosses: data.stats.totalLosses,
                                netProfit: data.stats.netProfit,
                                wonBets: data.stats.wonBets,
                                lostBets: data.stats.lostBets,
                                winRate: data.stats.winRate,
                                totalBets: data.stats.wonBets + data.stats.lostBets
                            }));
                        }

                        // Recharger les stats compl√®tes
                        setTimeout(() => {
                            window.location.reload();
                        }, 1500);
                    } else {
                        showNotification(data.error || "Erreur lors du recalcul", "error");
                    }
                } catch (error) {
                    console.error("Recalculate error:", error);
                    showNotification("Erreur de connexion", "error");
                } finally {
                    setRecalculating(false);
                }
            };

            // Charger les statistiques
            useEffect(() => {
                const fetchStats = async () => {
                    if (!user) {
                        // Mode d√©mo
                        setStats({
                            currentBalance: 50000,
                            totalGains: 15000,
                            totalLosses: 8000,
                            netProfit: 7000,
                            winRate: 62.5,
                            totalBets: 24,
                            roi: 14,
                            averageBet: 2000
                        });
                        setLoading(false);
                        return;
                    }

                    try {
                        const token = localStorage.getItem('authToken');
                        const response = await fetch(`${API_BASE_URL}/user/capital/stats`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            setStats(data.stats);
                            setHistory(data.history || []);
                        }
                    } catch (error) {
                        console.warn("Could not fetch capital stats:", error);
                        // Mode d√©mo fallback
                        setStats({
                            currentBalance: 50000,
                            totalGains: 15000,
                            totalLosses: 8000,
                            netProfit: 7000,
                            winRate: 62.5,
                            totalBets: 24,
                            roi: 14,
                            averageBet: 2000
                        });
                    } finally {
                        setLoading(false);
                    }
                };

                fetchStats();
            }, [user]);

            const handleAdjustment = async () => {
                if (!adjustmentData.amount || !adjustmentData.reason) {
                    showNotification("Veuillez remplir tous les champs", "error");
                    return;
                }

                try {
                    const token = localStorage.getItem('authToken');
                    const amount = adjustmentData.type === 'withdrawal' 
                        ? -Math.abs(parseFloat(adjustmentData.amount))
                        : Math.abs(parseFloat(adjustmentData.amount));

                    const response = await fetch(`${API_BASE_URL}/user/capital/adjust`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({
                            amount,
                            reason: adjustmentData.reason,
                            type: adjustmentData.type
                        })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        showNotification(`Solde mis √† jour: ${data.newBalance.toLocaleString()} FCFA`, "success");
                        setStats(prev => ({ ...prev, currentBalance: data.newBalance }));
                        setAdjustmentModal(false);
                        setAdjustmentData({ amount: '', reason: '', type: 'deposit' });
                    } else {
                        throw new Error(data.error);
                    }
                } catch (error) {
                    showNotification(`Erreur: ${error.message}`, "error");
                }
            };

            // Modal d'ajustement
            const AdjustmentModal = () => {
                if (!adjustmentModal) return null;

                return (
                    <div style={{
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                        background: 'rgba(0,0,0,0.8)',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        zIndex: 2000,
                        padding: '20px'
                    }} onClick={(e) => e.target === e.currentTarget && setAdjustmentModal(false)}>
                        <div className="card" style={{ width: '100%', maxWidth: '400px' }}>
                            <h3 style={{ marginBottom: '16px', color: 'var(--accent-gold)' }}>üí∞ Ajuster le capital</h3>
                            
                            <div style={{ marginBottom: '16px' }}>
                                <label style={{ display: 'block', marginBottom: '8px', color: 'var(--text-secondary)' }}>Type</label>
                                <div style={{ display: 'flex', gap: '8px' }}>
                                    <button
                                        className={`btn ${adjustmentData.type === 'deposit' ? 'btn-success' : 'btn-secondary'}`}
                                        style={{ flex: 1 }}
                                        onClick={() => setAdjustmentData(prev => ({ ...prev, type: 'deposit' }))}
                                    >üì• D√©p√¥t</button>
                                    <button
                                        className={`btn ${adjustmentData.type === 'withdrawal' ? 'btn-danger' : 'btn-secondary'}`}
                                        style={{ flex: 1 }}
                                        onClick={() => setAdjustmentData(prev => ({ ...prev, type: 'withdrawal' }))}
                                    >üì§ Retrait</button>
                                </div>
                            </div>

                            <div style={{ marginBottom: '16px' }}>
                                <label style={{ display: 'block', marginBottom: '8px', color: 'var(--text-secondary)' }}>Montant (FCFA)</label>
                                <input
                                    type="number"
                                    className="input"
                                    placeholder="Ex: 10000"
                                    value={adjustmentData.amount}
                                    onChange={(e) => setAdjustmentData(prev => ({ ...prev, amount: e.target.value }))}
                                    style={{ width: '100%' }}
                                />
                            </div>

                            <div style={{ marginBottom: '20px' }}>
                                <label style={{ display: 'block', marginBottom: '8px', color: 'var(--text-secondary)' }}>Raison</label>
                                <input
                                    type="text"
                                    className="input"
                                    placeholder="Ex: Recharge via MoMo"
                                    value={adjustmentData.reason}
                                    onChange={(e) => setAdjustmentData(prev => ({ ...prev, reason: e.target.value }))}
                                    style={{ width: '100%' }}
                                />
                            </div>

                            <div style={{ display: 'flex', gap: '12px' }}>
                                <button className="btn btn-secondary" style={{ flex: 1 }} onClick={() => setAdjustmentModal(false)}>Annuler</button>
                                <button className="btn btn-primary" style={{ flex: 1 }} onClick={handleAdjustment}>Confirmer</button>
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <>
                    <Header showBack={false} title="Suivi Capital" />
                    <main className="main-content">
                        {loading ? (
                            <div style={{ 
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center',
                                justifyContent: 'center',
                                padding: '60px 20px',
                                minHeight: '60vh'
                            }}>
                                {/* Logo anim√© */}
                                <div style={{
                                    fontSize: '2rem',
                                    fontWeight: 'bold',
                                    marginBottom: '24px',
                                    animation: 'pulse 1.5s ease-in-out infinite'
                                }}>
                                    <span style={{ color: 'var(--accent-gold)' }}>E</span>
                                    <span style={{ color: 'white' }}>-Cauri</span>
                                </div>
                                
                                {/* Spinner personnalis√© */}
                                <div style={{
                                    width: '50px',
                                    height: '50px',
                                    border: '3px solid rgba(212, 175, 55, 0.2)',
                                    borderTopColor: 'var(--accent-gold)',
                                    borderRadius: '50%',
                                    animation: 'spin 1s linear infinite',
                                    marginBottom: '16px'
                                }}></div>
                                
                                {/* Message */}
                                <div style={{
                                    color: 'var(--text-secondary)',
                                    fontSize: '0.9rem',
                                    textAlign: 'center'
                                }}>
                                    üìä Chargement des statistiques...
                                </div>
                                
                                {/* Barre de progression */}
                                <div style={{
                                    width: '180px',
                                    height: '3px',
                                    background: 'rgba(255,255,255,0.1)',
                                    borderRadius: '2px',
                                    marginTop: '16px',
                                    overflow: 'hidden'
                                }}>
                                    <div style={{
                                        width: '40%',
                                        height: '100%',
                                        background: 'var(--accent-gold)',
                                        borderRadius: '2px',
                                        animation: 'loading-bar 1.5s ease-in-out infinite'
                                    }}></div>
                                </div>
                            </div>
                        ) : (
                            <>
                                <div className="stats-grid animate-fade-in">
                                    <div className="stat-card green">
                                        <div className="stat-label">Gains</div>
                                        <div className="stat-value green">+{(stats?.totalGains || 0).toLocaleString()} F</div>
                                    </div>
                                    <div className="stat-card red">
                                        <div className="stat-label">Pertes</div>
                                        <div className="stat-value red">-{(stats?.totalLosses || 0).toLocaleString()} F</div>
                                    </div>
                                </div>

                                <div className="balance-display animate-fade-in delay-1">
                                    <div className="balance-label">Solde actuel</div>
                                    <div className="balance-value">{(stats?.currentBalance || 0).toLocaleString()} FCFA</div>
                                </div>

                                {/* Stats suppl√©mentaires */}
                                <div className="card animate-fade-in delay-2" style={{ marginTop: '16px' }}>
                                    <h4 style={{ marginBottom: '16px', color: 'var(--accent-gold)' }}>üìä Statistiques</h4>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
                                        <div>
                                            <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>Taux de r√©ussite</div>
                                            <div style={{ 
                                                fontFamily: 'Space Mono', 
                                                fontSize: '1.2rem',
                                                color: (stats?.winRate || 0) >= 50 ? 'var(--accent-green)' : 'var(--accent-red)'
                                            }}>{(stats?.winRate || 0).toFixed(1)}%</div>
                                        </div>
                                        <div>
                                            <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>ROI</div>
                                            <div style={{ 
                                                fontFamily: 'Space Mono', 
                                                fontSize: '1.2rem',
                                                color: (stats?.roi || 0) >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'
                                            }}>{(stats?.roi || 0).toFixed(1)}%</div>
                                        </div>
                                        <div>
                                            <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>Paris total</div>
                                            <div style={{ fontFamily: 'Space Mono', fontSize: '1.2rem' }}>{stats?.totalBets || 0}</div>
                                        </div>
                                        <div>
                                            <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>Mise moyenne</div>
                                            <div style={{ fontFamily: 'Space Mono', fontSize: '1.2rem' }}>{(stats?.averageBet || 0).toLocaleString()} F</div>
                                        </div>
                                    </div>
                                </div>

                                {/* Bouton de recalcul */}
                                {user && (stats?.totalBets === 0 || stats?.totalGains === 0) && history.length > 0 && (
                                    <div className="card animate-fade-in delay-2" style={{ 
                                        marginTop: '16px', 
                                        background: 'rgba(245, 158, 11, 0.1)',
                                        border: '1px solid rgba(245, 158, 11, 0.3)'
                                    }}>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '12px' }}>
                                            <span style={{ fontSize: '1.2rem' }}>‚ö†Ô∏è</span>
                                            <span style={{ color: 'var(--accent-gold)', fontWeight: '600' }}>Statistiques incompl√®tes</span>
                                        </div>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '12px' }}>
                                            Vos gains et pertes n'ont pas √©t√© correctement calcul√©s. 
                                            Cliquez sur le bouton ci-dessous pour recalculer toutes vos pr√©dictions.
                                        </p>
                                        <button 
                                            className="btn btn-primary"
                                            style={{ width: '100%' }}
                                            onClick={handleRecalculateAll}
                                            disabled={recalculating}
                                        >
                                            {recalculating ? (
                                                <>
                                                    <span className="spinner"></span>
                                                    Recalcul en cours...
                                                </>
                                            ) : (
                                                <>
                                                    <Icons.Calculator />
                                                    üîÑ Recalculer mes gains/pertes
                                                </>
                                            )}
                                        </button>
                                    </div>
                                )}

                                {/* Historique */}
                                {history.length > 0 && (
                                    <div className="card animate-fade-in delay-3" style={{ marginTop: '16px' }}>
                                        <h4 style={{ marginBottom: '16px' }}>üìú Historique r√©cent</h4>
                                        {history.slice(0, 10).map((item, index) => (
                                            <div key={index} style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                padding: '8px 0',
                                                borderBottom: index < Math.min(history.length, 10) - 1 ? '1px solid var(--border-color)' : 'none'
                                            }}>
                                                <div>
                                                    <div style={{ fontSize: '0.85rem' }}>{item.reason || 'Transaction'}</div>
                                                    <div style={{ color: 'var(--text-muted)', fontSize: '0.7rem' }}>
                                                        {item.timestamp ? new Date(item.timestamp).toLocaleDateString('fr-FR') : ''}
                                                    </div>
                                                </div>
                                                <div style={{ 
                                                    fontFamily: 'Space Mono',
                                                    color: item.change >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'
                                                }}>
                                                    {item.change >= 0 ? '+' : ''}{item.change?.toLocaleString()} F
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}

                                {/* Boutons d'action */}
                                <div style={{ display: 'flex', gap: '12px', marginTop: '20px' }}>
                                    <button 
                                        className="btn btn-secondary animate-fade-in delay-3" 
                                        style={{ flex: 1 }}
                                        onClick={() => user ? setAdjustmentModal(true) : requireAuth('capital')}
                                    >
                                        <Icons.Trending />
                                        Ajuster
                                    </button>
                                    <button 
                                        className="btn btn-primary animate-fade-in delay-4" 
                                        style={{ flex: 1 }}
                                        onClick={() => user ? navigate('recommendations') : requireAuth('recommendations')}
                                    >
                                        <Icons.Brain />
                                        Recommandations
                                    </button>
                                </div>

                                {!user && (
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem', textAlign: 'center', marginTop: '12px' }} className="animate-fade-in delay-5">
                                        Connexion requise pour acc√©der √† toutes les fonctionnalit√©s
                                    </p>
                                )}
                            </>
                        )}
                    </main>
                    <AdjustmentModal />
                    <BottomNav />
                </>
            );
        };

        const RecommendationsPage = () => {
            const { user, navigate, API_BASE_URL, showNotification } = useApp();
            const [recommendations, setRecommendations] = useState(null);
            const [userStats, setUserStats] = useState(null);
            const [loading, setLoading] = useState(false);
            const [generating, setGenerating] = useState(false);

            // Charger les recommandations existantes
            useEffect(() => {
                const fetchRecommendations = async () => {
                    if (!user) return;
                    
                    setLoading(true);
                    try {
                        const token = localStorage.getItem('authToken');
                        const response = await fetch(`${API_BASE_URL}/user/recommendations`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            if (data.recommendations?.length > 0) {
                                setRecommendations(data.recommendations[0]);
                            }
                        }
                    } catch (error) {
                        console.warn("Could not fetch recommendations:", error);
                    } finally {
                        setLoading(false);
                    }
                };

                fetchRecommendations();
            }, [user]);

            const generateRecommendations = async () => {
                setGenerating(true);
                showNotification("G√©n√©ration des recommandations en cours...", "info");

                try {
                    const token = localStorage.getItem('authToken');
                    const response = await fetch(`${API_BASE_URL}/user/recommendations/generate`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    const data = await response.json();

                    if (response.ok) {
                        setRecommendations(data.recommendations);
                        setUserStats(data.userStats);
                        showNotification("Recommandations g√©n√©r√©es avec succ√®s!", "success");
                    } else {
                        throw new Error(data.error || "Erreur lors de la g√©n√©ration");
                    }
                } catch (error) {
                    showNotification(`Erreur: ${error.message}`, "error");
                    // Fallback avec des recommandations de d√©mo
                    setRecommendations({
                        analysis: {
                            strengths: ["Utilisation de l'IA pour les analyses", "Bonne discipline de mise"],
                            weaknesses: ["Taux de r√©ussite √† am√©liorer sur les matchs nuls"],
                            riskProfile: "moderate",
                            trend: "stable"
                        },
                        recommendations: [
                            {
                                category: "strategy",
                                priority: "high",
                                title: "Diversifiez vos paris",
                                description: "Vos performances sur les BTTS sont excellentes mais vous n√©gligez les Double Chance.",
                                actionable: "Int√©grez 2-3 paris Double Chance par semaine"
                            },
                            {
                                category: "bankroll",
                                priority: "medium",
                                title: "Ajustez vos mises",
                                description: "Vos mises sont parfois trop √©lev√©es par rapport √† votre capital.",
                                actionable: "Ne d√©passez pas 5% de votre capital par pari"
                            }
                        ],
                        optimalSettings: {
                            suggestedMaxBetPercentage: 5,
                            suggestedMinBet: 100,
                            preferredOptionTypes: ["BTTS", "DOUBLE_CHANCE", "TOTALS"]
                        },
                        motivationalMessage: "Continuez sur cette lanc√©e, vous progressez bien !"
                    });
                } finally {
                    setGenerating(false);
                }
            };

            if (!user) {
                navigate('login');
                return null;
            }

            const getPriorityColor = (priority) => {
                switch (priority) {
                    case 'high': return 'var(--accent-red)';
                    case 'medium': return 'var(--accent-gold)';
                    case 'low': return 'var(--accent-green)';
                    default: return 'var(--text-muted)';
                }
            };

            const getCategoryIcon = (category) => {
                switch (category) {
                    case 'bankroll': return 'üí∞';
                    case 'strategy': return 'üìä';
                    case 'option_types': return 'üéØ';
                    case 'timing': return '‚è±Ô∏è';
                    case 'psychology': return 'üß†';
                    default: return 'üìã';
                }
            };

            return (
                <>
                    <Header showBack={true} title="Recommandations IA" />
                    <main className="main-content">
                        {/* Stats utilisateur */}
                        {userStats && (
                            <div className="card animate-fade-in" style={{ marginBottom: '16px' }}>
                                <h4 style={{ marginBottom: '12px', color: 'var(--accent-gold)' }}>üìä Vos statistiques</h4>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '12px', textAlign: 'center' }}>
                                    <div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.2rem', color: 'var(--accent-gold)' }}>
                                            {(userStats.winRate || 0).toFixed(1)}%
                                        </div>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.7rem' }}>Taux r√©ussite</div>
                                    </div>
                                    <div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.2rem' }}>
                                            {userStats.totalPredictions || 0}
                                        </div>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.7rem' }}>Pr√©dictions</div>
                                    </div>
                                    <div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1rem', color: 'var(--accent-green)' }}>
                                            {(userStats.currentBalance || 0).toLocaleString()} F
                                        </div>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.7rem' }}>Capital</div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Bouton g√©n√©rer */}
                        <button 
                            className="btn btn-primary animate-fade-in" 
                            style={{ width: '100%', marginBottom: '20px' }}
                            onClick={generateRecommendations}
                            disabled={generating}
                        >
                            {generating ? (
                                <>
                                    <span className="spinner" style={{ width: '20px', height: '20px' }}></span>
                                    Analyse en cours...
                                </>
                            ) : (
                                <>
                                    <Icons.Brain />
                                    G√©n√©rer mes recommandations
                                </>
                            )}
                        </button>

                        {loading && (
                            <div style={{ textAlign: 'center', padding: '40px' }}>
                                <div className="spinner"></div>
                            </div>
                        )}

                        {/* Analyse */}
                        {recommendations?.analysis && (
                            <div className="card animate-fade-in delay-1" style={{ marginBottom: '16px' }}>
                                <h4 style={{ marginBottom: '12px' }}>üîç Analyse de votre profil</h4>

                                {/* Profil de risque et tendance */}
                                <div style={{ display: 'flex', gap: '12px', marginBottom: '16px', flexWrap: 'wrap' }}>
                                    <span style={{
                                        padding: '4px 12px',
                                        borderRadius: '20px',
                                        fontSize: '0.8rem',
                                        background: recommendations.analysis.riskProfile === 'conservative' 
                                            ? 'rgba(16, 185, 129, 0.2)' 
                                            : recommendations.analysis.riskProfile === 'aggressive'
                                                ? 'rgba(239, 68, 68, 0.2)'
                                                : 'rgba(245, 158, 11, 0.2)',
                                        color: recommendations.analysis.riskProfile === 'conservative' 
                                            ? 'var(--accent-green)' 
                                            : recommendations.analysis.riskProfile === 'aggressive'
                                                ? 'var(--accent-red)'
                                                : 'var(--accent-gold)'
                                    }}>
                                        Profil: {recommendations.analysis.riskProfile}
                                    </span>
                                    <span style={{
                                        padding: '4px 12px',
                                        borderRadius: '20px',
                                        fontSize: '0.8rem',
                                        background: 'rgba(59, 130, 246, 0.2)',
                                        color: 'var(--accent-blue)'
                                    }}>
                                        Tendance: {recommendations.analysis.trend}
                                    </span>
                                </div>

                                {/* Points forts */}
                                {recommendations.analysis.strengths?.length > 0 && (
                                    <div style={{ marginBottom: '12px' }}>
                                        <h5 style={{ color: 'var(--accent-green)', marginBottom: '8px', fontSize: '0.9rem' }}>
                                            ‚úÖ Points forts
                                        </h5>
                                        {recommendations.analysis.strengths.map((s, i) => (
                                            <p key={i} style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', marginLeft: '16px' }}>
                                                ‚Ä¢ {s}
                                            </p>
                                        ))}
                                    </div>
                                )}

                                {/* Points faibles */}
                                {recommendations.analysis.weaknesses?.length > 0 && (
                                    <div>
                                        <h5 style={{ color: 'var(--accent-red)', marginBottom: '8px', fontSize: '0.9rem' }}>
                                            ‚ö†Ô∏è Points √† am√©liorer
                                        </h5>
                                        {recommendations.analysis.weaknesses.map((w, i) => (
                                            <p key={i} style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', marginLeft: '16px' }}>
                                                ‚Ä¢ {w}
                                            </p>
                                        ))}
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Recommandations */}
                        {recommendations?.recommendations?.length > 0 && (
                            <div className="animate-fade-in delay-2">
                                <h4 style={{ marginBottom: '12px' }}>üí° Recommandations personnalis√©es</h4>
                                {recommendations.recommendations.map((rec, index) => (
                                    <div key={index} className="card" style={{ marginBottom: '12px' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '8px' }}>
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                <span>{getCategoryIcon(rec.category)}</span>
                                                <h5 style={{ fontSize: '0.95rem' }}>{rec.title}</h5>
                                            </div>
                                            <span style={{
                                                padding: '2px 8px',
                                                borderRadius: '10px',
                                                fontSize: '0.7rem',
                                                background: `${getPriorityColor(rec.priority)}20`,
                                                color: getPriorityColor(rec.priority)
                                            }}>
                                                {rec.priority?.toUpperCase()}
                                            </span>
                                        </div>
                                        <p style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', marginBottom: '8px' }}>
                                            {rec.description}
                                        </p>
                                        {rec.actionable && (
                                            <div style={{
                                                background: 'rgba(245, 158, 11, 0.1)',
                                                padding: '8px 12px',
                                                borderRadius: '8px',
                                                borderLeft: '3px solid var(--accent-gold)'
                                            }}>
                                                <span style={{ color: 'var(--accent-gold)', fontSize: '0.8rem', fontWeight: '600' }}>
                                                    üìå Action: 
                                                </span>
                                                <span style={{ color: 'var(--text-primary)', fontSize: '0.85rem' }}>
                                                    {rec.actionable}
                                                </span>
                                            </div>
                                        )}
                                    </div>
                                ))}
                            </div>
                        )}

                        {/* Param√®tres optimaux */}
                        {recommendations?.optimalSettings && (
                            <div className="card animate-fade-in delay-3" style={{ marginTop: '16px' }}>
                                <h4 style={{ marginBottom: '12px', color: 'var(--accent-gold)' }}>‚öôÔ∏è Param√®tres recommand√©s</h4>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
                                    <div>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>% max par pari</div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.1rem' }}>
                                            {recommendations.optimalSettings.suggestedMaxBetPercentage || 5}%
                                        </div>
                                    </div>
                                    <div>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>Mise minimum</div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.1rem' }}>
                                            {(recommendations.optimalSettings.suggestedMinBet || 100).toLocaleString()} F
                                        </div>
                                    </div>
                                </div>
                                {recommendations.optimalSettings.preferredOptionTypes?.length > 0 && (
                                    <div style={{ marginTop: '12px' }}>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem', marginBottom: '4px' }}>
                                            Types de paris recommand√©s:
                                        </div>
                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                                            {recommendations.optimalSettings.preferredOptionTypes.map((type, i) => (
                                                <span key={i} style={{
                                                    padding: '4px 10px',
                                                    borderRadius: '15px',
                                                    fontSize: '0.8rem',
                                                    background: 'rgba(16, 185, 129, 0.2)',
                                                    color: 'var(--accent-green)'
                                                }}>
                                                    {type}
                                                </span>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Message de motivation */}
                        {recommendations?.motivationalMessage && (
                            <div className="animate-fade-in delay-4" style={{
                                marginTop: '20px',
                                padding: '16px',
                                background: 'rgba(139, 92, 246, 0.1)',
                                border: '1px solid rgba(139, 92, 246, 0.3)',
                                borderRadius: '12px',
                                textAlign: 'center'
                            }}>
                                <span style={{ fontSize: '1.5rem' }}>üí™</span>
                                <p style={{ color: '#a78bfa', marginTop: '8px', fontStyle: 'italic' }}>
                                    {recommendations.motivationalMessage}
                                </p>
                            </div>
                        )}

                        {/* Attribution */}
                        <p className="animate-fade-in delay-5" style={{
                            marginTop: '20px',
                            color: 'var(--text-muted)',
                            fontSize: '0.75rem',
                            textAlign: 'center'
                        }}>
                            üîÆ Analyse g√©n√©r√©e par DeepSeek Reasoner
                        </p>
                    </main>
                    <BottomNav />
                </>
            );
        };

        const FormationsPage = () => {
            const { user, navigate } = useApp();

            if (!user) {
                navigate('login');
                return null;
            }

            return (
                <>
                    <Header showBack={true} title="Formations" />
                    <main className="main-content">
                        <div className="card card-clickable animate-fade-in" onClick={() => navigate('formation-detail')}>
                            <div style={{ display: 'flex', gap: '16px' }}>
                                <div style={{ 
                                    width: '80px', 
                                    height: '80px', 
                                    borderRadius: '12px', 
                                    background: 'var(--gradient-gold)',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }}>
                                    <Icons.Book />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <h3>Deviens un parieur pro</h3>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.9rem', marginTop: '4px' }}>
                                        Les fondamentaux des paris sportifs
                                    </p>
                                    <div style={{ marginTop: '8px', color: 'var(--accent-gold)', fontSize: '0.85rem' }}>
                                        3 chapitres ‚Ä¢ 60 min
                                    </div>
                                </div>
                            </div>
                        </div>
                    </main>
                    <BottomNav />
                </>
            );
        };

        const FormationDetailPage = () => {
            const { navigate } = useApp();

            const chapters = [
                { id: 1, title: 'Les bases des paris sportifs', duration: '15 min' },
                { id: 2, title: 'Gestion de bankroll', duration: '20 min' },
                { id: 3, title: 'Analyser les cotes', duration: '25 min' }
            ];

            return (
                <>
                    <Header showBack={true} title="Formation" />
                    <main className="main-content">
                        <h2 className="section-title animate-fade-in">Deviens un parieur pro</h2>
                        <p className="section-subtitle animate-fade-in delay-1">
                            Apprenez les fondamentaux pour devenir un parieur rentable
                        </p>

                        {chapters.map((chapter, index) => (
                            <div 
                                key={chapter.id}
                                className={`card card-clickable animate-fade-in delay-${index + 2}`}
                                onClick={() => navigate('chapter-detail')}
                            >
                                <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                                    <div style={{ 
                                        width: '48px', 
                                        height: '48px', 
                                        borderRadius: '50%', 
                                        background: 'var(--bg-secondary)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        fontFamily: 'Space Mono',
                                        fontWeight: '700',
                                        color: 'var(--accent-gold)'
                                    }}>
                                        {chapter.id}
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <h4>{chapter.title}</h4>
                                        <span style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>
                                            {chapter.duration}
                                        </span>
                                    </div>
                                    <Icons.Play />
                                </div>
                            </div>
                        ))}
                    </main>
                    <BottomNav />
                </>
            );
        };

        const ChapterDetailPage = () => {
            return (
                <>
                    <Header showBack={true} title="Chapitre 1" />
                    <main className="main-content">
                        <div className="animate-fade-in" style={{ 
                            background: 'var(--bg-card)', 
                            borderRadius: '16px', 
                            aspectRatio: '16/9',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            marginBottom: '20px'
                        }}>
                            <div style={{ 
                                width: '64px', 
                                height: '64px', 
                                borderRadius: '50%',
                                background: 'var(--gradient-gold)',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                cursor: 'pointer'
                            }}>
                                <Icons.Play />
                            </div>
                        </div>

                        <h2 className="section-title animate-fade-in delay-1">Les bases des paris sportifs</h2>
                        
                        <div className="animate-fade-in delay-2" style={{ color: 'var(--text-secondary)', lineHeight: '1.7' }}>
                            <p style={{ marginBottom: '16px' }}>
                                Dans ce chapitre, vous apprendrez les fondamentaux des paris sportifs : 
                                comprendre les cotes, les diff√©rents types de paris, et comment √©valuer les opportunit√©s.
                            </p>
                            <p>
                                Une bonne compr√©hension de ces bases est essentielle pour devenir un parieur rentable sur le long terme.
                            </p>
                        </div>
                    </main>
                    <BottomNav />
                </>
            );
        };

        // ============== ROUTER ==============

        const Router = () => {
            const { currentPage } = useApp();

            const pages = {
                'home': HomePage,
                'login': LoginPage,
                'outils': OutilsPage,
                'matchs': MatchsPage,
                'balance-input': BalanceInputPage,
                'strategy': StrategyPage,
                'pronostics': PronosticsPage,
                'cashout': CashoutPage,
                'coverage-strategy': CoverageStrategyPage,
                'capital': CapitalPage,
                'recommendations': RecommendationsPage,
                'formations': FormationsPage,
                'formation-detail': FormationDetailPage,
                'chapter-detail': ChapterDetailPage,
            };

            const PageComponent = pages[currentPage] || HomePage;
            return <PageComponent />;
        };

        // ============== APP ==============

        const App = () => {
            const appContext = useApp();
            
            return (
                <>
                    <Router />
                    {appContext?.notification && (
                        <Notification 
                            message={appContext.notification.message} 
                            type={appContext.notification.type} 
                        />
                    )}
                    {/* Loader global avec message */}
                    <GlobalLoader message={appContext?.loadingMessage} />
                </>
            );
        };

        // ============== RENDER ==============

        const Root = () => (
            <AppProvider>
                <div className="app-container">
                    <App />
                </div>
            </AppProvider>
        );

        ReactDOM.createRoot(document.getElementById('root')).render(<Root />);
    </script>
</body>
</html>
