<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>E-Cauri App V2 - Paris Sportifs Intelligents</title>
    <!-- React -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Firebase Configuration - REMPLACER PAR VOS VALEURS -->
    <script>
        // Configuration Firebase pour le projet: football-opportunities
        // ‚ö†Ô∏è IMPORTANT: Remplacez ces valeurs par celles de votre projet Firebase
        // Trouvez-les dans: Firebase Console ‚Üí Param√®tres du projet ‚Üí Vos applications ‚Üí Web
         const firebaseConfig = {
            apiKey: "AIzaSyAoUl0RbzzolyuZ-TAd8v0i9O5X2w1Ywfg",
            authDomain: "football-opportunities.firebaseapp.com",
            projectId: "football-opportunities",
            storageBucket: "football-opportunities.firebasestorage.app",
            messagingSenderId: "374999604744",
            appId: "1:374999604744:web:321fc14e53ff57313efbbd"
        };
        
        // Initialiser Firebase seulement si la config est valide
        let firebaseApp = null;
        let firebaseAuth = null;
        
        if (firebaseConfig.apiKey && !firebaseConfig.apiKey.includes("VOTRE_")) {
            try {
                firebaseApp = firebase.initializeApp(firebaseConfig);
                firebaseAuth = firebase.auth();
                console.log("‚úÖ Firebase Auth initialized");
            } catch (error) {
                console.warn("‚ö†Ô∏è Firebase Auth init failed:", error.message);
            }
        } else {
            console.warn("‚ö†Ô∏è Firebase config not set - Auth will use mock mode");
            console.warn("   Modifiez firebaseConfig dans e-cauri-app-v2.html");
        }
    </script>
    
    <style>
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #111827;
            --bg-card: #1a2332;
            --bg-card-hover: #232f42;
            --accent-gold: #f59e0b;
            --accent-gold-light: #fbbf24;
            --accent-green: #10b981;
            --accent-green-light: #34d399;
            --accent-red: #ef4444;
            --accent-red-light: #f87171;
            --accent-blue: #3b82f6;
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --border-color: #374151;
            --gradient-gold: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            --gradient-green: linear-gradient(135deg, #10b981 0%, #059669 100%);
            --gradient-dark: linear-gradient(180deg, #0a0e17 0%, #111827 100%);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        #root { min-height: 100vh; display: flex; flex-direction: column; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes loading-bar { 
            0% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
            100% { transform: translateX(250%); }
        }

        .animate-fade-in { animation: fadeIn 0.4s ease-out forwards; }
        .animate-slide-up { animation: slideUp 0.5s ease-out forwards; }
        .delay-1 { animation-delay: 0.1s; opacity: 0; }
        .delay-2 { animation-delay: 0.2s; opacity: 0; }
        .delay-3 { animation-delay: 0.3s; opacity: 0; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-secondary); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }

        .app-container {
            max-width: 480px;
            margin: 0 auto;
            min-height: 100vh;
            background: var(--gradient-dark);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: rgba(10, 14, 23, 0.95);
            backdrop-filter: blur(10px);
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid rgba(55, 65, 81, 0.5);
        }

        .logo {
            font-family: 'Space Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            background: var(--gradient-gold);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -1px;
        }

        .header-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-card);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
        }

        .header-icon:hover { background: var(--bg-card-hover); border-color: var(--accent-gold); }
        .header-icon.connected { border-color: var(--accent-green); background: rgba(16, 185, 129, 0.15); }
        .header-icon svg { width: 20px; height: 20px; color: var(--text-secondary); }
        .header-icon.connected svg { color: var(--accent-green); }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: color 0.2s;
            background: none;
            border: none;
            font-family: inherit;
        }

        .back-btn:hover { color: var(--text-primary); }
        .back-btn svg { width: 20px; height: 20px; }
        .page-title { font-size: 1.1rem; font-weight: 600; color: var(--text-primary); }

        /* Main Content */
        .main-content { flex: 1; padding: 20px; padding-bottom: 100px; }

        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .card:hover { background: var(--bg-card-hover); transform: translateY(-2px); }
        .card-clickable { cursor: pointer; }

        .match-card {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .match-teams {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .team-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .team-logo {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: var(--bg-secondary);
            object-fit: contain;
        }

        .team-name { font-weight: 500; font-size: 0.95rem; }
        .match-meta { color: var(--text-muted); font-size: 0.8rem; margin-top: 8px; }
        .match-arrow { color: var(--text-muted); }

        /* Buttons */
        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 14px 24px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-family: inherit;
        }

        .btn svg { width: 20px; height: 20px; }

        .btn-primary {
            background: var(--gradient-gold);
            color: #000;
        }

        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(245, 158, 11, 0.3); }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover { background: var(--bg-card-hover); border-color: var(--accent-gold); }

        .btn-success {
            background: var(--gradient-green);
            color: #fff;
        }

        .btn-success:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(16, 185, 129, 0.3); }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: #fff;
        }

        .btn-danger:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(239, 68, 68, 0.3); }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Input */
        .input-group { margin-bottom: 20px; }
        .input-label { display: block; color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 8px; }

        .input {
            width: 100%;
            padding: 14px 16px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        .input:focus {
            outline: none;
            border-color: var(--accent-gold);
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.1);
        }

        .input::placeholder { color: var(--text-muted); }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border-color);
        }

        .stat-card.green { border-color: rgba(16, 185, 129, 0.3); background: rgba(16, 185, 129, 0.1); }
        .stat-card.red { border-color: rgba(239, 68, 68, 0.3); background: rgba(239, 68, 68, 0.1); }
        .stat-label { color: var(--text-muted); font-size: 0.8rem; margin-bottom: 4px; }
        .stat-value { font-family: 'Space Mono', monospace; font-size: 1.2rem; font-weight: 700; }
        .stat-value.green { color: var(--accent-green); }
        .stat-value.red { color: var(--accent-red); }

        /* Option Cards */
        .option-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option-card:hover { border-color: var(--accent-gold); }
        .option-card.selected { border-color: var(--accent-gold); background: rgba(245, 158, 11, 0.1); }

        .option-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .option-name { font-weight: 500; }
        .option-odds { font-family: 'Space Mono', monospace; color: var(--accent-gold); font-weight: 700; }
        .option-prob { color: var(--text-muted); font-size: 0.85rem; }

        /* Bottom Nav */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 480px;
            background: rgba(10, 14, 23, 0.98);
            backdrop-filter: blur(10px);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: 12px 0;
            z-index: 100;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            color: var(--text-muted);
            cursor: pointer;
            transition: color 0.2s;
            background: none;
            border: none;
            font-family: inherit;
            padding: 8px 16px;
        }

        .nav-item:hover, .nav-item.active { color: var(--accent-gold); }
        .nav-item svg { width: 24px; height: 24px; }
        .nav-label { font-size: 0.7rem; }

        /* Loading */
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 40px auto;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 14, 23, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-text {
            color: var(--text-secondary);
            margin-top: 20px;
            font-size: 0.9rem;
        }

        /* AI Analysis Box */
        .analysis-box {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(245, 158, 11, 0.05) 100%);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .analysis-title {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--accent-gold);
            font-weight: 600;
            margin-bottom: 12px;
        }

        .analysis-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 500;
            z-index: 1001;
            animation: slideUp 0.3s ease-out;
        }

        .notification.success { background: var(--accent-green); color: #fff; }
        .notification.error { background: var(--accent-red); color: #fff; }
        .notification.info { background: var(--accent-blue); color: #fff; }

        /* Balance Display */
        .balance-display {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 24px;
            text-align: center;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .balance-label { color: var(--text-muted); font-size: 0.9rem; margin-bottom: 8px; }

        .balance-value {
            font-family: 'Space Mono', monospace;
            font-size: 2rem;
            font-weight: 700;
            background: var(--gradient-gold);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Chart */
        .chart-container {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .chart-title { color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 16px; }

        .chart-placeholder {
            height: 150px;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(16, 185, 129, 0.05) 100%);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .chart-line {
            position: absolute;
            bottom: 20%;
            left: 5%;
            width: 90%;
            height: 2px;
            background: var(--accent-green);
            transform-origin: left;
            transform: rotate(-10deg);
        }

        /* Recommendation Box */
        .recommendation-box {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(16, 185, 129, 0.05) 100%);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .recommendation-title {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--accent-green);
            font-weight: 600;
            margin-bottom: 12px;
        }

        .recommendation-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Section Title */
        .section-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .section-subtitle {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useContext, createContext, useCallback } = React;

        // ============== CONFIGURATION API ==============
        const API_BASE_URL = 'https://e-cauri-api.onrender.com/api';

        // ============== SERVICE NOTIFICATIONS NAVIGATEUR ==============
        // D√âSACTIV√â - L'API Notification n'est pas disponible dans ce contexte
        const NotificationService = {
            permission: 'denied',
            supported: false,
            
            init() {
                // Notifications d√©sactiv√©es
                console.log('üîî Notifications: d√©sactiv√©es (API non disponible)');
                return false;
            },
            
            async requestPermission() {
                return false;
            },
            
            async send(title, options = {}) {
                // Afficher dans la console √† la place
                console.log(`üì¢ [Notification] ${title}`, options.body || '');
                return null;
            },
            
            // Notifications sp√©cifiques - juste des logs
            analysisComplete(matchName) {
                console.log(`‚úÖ Analyse termin√©e: ${matchName}`);
                return null;
            },
            
            recommendationsReady() {
                console.log('üìä Recommandations disponibles');
                return null;
            },
            
            matchStarting(matchName, minutesUntil) {
                console.log(`‚öΩ ${matchName} commence dans ${minutesUntil} minutes`);
                return null;
            },
            
            matchResult(matchName, result, profit) {
                console.log(`üéØ R√©sultat ${matchName}: ${profit >= 0 ? 'Gain' : 'Perte'} de ${Math.abs(profit)} FCFA`);
                return null;
            }
        };

        // ============== IC√îNES ==============
        const Icons = {
            Home: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9,22 9,12 15,12 15,22"/></svg>,
            Tool: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>,
            Chart: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="20" x2="12" y2="10"/><line x1="18" y1="20" x2="18" y2="4"/><line x1="6" y1="20" x2="6" y2="16"/></svg>,
            TrendingUp: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="23,6 13.5,15.5 8.5,10.5 1,18"/><polyline points="17,6 23,6 23,12"/></svg>,
            Trending: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="23,6 13.5,15.5 8.5,10.5 1,18"/><polyline points="17,6 23,6 23,12"/></svg>,
            Brain: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 4.44-1.54"/><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-4.44-1.54"/></svg>,
            User: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>,
            ArrowLeft: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12,19 5,12 12,5"/></svg>,
            ArrowRight: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12,5 19,12 12,19"/></svg>,
            Check: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="20,6 9,17 4,12"/></svg>,
            Book: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>,
            Play: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="5,3 19,12 5,21 5,3"/></svg>,
            Lock: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>,
            Target: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>,
            Zap: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="13,2 3,14 12,14 11,22 21,10 12,10 13,2"/></svg>,
            AlertCircle: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>,
            Lightbulb: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="9" y1="18" x2="15" y2="18"/><line x1="10" y1="22" x2="14" y2="22"/><path d="M15.09 14c.18-.98.65-1.74 1.41-2.5A4.65 4.65 0 0 0 18 8 6 6 0 0 0 6 8c0 1 .23 2.23 1.5 3.5A4.61 4.61 0 0 1 8.91 14"/></svg>,
            DollarSign: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>,
            Shield: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>,
            Eye: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>,
            Bell: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg>,
            Refresh: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>,
            Calculator: () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="4" y="2" width="16" height="20" rx="2"/><line x1="8" y1="6" x2="16" y2="6"/><line x1="8" y1="10" x2="8" y2="10.01"/><line x1="12" y1="10" x2="12" y2="10.01"/><line x1="16" y1="10" x2="16" y2="10.01"/><line x1="8" y1="14" x2="8" y2="14.01"/><line x1="12" y1="14" x2="12" y2="14.01"/><line x1="16" y1="14" x2="16" y2="14.01"/><line x1="8" y1="18" x2="8" y2="18.01"/><line x1="12" y1="18" x2="16" y2="18"/></svg>,
        };

        // ============== CONTEXTE ==============
        const AppContext = createContext(null);

        const AppProvider = ({ children }) => {
            const [currentPage, setCurrentPage] = useState('home');
            const [pageHistory, setPageHistory] = useState(['home']);
            const [user, setUser] = useState(null);
            const [pendingPage, setPendingPage] = useState(null);
            
            // Data state
            const [matches, setMatches] = useState([]);
            const [selectedMatch, setSelectedMatch] = useState(null);
            const [userBalance, setUserBalance] = useState(0);
            const [currentPrediction, setCurrentPrediction] = useState(null);
            const [activePredictions, setActivePredictions] = useState([]);
            const [selectedOptions, setSelectedOptions] = useState([]);
            
            // ========== SYST√àME DE VERROUILLAGE DES ANALYSES ==========
            // Emp√™che les analyses/hedging multiples et persiste l'√©tat
            const [analysisLock, setAnalysisLock] = useState(null); // { type: 'prediction'|'hedging', id: string, startedAt: timestamp }
            const [pendingAnalysis, setPendingAnalysis] = useState(null); // Analyse en attente de r√©sultat
            
            // Charger le verrou depuis localStorage au d√©marrage
            useEffect(() => {
                try {
                    const savedLock = localStorage.getItem('ecauri_analysis_lock');
                    if (savedLock) {
                        const lock = JSON.parse(savedLock);
                        // V√©rifier si le verrou n'est pas trop vieux (max 10 minutes)
                        const lockAge = Date.now() - lock.startedAt;
                        if (lockAge < 10 * 60 * 1000) {
                            setAnalysisLock(lock);
                            console.log('üîí Analyse en cours restaur√©e:', lock);
                        } else {
                            // Verrou expir√©, le supprimer
                            localStorage.removeItem('ecauri_analysis_lock');
                            console.log('üîì Verrou expir√©, supprim√©');
                        }
                    }
                    
                    // Restaurer les pr√©dictions en cours
                    const savedPredictions = localStorage.getItem('ecauri_active_predictions');
                    if (savedPredictions) {
                        const predictions = JSON.parse(savedPredictions);
                        setActivePredictions(predictions);
                        console.log('üìã Pr√©dictions restaur√©es:', predictions.length);
                    }
                } catch (e) {
                    console.warn('Erreur restauration √©tat:', e);
                }
            }, []);
            
            // Persister le verrou dans localStorage
            useEffect(() => {
                if (analysisLock) {
                    localStorage.setItem('ecauri_analysis_lock', JSON.stringify(analysisLock));
                } else {
                    localStorage.removeItem('ecauri_analysis_lock');
                }
            }, [analysisLock]);
            
            // Persister les pr√©dictions actives
            useEffect(() => {
                if (activePredictions.length > 0) {
                    localStorage.setItem('ecauri_active_predictions', JSON.stringify(activePredictions));
                }
            }, [activePredictions]);
            
            // Fonction pour acqu√©rir un verrou
            const acquireAnalysisLock = (type, id) => {
                if (analysisLock) {
                    console.warn('üîí Verrou d√©j√† actif:', analysisLock);
                    return false;
                }
                const newLock = { type, id, startedAt: Date.now() };
                setAnalysisLock(newLock);
                console.log('üîí Verrou acquis:', newLock);
                return true;
            };
            
            // Fonction pour lib√©rer le verrou
            const releaseAnalysisLock = () => {
                setAnalysisLock(null);
                console.log('üîì Verrou lib√©r√©');
            };
            
            // V√©rifier si une analyse est en cours
            const isAnalysisInProgress = () => {
                return analysisLock !== null;
            };
            
            // UI state - Loading states am√©lior√©s
            const [loading, setLoading] = useState(false);
            const [loadingMessage, setLoadingMessage] = useState('');
            const [notification, setNotification] = useState(null);
            const [notificationsEnabled, setNotificationsEnabled] = useState(false);

            // Demander permission notifications au chargement
            useEffect(() => {
                const initNotifications = async () => {
                    try {
                        // Initialiser le service
                        const supported = NotificationService.init();
                        if (!supported) {
                            console.log('‚ö†Ô∏è Notifications non support√©es dans ce contexte');
                            return;
                        }
                        
                        // Demander la permission
                        const granted = await NotificationService.requestPermission();
                        setNotificationsEnabled(granted);
                        if (granted) {
                            console.log('‚úÖ Notifications navigateur activ√©es');
                        }
                    } catch (error) {
                        console.warn('Erreur init notifications:', error);
                    }
                };
                initNotifications();
            }, []);

            const navigate = (page, params = {}) => {
                setPageHistory(prev => [...prev, page]);
                setCurrentPage(page);
            };

            const goBack = () => {
                if (pageHistory.length > 1) {
                    const newHistory = [...pageHistory];
                    newHistory.pop();
                    setPageHistory(newHistory);
                    setCurrentPage(newHistory[newHistory.length - 1]);
                }
            };

            const requireAuth = (targetPage) => {
                if (user) {
                    navigate(targetPage);
                } else {
                    setPendingPage(targetPage);
                    navigate('login');
                }
            };

            const login = async (email, password) => {
                setLoading(true);
                try {
                    if (firebaseAuth) {
                        // Firebase Auth r√©el
                        const userCredential = await firebaseAuth.signInWithEmailAndPassword(email, password);
                        const fbUser = userCredential.user;
                        
                        // R√©cup√©rer le token pour les appels API
                        const token = await fbUser.getIdToken();
                        localStorage.setItem('authToken', token);
                        
                        setUser({ 
                            uid: fbUser.uid,
                            email: fbUser.email, 
                            displayName: fbUser.displayName || email.split('@')[0]
                        });
                        showNotification('Connexion r√©ussie !', 'success');
                    } else {
                        // Mode d√©mo (sans Firebase)
                        await new Promise(r => setTimeout(r, 500));
                        const mockUser = { 
                            uid: 'demo_' + Date.now(),
                            email, 
                            displayName: email.split('@')[0] 
                        };
                        localStorage.setItem('authToken', 'demo_token_' + Date.now());
                        setUser(mockUser);
                        showNotification('Connexion d√©mo r√©ussie', 'info');
                    }
                    
                    setLoading(false);
                    if (pendingPage) {
                        navigate(pendingPage);
                        setPendingPage(null);
                    } else {
                        navigate('home');
                    }
                    return true;
                } catch (error) {
                    setLoading(false);
                    console.error('Login error:', error);
                    showNotification(getFirebaseErrorMessage(error.code), 'error');
                    return false;
                }
            };

            const register = async (email, password, displayName) => {
                setLoading(true);
                try {
                    if (firebaseAuth) {
                        // Cr√©er le compte Firebase
                        const userCredential = await firebaseAuth.createUserWithEmailAndPassword(email, password);
                        const fbUser = userCredential.user;
                        
                        // Mettre √† jour le profil
                        await fbUser.updateProfile({ displayName });
                        
                        // R√©cup√©rer le token
                        const token = await fbUser.getIdToken();
                        localStorage.setItem('authToken', token);
                        
                        // Cr√©er le profil utilisateur c√¥t√© backend
                        await fetch(`${API_BASE_URL}/user/profile`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify({
                                email,
                                displayName,
                                currentBalance: 0
                            })
                        });
                        
                        setUser({ 
                            uid: fbUser.uid,
                            email: fbUser.email, 
                            displayName 
                        });
                        showNotification('Compte cr√©√© avec succ√®s !', 'success');
                    } else {
                        // Mode d√©mo
                        await new Promise(r => setTimeout(r, 500));
                        const mockUser = { uid: 'demo_' + Date.now(), email, displayName };
                        localStorage.setItem('authToken', 'demo_token_' + Date.now());
                        setUser(mockUser);
                        showNotification('Compte d√©mo cr√©√©', 'info');
                    }
                    
                    setLoading(false);
                    if (pendingPage) {
                        navigate(pendingPage);
                        setPendingPage(null);
                    } else {
                        navigate('home');
                    }
                    return true;
                } catch (error) {
                    setLoading(false);
                    console.error('Register error:', error);
                    showNotification(getFirebaseErrorMessage(error.code), 'error');
                    return false;
                }
            };

            const logout = async () => {
                if (firebaseAuth) {
                    await firebaseAuth.signOut();
                }
                localStorage.removeItem('authToken');
                setUser(null);
                navigate('home');
                showNotification('D√©connexion r√©ussie', 'info');
            };

            // √âcouter les changements d'√©tat d'authentification Firebase
            useEffect(() => {
                if (firebaseAuth) {
                    const unsubscribe = firebaseAuth.onAuthStateChanged(async (fbUser) => {
                        if (fbUser) {
                            const token = await fbUser.getIdToken();
                            localStorage.setItem('authToken', token);
                            setUser({
                                uid: fbUser.uid,
                                email: fbUser.email,
                                displayName: fbUser.displayName || fbUser.email?.split('@')[0]
                            });
                        }
                    });
                    return () => unsubscribe();
                }
            }, []);

            // Helper pour obtenir un token valide (rafra√Æchi si n√©cessaire)
            const getValidToken = async (forceRefresh = false) => {
                try {
                    // Si Firebase Auth est disponible et un utilisateur est connect√©
                    if (firebaseAuth && firebaseAuth.currentUser) {
                        // Forcer le rafra√Æchissement du token
                        const freshToken = await firebaseAuth.currentUser.getIdToken(forceRefresh);
                        localStorage.setItem('authToken', freshToken);
                        if (forceRefresh) {
                            console.log('üîë Token rafra√Æchi avec succ√®s');
                        }
                        return freshToken;
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Impossible de rafra√Æchir le token:', error.message);
                }
                
                // Fallback: utiliser le token stock√©
                return localStorage.getItem('authToken');
            };

            // Helper pour les appels API avec gestion automatique du token expir√©
            const apiCallWithAuth = async (url, options = {}, retryCount = 0) => {
                // Obtenir un token valide
                const token = await getValidToken(retryCount > 0);
                
                if (!token) {
                    throw new Error('No auth token available');
                }
                
                const response = await fetch(url, {
                    ...options,
                    headers: {
                        ...options.headers,
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                // Si token expir√© (401), rafra√Æchir et r√©essayer une fois
                if (response.status === 401 && retryCount < 1) {
                    console.log('üîÑ Token expir√©, rafra√Æchissement en cours...');
                    return apiCallWithAuth(url, options, retryCount + 1);
                }
                
                return response;
            };

            // Charger les pr√©dictions de l'utilisateur depuis Firebase
            const fetchUserPredictions = async () => {
                const token = localStorage.getItem('authToken');
                if (!token) return;

                try {
                    const response = await apiCallWithAuth(`${API_BASE_URL}/predictions`);

                    if (response.ok) {
                        const data = await response.json();
                        const predictions = data.predictions || [];
                        
                        console.log('üìä Raw predictions from server:', predictions.length);
                        predictions.forEach((p, i) => {
                            console.log(`  ${i+1}. ${p.matchInfo?.homeTeam || p.meta?.homeTeam} vs ${p.matchInfo?.awayTeam || p.meta?.awayTeam}`);
                            console.log(`     Status: ${p.status}, selectedOptions: ${p.selectedOptions?.length || 0}`);
                        });
                        
                        // Les pr√©dictions sont d√©j√† filtr√©es et d√©dupliqu√©es c√¥t√© serveur
                        setActivePredictions(predictions);
                        console.log(`‚úÖ Loaded ${predictions.length} active predictions from Firebase`);
                    }
                } catch (error) {
                    console.warn('Could not fetch user predictions:', error);
                }
            };

            // Charger le capital de l'utilisateur depuis Firebase
            const fetchUserCapital = async () => {
                const token = localStorage.getItem('authToken');
                if (!token) return;

                try {
                    const response = await apiCallWithAuth(`${API_BASE_URL}/user/capital`);

                    if (response.ok) {
                        const data = await response.json();
                        if (data.capital?.currentBalance !== undefined) {
                            setUserBalance(data.capital.currentBalance);
                            console.log(`‚úÖ Loaded user balance: ${data.capital.currentBalance} FCFA`);
                        }
                    }
                } catch (error) {
                    console.warn('Could not fetch user capital:', error);
                }
            };

            // Charger les donn√©es utilisateur quand il se connecte
            useEffect(() => {
                if (user) {
                    console.log('üë§ User connected, loading data...');
                    fetchUserPredictions();
                    fetchUserCapital();
                } else {
                    // R√©initialiser les donn√©es si d√©connect√©
                    setActivePredictions([]);
                    setCurrentPrediction(null);
                }
            }, [user]);

            // ============== SYST√àME DE SUIVI AUTOMATIQUE DES MATCHS ==============
            const [livePollingActive, setLivePollingActive] = useState(false);
            
            // Fonction pour v√©rifier le statut live d'un match et agir automatiquement
            const checkMatchLiveStatus = async (prediction) => {
                if (!prediction || !prediction.matchInfo?.fixtureId) return null;
                
                const token = localStorage.getItem('authToken');
                if (!token) return null;
                
                try {
                    const response = await fetch(`${API_BASE_URL}/predictions/${prediction.id}/live-status`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    if (!response.ok) return null;
                    
                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.warn('Could not check live status:', error);
                    return null;
                }
            };
            
            // Fonction pour auto-finaliser un match termin√©
            const autoFinalizeMatch = async (predictionId) => {
                const token = localStorage.getItem('authToken');
                if (!token) return;
                
                try {
                    console.log(`üèÅ Auto-finalizing prediction ${predictionId}...`);
                    const response = await fetch(`${API_BASE_URL}/predictions/${predictionId}/auto-finalize`, {
                        method: 'POST',
                        headers: { 
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('‚úÖ Match finalized:', result);
                        
                        // Notification de r√©sultat
                        const profit = result.capitalUpdate?.change || 0;
                        if (profit >= 0) {
                            showNotification(`üéâ Victoire ! Gain de ${profit.toLocaleString()} FCFA`, 'success');
                        } else {
                            showNotification(`üòî D√©faite. Perte de ${Math.abs(profit).toLocaleString()} FCFA`, 'error');
                        }
                        
                        // Rafra√Æchir les donn√©es
                        fetchUserPredictions();
                        fetchUserCapital();
                    }
                } catch (error) {
                    console.error('Auto-finalize error:', error);
                }
            };
            
            // Polling automatique toutes les 60 secondes pour les matchs actifs
            useEffect(() => {
                if (!user || activePredictions.length === 0) {
                    setLivePollingActive(false);
                    return;
                }
                
                // V√©rifier s'il y a des matchs en cours (status = active ou analyzing)
                const liveMatches = activePredictions.filter(p => 
                    p.status === 'active' || p.status === 'validated'
                );
                
                if (liveMatches.length === 0) {
                    setLivePollingActive(false);
                    return;
                }
                
                setLivePollingActive(true);
                console.log(`üîÑ Starting live polling for ${liveMatches.length} match(es)`);
                
                const pollInterval = setInterval(async () => {
                    console.log('üîç Checking live status...');
                    
                    for (const prediction of liveMatches) {
                        const liveStatus = await checkMatchLiveStatus(prediction);
                        
                        if (!liveStatus) continue;
                        
                        // Match termin√© ‚Üí Auto-finaliser
                        if (liveStatus.isFinished) {
                            console.log(`üèÅ Match ${prediction.matchInfo?.homeTeam} vs ${prediction.matchInfo?.awayTeam} termin√©!`);
                            await autoFinalizeMatch(prediction.id);
                        }
                        // Mi-temps atteinte ‚Üí Sugg√©rer hedging
                        else if (liveStatus.canHedge && !prediction.hedgingSuggested) {
                            console.log(`‚öΩ Mi-temps atteinte pour ${prediction.matchInfo?.homeTeam} vs ${prediction.matchInfo?.awayTeam}`);
                            showNotification(
                                `‚öΩ Mi-temps ! ${prediction.matchInfo?.homeTeam} vs ${prediction.matchInfo?.awayTeam} - Score: ${liveStatus.score?.home || 0}-${liveStatus.score?.away || 0}. Voulez-vous couvrir ?`,
                                'warning'
                            );
                            // Marquer comme sugg√©r√© pour ne pas r√©p√©ter
                            prediction.hedgingSuggested = true;
                        }
                        // Match commenc√©
                        else if (liveStatus.hasStarted && !prediction.matchStarted) {
                            console.log(`üü¢ Match commenc√©: ${prediction.matchInfo?.homeTeam} vs ${prediction.matchInfo?.awayTeam}`);
                            showNotification(
                                `üü¢ Coup d'envoi ! ${prediction.matchInfo?.homeTeam} vs ${prediction.matchInfo?.awayTeam}`,
                                'info'
                            );
                            prediction.matchStarted = true;
                        }
                        
                        // Mettre √† jour le statut live dans la pr√©diction
                        setActivePredictions(prev => prev.map(p => 
                            p.id === prediction.id 
                                ? { ...p, liveStatus, hedgingSuggested: prediction.hedgingSuggested, matchStarted: prediction.matchStarted }
                                : p
                        ));
                    }
                }, 60000); // Toutes les 60 secondes
                
                // V√©rifier imm√©diatement au montage
                (async () => {
                    for (const prediction of liveMatches) {
                        const liveStatus = await checkMatchLiveStatus(prediction);
                        if (liveStatus) {
                            setActivePredictions(prev => prev.map(p => 
                                p.id === prediction.id ? { ...p, liveStatus } : p
                            ));
                        }
                    }
                })();
                
                return () => {
                    console.log('üõë Stopping live polling');
                    clearInterval(pollInterval);
                };
            }, [user, activePredictions.length]);
            // ==================================================================

            // Helper pour les messages d'erreur Firebase
            const getFirebaseErrorMessage = (code) => {
                const messages = {
                    'auth/invalid-email': 'Email invalide',
                    'auth/user-disabled': 'Compte d√©sactiv√©',
                    'auth/user-not-found': 'Aucun compte avec cet email',
                    'auth/wrong-password': 'Mot de passe incorrect',
                    'auth/email-already-in-use': 'Email d√©j√† utilis√©',
                    'auth/weak-password': 'Mot de passe trop faible (min 6 caract√®res)',
                    'auth/network-request-failed': 'Erreur r√©seau'
                };
                return messages[code] || 'Erreur de connexion';
            };

            const showNotification = (message, type = 'info') => {
                setNotification({ message, type });
                setTimeout(() => setNotification(null), 3000);
            };

            // Fetch opportunities from Firebase via API
            const fetchOpportunities = async () => {
                setLoading(true);
                try {
                    const response = await fetch(`${API_BASE_URL}/opportunities`);
                    const data = await response.json();
                    setMatches(data.opportunities || []);
                } catch (error) {
                    console.error('Error fetching opportunities:', error);
                    // Donn√©es de d√©mo si API indisponible
                    setMatches([
                        { id: '1', homeTeam: 'PSG', awayTeam: 'Marseille', fixtureId: 123456, league: 'Ligue 1', matchDate: new Date(Date.now() + 86400000).toISOString(), status: 'upcoming' },
                        { id: '2', homeTeam: 'Real Madrid', awayTeam: 'Barcelona', fixtureId: 234567, league: 'La Liga', matchDate: new Date(Date.now() + 172800000).toISOString(), status: 'upcoming' },
                        { id: '3', homeTeam: 'Man City', awayTeam: 'Liverpool', fixtureId: 345678, league: 'Premier League', matchDate: new Date(Date.now() + 259200000).toISOString(), status: 'upcoming' }
                    ]);
                }
                setLoading(false);
            };

            // Analyze prediction via API
            const analyzePrediction = async (opportunityId, balance, bookmaker = 'default', stakePercentage = 6) => {
                // ========== V√âRIFICATION DU VERROUILLAGE ==========
                if (analysisLock) {
                    showNotification("‚è≥ Une analyse est d√©j√† en cours. Veuillez patienter.", "warning");
                    navigate('pronostics');
                    return;
                }
                
                // V√©rifier le token d'authentification
                const token = localStorage.getItem('authToken');
                if (!token) {
                    showNotification("Vous devez √™tre connect√© pour analyser", "error");
                    requireAuth('balance-input');
                    return;
                }

                console.log('üîÆ Starting analysis...', { opportunityId, balance, bookmaker, stakePercentage });
                
                // ========== ACQU√âRIR LE VERROU ==========
                const lockId = `prediction_${opportunityId}_${Date.now()}`;
                if (!acquireAnalysisLock('prediction', lockId)) {
                    showNotification("‚è≥ Impossible de lancer l'analyse. Une autre est en cours.", "warning");
                    return;
                }

                // 1. Cr√©er imm√©diatement une pr√©diction avec statut "analyzing"
                const tempPrediction = {
                    id: `analyzing_${Date.now()}`,
                    matchId: opportunityId,
                    match: selectedMatch,
                    matchInfo: {
                        homeTeam: selectedMatch?.homeTeam || '√âquipe A',
                        awayTeam: selectedMatch?.awayTeam || '√âquipe B',
                        league: selectedMatch?.league || 'Championnat',
                        matchDate: selectedMatch?.matchDate || selectedMatch?.date,
                        fixtureId: selectedMatch?.fixtureId || opportunityId
                    },
                    meta: {
                        homeTeam: selectedMatch?.homeTeam,
                        awayTeam: selectedMatch?.awayTeam,
                        league: selectedMatch?.league
                    },
                    selectedBookmaker: bookmaker,
                    userBalance: balance,
                    stakePercentage: stakePercentage,
                    status: 'analyzing',
                    createdAt: new Date().toISOString(),
                    isAnalyzing: true,
                    lockId: lockId // R√©f√©rence au verrou
                };

                // Ajouter aux pronostics actifs imm√©diatement
                setActivePredictions(prev => [tempPrediction, ...prev.filter(p => p.matchId !== opportunityId)]);
                
                // 2. Rediriger imm√©diatement vers "Pronos en cours"
                showNotification("üîÑ Analyse lanc√©e ! L'IA analyse le match...", "info");
                navigate('pronostics');

                // 3. Lancer l'analyse en arri√®re-plan
                try {
                    const response = await apiCallWithAuth(
                        `${API_BASE_URL}/predictions/analyze`,
                        {
                            method: 'POST',
                            body: JSON.stringify({ opportunityId, userBalance: balance, bookmaker, stakePercentage })
                        }
                    );

                    console.log('üì° Response status:', response.status);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || `Erreur serveur ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('‚úÖ Analysis result:', data);

                    if (data.prediction) {
                        // 4. Mettre √† jour la pr√©diction avec les r√©sultats
                        const completedPrediction = {
                            ...data.prediction,
                            id: data.prediction.id || tempPrediction.id.replace('analyzing_', 'pred_'),
                            matchId: opportunityId,
                            match: selectedMatch,
                            matchInfo: tempPrediction.matchInfo,
                            status: 'analyzed', // Analyse termin√©e
                            createdAt: tempPrediction.createdAt,
                            analyzedAt: new Date().toISOString(),
                            isAnalyzing: false,
                            isDemo: false
                        };
                        
                        // Remplacer la pr√©diction temporaire par la compl√®te
                        setActivePredictions(prev => prev.map(p => 
                            (p.id === tempPrediction.id || p.matchId === opportunityId) 
                                ? completedPrediction 
                                : p
                        ));
                        
                        setCurrentPrediction(completedPrediction);
                        setUserBalance(balance);
                        
                        showNotification("‚úÖ Analyse termin√©e ! Consultez les r√©sultats.", "success");
                        
                        // Notification navigateur
                        NotificationService.analysisComplete(
                            `${selectedMatch?.homeTeam || 'Match'} vs ${selectedMatch?.awayTeam || ''}`
                        );
                    } else {
                        throw new Error("R√©ponse invalide du serveur - Aucune pr√©diction retourn√©e");
                    }
                } catch (error) {
                    console.error('‚ùå Error analyzing prediction:', error);
                    
                    // ========== PAS DE MODE DEMO - AFFICHER L'ERREUR ==========
                    // Marquer la pr√©diction comme en erreur (l'utilisateur peut r√©essayer)
                    setActivePredictions(prev => prev.map(p => 
                        (p.id === tempPrediction.id || p.matchId === opportunityId)
                            ? { 
                                ...p, 
                                status: 'error', 
                                error: error.message, 
                                isAnalyzing: false,
                                canRetry: true, // Permettre de r√©essayer
                                errorAt: new Date().toISOString()
                            }
                            : p
                    ));
                    
                    showNotification(`‚ùå Erreur d'analyse: ${error.message}. Vous pouvez r√©essayer.`, "error");
                } finally {
                    // ========== TOUJOURS LIB√âRER LE VERROU ==========
                    releaseAnalysisLock();
                }
            };

            // Fonction pour g√©n√©rer des donn√©es de d√©mo
            const generateDemoPrediction = (match, balance, bookmaker) => {
                const homeTeam = match?.homeTeam || '√âquipe A';
                const awayTeam = match?.awayTeam || '√âquipe B';
                
                return {
                    matchAnalysis: {
                        claude: {
                            enjeu: {
                                teamA: { description: "Match important pour le classement", motivation: "high" },
                                teamB: { description: "Cherche √† surprendre", motivation: "medium" }
                            },
                            btts: { 
                                probability: 0.65, 
                                prediction: "oui", 
                                analysis: "Les deux √©quipes ont des attaques performantes et des d√©fenses perfectibles. Historiquement, leurs confrontations produisent des buts des deux c√¥t√©s." 
                            },
                            winner: { 
                                teamA: { probability: 0.55, analysis: "Avantage du terrain et meilleure forme r√©cente" },
                                teamB: { probability: 0.25, analysis: "Difficult√©s √† l'ext√©rieur cette saison" },
                                draw: { probability: 0.20, analysis: "Possible si match serr√©" },
                                prediction: 'teamA',
                                confidence: 'medium'
                            },
                            totalGoals: { 
                                expected: 2.8, 
                                over15: 0.85,
                                over25: 0.68,
                                over35: 0.42,
                                analysis: "Moyenne de 2.8 buts par match entre ces √©quipes"
                            },
                            trend: {
                                globalAnalysis: "Match offensif attendu avec un l√©ger avantage pour l'√©quipe √† domicile",
                                scenarios: [
                                    { description: `Victoire ${homeTeam} 2-1`, probability: 0.22 },
                                    { description: `Victoire ${homeTeam} 2-0`, probability: 0.18 },
                                    { description: "Match nul 1-1", probability: 0.15 }
                                ]
                            },
                            _thinking: "[Mode d√©mo - Simulation de r√©flexion IA]"
                        },
                        deepseek: {
                            btts: { probability: 0.62 },
                            winner: { prediction: "teamA", confidence: "medium" },
                            _thinking: "[Mode d√©mo - Simulation de raisonnement]"
                        }
                    },
                    oddsAnalysis: {
                        recommendedOptions: [
                            { option: `Victoire ${homeTeam}`, odds: 1.45, estimatedProbability: 0.55, riskLevel: "low", value: 1.20, reasoning: "Cote sous-√©valu√©e par rapport √† notre estimation" },
                            { option: "Plus de 2.5 buts", odds: 1.70, estimatedProbability: 0.68, riskLevel: "medium", value: 1.15, reasoning: "Bon ratio risque/rendement" },
                            { option: "BTTS Oui", odds: 1.85, estimatedProbability: 0.65, riskLevel: "medium", value: 1.21, reasoning: "Value int√©ressante bas√©e sur l'historique" }
                        ],
                        bestValue: "BTTS Oui",
                        safestOption: `Victoire ${homeTeam}`
                    },
                    synthesis: {
                        synthesis: "Les deux IA s'accordent sur une victoire probable de l'√©quipe √† domicile avec des buts des deux c√¥t√©s",
                        consensusPoints: ["Victoire domicile probable", "Match avec des buts (Over 2.5)", "BTTS probable"],
                        divergencePoints: [],
                        coverageScore: 0.75,
                        valueScore: 0.82
                    },
                    stakes: null, // Stakes calcul√©es au frontend maintenant
                    selectedBookmaker: {
                        key: bookmaker,
                        name: bookmaker.charAt(0).toUpperCase() + bookmaker.slice(1),
                        optionsCount: 15
                    },
                    meta: {
                        homeTeam,
                        awayTeam,
                        league: match?.league || 'Championnat',
                        aiEngines: {
                            primary: "Claude (Extended Thinking) - Mode D√©mo",
                            secondary: "DeepSeek (Reasoner) - Mode D√©mo"
                        },
                        generatedAt: new Date().toISOString()
                    }
                };
            };

            const value = {
                currentPage, navigate, goBack, requireAuth,
                user, login, logout, pendingPage, setPendingPage,
                matches, fetchOpportunities, selectedMatch, setSelectedMatch,
                userBalance, setUserBalance, currentPrediction, setCurrentPrediction,
                activePredictions, setActivePredictions,
                selectedOptions, setSelectedOptions,
                analyzePrediction,
                fetchUserPredictions, fetchUserCapital, getValidToken, apiCallWithAuth,
                loading, setLoading, loadingMessage, setLoadingMessage,
                notification, showNotification,
                livePollingActive,
                API_BASE_URL,
                // Syst√®me de verrouillage
                analysisLock, acquireAnalysisLock, releaseAnalysisLock, isAnalysisInProgress,
                register
            };

            return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
        };

        const useApp = () => useContext(AppContext);

        // ============== COMPOSANTS ==============
        
        const Header = ({ showBack = false, title = '' }) => {
            const { goBack, user, navigate, logout } = useApp();
            
            return (
                <header className="header">
                    {showBack ? (
                        <button className="back-btn" onClick={goBack}>
                            <Icons.ArrowLeft />
                            Retour
                        </button>
                    ) : (
                        <div className="logo">E-Cauri</div>
                    )}
                    
                    {title && <span className="page-title">{title}</span>}
                    
                    <div 
                        className={`header-icon ${user ? 'connected' : ''}`}
                        onClick={() => user ? logout() : navigate('login')}
                    >
                        <Icons.User />
                    </div>
                </header>
            );
        };

        const BottomNav = () => {
            const { currentPage, navigate, requireAuth } = useApp();
            
            const navItems = [
                { id: 'pronostics', label: 'Pronos', icon: Icons.Target },
                { id: 'outils', label: 'Outils', icon: Icons.Tool },
                { id: 'capital', label: 'Capital', icon: Icons.Chart },
                { id: 'formations', label: 'Formation', icon: Icons.Book, requireAuth: true }
            ];
            
            return (
                <nav className="bottom-nav">
                    {navItems.map(item => (
                        <button
                            key={item.id}
                            className={`nav-item ${currentPage === item.id ? 'active' : ''}`}
                            onClick={() => item.requireAuth ? requireAuth(item.id) : navigate(item.id)}
                        >
                            <item.icon />
                            <span className="nav-label">{item.label}</span>
                        </button>
                    ))}
                </nav>
            );
        };

        const LoadingOverlay = ({ text = "Analyse en cours..." }) => (
            <div className="loading-overlay">
                <div className="loading-spinner"></div>
                <div className="loading-text">{text}</div>
            </div>
        );

        // Composant de chargement global avec logo anim√©
        const GlobalLoader = ({ message }) => {
            if (!message) return null;
            
            return (
                <div style={{
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    background: 'rgba(10, 10, 10, 0.95)',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 9999
                }}>
                    {/* Logo anim√© */}
                    <div style={{
                        fontSize: '2.5rem',
                        fontWeight: 'bold',
                        marginBottom: '24px',
                        animation: 'pulse 1.5s ease-in-out infinite'
                    }}>
                        <span style={{ color: 'var(--accent-gold)' }}>E</span>
                        <span style={{ color: 'white' }}>-Cauri</span>
                    </div>
                    
                    {/* Spinner personnalis√© */}
                    <div style={{
                        width: '60px',
                        height: '60px',
                        border: '3px solid rgba(212, 175, 55, 0.2)',
                        borderTopColor: 'var(--accent-gold)',
                        borderRadius: '50%',
                        animation: 'spin 1s linear infinite',
                        marginBottom: '20px'
                    }}></div>
                    
                    {/* Message */}
                    <div style={{
                        color: 'var(--text-secondary)',
                        fontSize: '0.95rem',
                        textAlign: 'center',
                        maxWidth: '280px'
                    }}>
                        {message}
                    </div>
                    
                    {/* Barre de progression ind√©termin√©e */}
                    <div style={{
                        width: '200px',
                        height: '4px',
                        background: 'rgba(255,255,255,0.1)',
                        borderRadius: '2px',
                        marginTop: '16px',
                        overflow: 'hidden'
                    }}>
                        <div style={{
                            width: '40%',
                            height: '100%',
                            background: 'var(--accent-gold)',
                            borderRadius: '2px',
                            animation: 'loading-bar 1.5s ease-in-out infinite'
                        }}></div>
                    </div>
                </div>
            );
        };

        const Notification = ({ message, type }) => (
            <div className={`notification ${type}`}>{message}</div>
        );

        // ============== PAGES ==============

        const HomePage = () => {
            const { navigate, requireAuth, user } = useApp();
            
            return (
                <>
                    <Header />
                    <main className="main-content">
                        <div className="animate-fade-in" style={{ textAlign: 'center', marginBottom: '32px' }}>
                            <h1 style={{ fontSize: '2rem', marginBottom: '12px' }}>
                                Bienvenue sur <span style={{ color: 'var(--accent-gold)' }}>E-Cauri</span>
                            </h1>
                            <p style={{ color: 'var(--text-secondary)' }}>
                                Vos pronostics sportifs intelligents
                            </p>
                        </div>
                        
                        <div className="card card-clickable animate-fade-in delay-1" onClick={() => navigate('outils')}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                                <div style={{ background: 'var(--gradient-gold)', padding: '12px', borderRadius: '12px' }}>
                                    <Icons.Zap />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <h3>Predicator V1</h3>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.9rem' }}>
                                        Outil de pr√©diction IA
                                    </p>
                                </div>
                                <Icons.ArrowRight />
                            </div>
                        </div>

                        <div className="card card-clickable animate-fade-in delay-2" onClick={() => requireAuth('formations')}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                                <div style={{ background: 'var(--gradient-green)', padding: '12px', borderRadius: '12px', color: '#fff' }}>
                                    <Icons.Book />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <h3>Formations</h3>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.9rem' }}>
                                        Deviens un parieur pro
                                    </p>
                                </div>
                                {!user && <Icons.Lock />}
                                <Icons.ArrowRight />
                            </div>
                        </div>

                        <div className="card card-clickable animate-fade-in delay-3" onClick={() => navigate('capital')}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                                <div style={{ background: 'linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%)', padding: '12px', borderRadius: '12px', color: '#fff' }}>
                                    <Icons.TrendingUp />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <h3>Suivi Capital</h3>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.9rem' }}>
                                        √âvolution de vos gains
                                    </p>
                                </div>
                                <Icons.ArrowRight />
                            </div>
                        </div>
                    </main>
                    <BottomNav />
                </>
            );
        };

        const LoginPage = () => {
            const { login, goBack, loading, navigate, showNotification } = useApp();
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');

            const handleSubmit = async (e) => {
                e.preventDefault();
                await login(email, password);
            };

            return (
                <>
                    <Header showBack={true} title="Connexion" />
                    <main className="main-content">
                        <div className="animate-fade-in" style={{ textAlign: 'center', marginBottom: '32px' }}>
                            <div className="logo" style={{ fontSize: '2.5rem', marginBottom: '8px' }}>E-Cauri</div>
                            <p style={{ color: 'var(--text-secondary)' }}>
                                Connectez-vous pour continuer
                            </p>
                        </div>

                        <form onSubmit={handleSubmit}>
                            <div className="input-group animate-fade-in delay-1">
                                <label className="input-label">Email</label>
                                <input 
                                    type="email" 
                                    className="input" 
                                    placeholder="votre@email.com"
                                    value={email}
                                    onChange={(e) => setEmail(e.target.value)}
                                    required
                                />
                            </div>

                            <div className="input-group animate-fade-in delay-2">
                                <label className="input-label">Mot de passe</label>
                                <input 
                                    type="password" 
                                    className="input" 
                                    placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    required
                                    minLength={6}
                                />
                            </div>

                            <button 
                                type="submit" 
                                className="btn btn-primary animate-fade-in delay-3" 
                                style={{ width: '100%' }}
                                disabled={loading}
                            >
                                {loading ? 'Connexion...' : 'Se connecter'}
                            </button>
                        </form>

                        <div className="animate-fade-in delay-3" style={{ 
                            textAlign: 'center', 
                            marginTop: '24px',
                            padding: '16px',
                            borderTop: '1px solid var(--border-color)'
                        }}>
                            <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>
                                Pas encore de compte ? Contactez l'administrateur pour en cr√©er un.
                            </p>
                        </div>

                        {!firebaseAuth && (
                            <div className="animate-fade-in delay-3" style={{
                                marginTop: '24px',
                                padding: '12px',
                                background: 'rgba(251, 191, 36, 0.1)',
                                borderRadius: '8px',
                                border: '1px solid rgba(251, 191, 36, 0.3)'
                            }}>
                                <p style={{ color: 'var(--accent-gold)', fontSize: '0.85rem', textAlign: 'center' }}>
                                    ‚ö†Ô∏è Mode d√©mo - Firebase non configur√©
                                </p>
                            </div>
                        )}
                    </main>
                </>
            );
        };

        const OutilsPage = () => {
            const { navigate } = useApp();

            return (
                <>
                    <Header showBack={true} title="Outils" />
                    <main className="main-content">
                        <h2 className="section-title animate-fade-in">Outils disponibles</h2>
                        
                        <div className="card card-clickable animate-fade-in delay-1" onClick={() => navigate('matchs')}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                                <div style={{ background: 'var(--gradient-gold)', padding: '16px', borderRadius: '12px' }}>
                                    <Icons.Target />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <h3>PREDICATOR V1</h3>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.9rem' }}>
                                        Analyse IA des matchs avec recommandations de paris
                                    </p>
                                </div>
                                <Icons.ArrowRight />
                            </div>
                        </div>

                        <p className="section-subtitle animate-fade-in delay-2" style={{ marginTop: '24px' }}>
                            D'autres outils arrivent bient√¥t...
                        </p>
                    </main>
                    <BottomNav />
                </>
            );
        };

        const MatchsPage = () => {
            const { matches, fetchOpportunities, setSelectedMatch, navigate, loading } = useApp();

            useEffect(() => {
                fetchOpportunities();
            }, []);

            const handleSelectMatch = (match) => {
                setSelectedMatch(match);
                navigate('balance-input');
            };

            const formatDate = (dateStr, formattedDate) => {
                // Utiliser la date format√©e si disponible
                if (formattedDate) return formattedDate;
                
                const date = new Date(dateStr);
                return date.toLocaleDateString('fr-FR', { 
                    weekday: 'short', 
                    day: 'numeric', 
                    month: 'short',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            };

            return (
                <>
                    <Header showBack={true} title="Matchs √† venir" />
                    <main className="main-content">
                        <h2 className="section-title animate-fade-in">S√©lectionnez un match</h2>
                        <p className="section-subtitle animate-fade-in" style={{ marginBottom: '16px' }}>
                            {matches.length} match{matches.length > 1 ? 's' : ''} disponible{matches.length > 1 ? 's' : ''}
                        </p>
                        
                        {loading ? (
                            <div className="loading-spinner"></div>
                        ) : matches.length === 0 ? (
                            <div className="empty-state">
                                <Icons.AlertCircle />
                                <p>Aucun match disponible pour le moment</p>
                                <button className="btn btn-secondary" onClick={fetchOpportunities} style={{ marginTop: '16px' }}>
                                    Actualiser
                                </button>
                            </div>
                        ) : (
                            matches.map((match, index) => (
                                <div 
                                    key={match.id} 
                                    className={`card card-clickable animate-fade-in delay-${Math.min(index + 1, 5)}`}
                                    onClick={() => handleSelectMatch(match)}
                                >
                                    <div className="match-card">
                                        <div className="match-teams">
                                            <div className="team-row">
                                                {match.homeTeamLogo ? (
                                                    <img 
                                                        src={match.homeTeamLogo} 
                                                        alt={match.homeTeam}
                                                        className="team-logo"
                                                        style={{ width: '32px', height: '32px', objectFit: 'contain', background: 'white', borderRadius: '4px', padding: '2px' }}
                                                        onError={(e) => { e.target.style.display = 'none'; }}
                                                    />
                                                ) : (
                                                    <div className="team-logo" style={{ background: 'var(--bg-secondary)', width: '32px', height: '32px', borderRadius: '4px' }}></div>
                                                )}
                                                <span className="team-name">{match.homeTeam}</span>
                                                <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginLeft: 'auto' }}>DOM</span>
                                            </div>
                                            <div className="team-row">
                                                {match.awayTeamLogo ? (
                                                    <img 
                                                        src={match.awayTeamLogo} 
                                                        alt={match.awayTeam}
                                                        className="team-logo"
                                                        style={{ width: '32px', height: '32px', objectFit: 'contain', background: 'white', borderRadius: '4px', padding: '2px' }}
                                                        onError={(e) => { e.target.style.display = 'none'; }}
                                                    />
                                                ) : (
                                                    <div className="team-logo" style={{ background: 'var(--bg-secondary)', width: '32px', height: '32px', borderRadius: '4px' }}></div>
                                                )}
                                                <span className="team-name">{match.awayTeam}</span>
                                                <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginLeft: 'auto' }}>EXT</span>
                                            </div>
                                            <div className="match-meta" style={{ display: 'flex', flexDirection: 'column', gap: '4px', marginTop: '8px' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                    {match.leagueLogo && (
                                                        <img src={match.leagueLogo} alt="" style={{ width: '16px', height: '16px' }} />
                                                    )}
                                                    <span>{match.league}</span>
                                                    {match.round && <span style={{ color: 'var(--text-muted)' }}>‚Ä¢ {match.round}</span>}
                                                </div>
                                                <div style={{ color: 'var(--accent-gold)' }}>
                                                    üìÖ {formatDate(match.matchDate, match.matchDateFormatted)}
                                                    {match.matchTime && ` √† ${match.matchTime}`}
                                                </div>
                                                {match.venue && (
                                                    <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>
                                                        üèüÔ∏è {match.venue}{match.city && `, ${match.city}`}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                        <div className="match-arrow">
                                            <Icons.ArrowRight />
                                        </div>
                                    </div>
                                </div>
                            ))
                        )}
                    </main>
                    <BottomNav />
                </>
            );
        };

        const BalanceInputPage = () => {
            const { selectedMatch, analyzePrediction, loading, user, requireAuth, showNotification, analysisLock, isAnalysisInProgress, navigate } = useApp();
            const [balance, setBalance] = useState('');
            const [bookmaker, setBookmaker] = useState('1xbet');
            const [bookmakers, setBookmakers] = useState({ popular: [], available: [] });
            const [loadingBookmakers, setLoadingBookmakers] = useState(true);
            const [stakePercentage, setStakePercentage] = useState(6); // Pourcentage de mise par d√©faut
            
            // V√©rifier si une analyse est d√©j√† en cours
            const analysisInProgress = isAnalysisInProgress && isAnalysisInProgress();

            // Charger les bookmakers disponibles pour ce match
            useEffect(() => {
                const fetchBookmakers = async () => {
                    setLoadingBookmakers(true);
                    try {
                        // Charger les bookmakers sp√©cifiques au match si disponible
                        if (selectedMatch?.id) {
                            const response = await fetch(`${API_BASE_URL}/opportunities/${selectedMatch.id}/bookmakers`);
                            if (response.ok) {
                                const data = await response.json();
                                setBookmakers({
                                    available: data.available || [],
                                    popular: data.popular || []
                                });
                                // S√©lectionner le premier bookmaker disponible par d√©faut
                                if (data.available?.length > 0) {
                                    setBookmaker(data.available[0].key);
                                }
                                setLoadingBookmakers(false);
                                return;
                            }
                        }
                        
                        // Fallback: charger la liste g√©n√©rale
                        const response = await fetch(`${API_BASE_URL}/bookmakers`);
                        if (response.ok) {
                            const data = await response.json();
                            setBookmakers({
                                available: [],
                                popular: data.popular || []
                            });
                        }
                    } catch (error) {
                        console.error('Error fetching bookmakers:', error);
                        // Liste par d√©faut en cas d'erreur
                        setBookmakers({
                            available: [],
                            popular: [
                                { key: '1xbet', name: '1xBet', popular: true },
                                { key: 'betway', name: 'Betway', popular: true },
                                { key: '22bet', name: '22bet', popular: true },
                                { key: 'melbet', name: 'Melbet', popular: true },
                                { key: 'bet365', name: 'Bet365', popular: true },
                                { key: 'sportybet', name: 'SportyBet', popular: true },
                                { key: 'betwinner', name: 'BetWinner', popular: true },
                                { key: '1win', name: '1win', popular: true }
                            ]
                        });
                    }
                    setLoadingBookmakers(false);
                };
                fetchBookmakers();
            }, [selectedMatch?.id]);

            const handleSubmit = async () => {
                if (!user) {
                    requireAuth('balance-input');
                    return;
                }
                if (!balance) {
                    showNotification("Veuillez entrer votre solde", "error");
                    return;
                }
                if (selectedMatch) {
                    await analyzePrediction(selectedMatch.id, parseInt(balance), bookmaker, stakePercentage);
                }
            };

            // Grouper les bookmakers pour l'affichage
            const getBookmakerOptions = () => {
                const options = [];
                
                // D'abord les bookmakers avec cotes disponibles pour ce match
                if (bookmakers.available?.length > 0) {
                    options.push({ label: 'üìä Cotes disponibles pour ce match', options: bookmakers.available });
                }
                
                // Ensuite les bookmakers populaires en Afrique
                if (bookmakers.popular?.length > 0) {
                    const popularNotAvailable = bookmakers.popular.filter(
                        p => !bookmakers.available?.some(a => a.key === p.key)
                    );
                    if (popularNotAvailable.length > 0) {
                        options.push({ label: '‚≠ê Bookmakers populaires', options: popularNotAvailable });
                    }
                }
                
                return options;
            };

            return (
                <>
                    <Header showBack={true} title="Votre capital" />
                    <main className="main-content">
                        {/* Avertissement si une analyse est d√©j√† en cours */}
                        {analysisInProgress && (
                            <div className="card animate-fade-in" style={{
                                background: 'rgba(245, 158, 11, 0.15)',
                                border: '1px solid rgba(245, 158, 11, 0.4)',
                                marginBottom: '16px'
                            }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                    <div className="spinner" style={{ width: '24px', height: '24px' }}></div>
                                    <div>
                                        <p style={{ fontWeight: '600', color: 'var(--accent-gold)', margin: '0 0 4px' }}>
                                            ‚ö†Ô∏è Analyse en cours
                                        </p>
                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem', margin: 0 }}>
                                            Une analyse est d√©j√† en cours. Veuillez patienter avant d'en lancer une nouvelle.
                                        </p>
                                    </div>
                                </div>
                                <button 
                                    className="btn btn-secondary" 
                                    style={{ width: '100%', marginTop: '12px' }}
                                    onClick={() => navigate('pronostics')}
                                >
                                    Voir les analyses en cours
                                </button>
                            </div>
                        )}
                        
                        {selectedMatch && (
                            <div className="card animate-fade-in">
                                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                    {selectedMatch.homeTeamLogo && (
                                        <img src={selectedMatch.homeTeamLogo} alt="" style={{ width: '32px', height: '32px' }} />
                                    )}
                                    <div style={{ flex: 1 }}>
                                        <h3 style={{ marginBottom: '4px' }}>
                                            {selectedMatch.homeTeam} vs {selectedMatch.awayTeam}
                                        </h3>
                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>
                                            {selectedMatch.league} ‚Ä¢ {selectedMatch.matchDateFormatted || 'Date √† confirmer'}
                                        </p>
                                    </div>
                                    {selectedMatch.awayTeamLogo && (
                                        <img src={selectedMatch.awayTeamLogo} alt="" style={{ width: '32px', height: '32px' }} />
                                    )}
                                </div>
                            </div>
                        )}

                        <div className="input-group animate-fade-in delay-1">
                            <label className="input-label">Quel est votre solde actuel ?</label>
                            <input
                                type="number"
                                className="input"
                                placeholder="Ex: 50000"
                                value={balance}
                                onChange={(e) => setBalance(e.target.value)}
                                style={{ fontFamily: 'Space Mono, monospace', fontSize: '1.5rem', textAlign: 'center' }}
                            />
                            <span style={{ display: 'block', textAlign: 'center', color: 'var(--text-muted)', marginTop: '8px' }}>FCFA</span>
                        </div>

                        <div className="input-group animate-fade-in delay-2">
                            <label className="input-label">
                                Votre bookmaker
                                {bookmakers.available?.length > 0 && (
                                    <span style={{ 
                                        marginLeft: '8px', 
                                        fontSize: '0.75rem', 
                                        background: 'var(--accent-green)', 
                                        padding: '2px 8px', 
                                        borderRadius: '10px',
                                        color: 'white'
                                    }}>
                                        {bookmakers.available.length} avec cotes
                                    </span>
                                )}
                            </label>
                            
                            {loadingBookmakers ? (
                                <div className="input" style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '16px' }}>
                                    <span style={{ color: 'var(--text-muted)' }}>Chargement des bookmakers...</span>
                                </div>
                            ) : (
                                <select 
                                    className="input"
                                    value={bookmaker}
                                    onChange={(e) => setBookmaker(e.target.value)}
                                    style={{ padding: '12px 16px' }}
                                >
                                    {getBookmakerOptions().map((group, groupIndex) => (
                                        <optgroup key={groupIndex} label={group.label}>
                                            {group.options.map((bm) => (
                                                <option key={bm.key} value={bm.key}>
                                                    {bm.name} {bm.optionsCount ? `(${bm.optionsCount} cotes)` : ''}
                                                </option>
                                            ))}
                                        </optgroup>
                                    ))}
                                    
                                    {/* Si aucun groupe, afficher une liste simple */}
                                    {getBookmakerOptions().length === 0 && (
                                        <>
                                            <option value="1xbet">1xBet</option>
                                            <option value="betway">Betway</option>
                                            <option value="22bet">22bet</option>
                                            <option value="bet365">Bet365</option>
                                            <option value="sportybet">SportyBet</option>
                                            <option value="melbet">Melbet</option>
                                        </>
                                    )}
                                </select>
                            )}
                            
                            <p style={{ 
                                color: 'var(--text-muted)', 
                                fontSize: '0.8rem', 
                                marginTop: '8px',
                                textAlign: 'center'
                            }}>
                                Les cotes du bookmaker s√©lectionn√© seront utilis√©es pour l'analyse
                            </p>
                        </div>

                        {/* S√©lecteur de pourcentage de mise */}
                        <div className="input-group animate-fade-in delay-2">
                            <label className="input-label">
                                Pourcentage du capital √† risquer
                                <span style={{ 
                                    marginLeft: '8px', 
                                    fontSize: '0.75rem', 
                                    background: stakePercentage <= 5 ? 'var(--accent-green)' : stakePercentage <= 8 ? 'var(--accent-gold)' : 'var(--accent-red)', 
                                    padding: '2px 8px', 
                                    borderRadius: '10px',
                                    color: 'white'
                                }}>
                                    {stakePercentage <= 5 ? 'üõ°Ô∏è Prudent' : stakePercentage <= 8 ? '‚öñÔ∏è Mod√©r√©' : 'üî• Agressif'}
                                </span>
                            </label>
                            
                            <div style={{ 
                                display: 'grid', 
                                gridTemplateColumns: 'repeat(5, 1fr)', 
                                gap: '8px',
                                marginTop: '8px'
                            }}>
                                {[3, 5, 6, 8, 10].map(pct => (
                                    <button
                                        key={pct}
                                        type="button"
                                        onClick={() => setStakePercentage(pct)}
                                        style={{
                                            padding: '12px 8px',
                                            borderRadius: '10px',
                                            border: stakePercentage === pct ? '2px solid var(--accent-gold)' : '1px solid var(--border-color)',
                                            background: stakePercentage === pct ? 'rgba(245, 158, 11, 0.2)' : 'var(--bg-card)',
                                            color: stakePercentage === pct ? 'var(--accent-gold)' : 'var(--text-secondary)',
                                            fontWeight: stakePercentage === pct ? '700' : '500',
                                            cursor: 'pointer',
                                            fontSize: '1rem',
                                            fontFamily: 'Space Mono, monospace',
                                            transition: 'all 0.2s'
                                        }}
                                    >
                                        {pct}%
                                    </button>
                                ))}
                            </div>
                            
                            <div style={{ 
                                display: 'flex', 
                                justifyContent: 'space-between',
                                marginTop: '12px',
                                padding: '10px 12px',
                                background: 'rgba(0,0,0,0.2)',
                                borderRadius: '8px'
                            }}>
                                <span style={{ fontSize: '0.85rem', color: 'var(--text-muted)' }}>
                                    Budget max avec {stakePercentage}%:
                                </span>
                                <span style={{ 
                                    fontSize: '1rem', 
                                    fontWeight: '700', 
                                    color: 'var(--accent-gold)',
                                    fontFamily: 'Space Mono, monospace'
                                }}>
                                    {balance ? Math.round(parseInt(balance) * stakePercentage / 100).toLocaleString() : '0'} FCFA
                                </span>
                            </div>
                            
                            <p style={{ 
                                color: 'var(--text-muted)', 
                                fontSize: '0.75rem', 
                                marginTop: '8px',
                                textAlign: 'center'
                            }}>
                                üí° Kelly recommande 3-6% pour limiter le risque de ruine
                            </p>
                        </div>

                        {/* Info sur les moteurs IA */}
                        <div className="animate-fade-in delay-2" style={{
                            background: 'rgba(59, 130, 246, 0.1)',
                            border: '1px solid rgba(59, 130, 246, 0.3)',
                            borderRadius: '12px',
                            padding: '16px',
                            marginTop: '16px'
                        }}>
                            <p style={{ color: 'var(--accent-blue)', fontSize: '0.85rem', marginBottom: '8px', fontWeight: '600' }}>
                                üß† Analyse IA avanc√©e
                            </p>
                            <p style={{ color: 'var(--text-secondary)', fontSize: '0.8rem', lineHeight: '1.5' }}>
                                ‚Ä¢ <strong>Claude</strong> (Extended Thinking) - Analyse approfondie<br/>
                                ‚Ä¢ <strong>DeepSeek</strong> (Reasoner) - Validation crois√©e<br/>
                                ‚Ä¢ Calcul des mises optimales (Crit√®re de Kelly)
                            </p>
                        </div>

                        <button 
                            className="btn btn-primary animate-fade-in delay-3" 
                            style={{ width: '100%', marginTop: '24px', opacity: analysisInProgress ? 0.5 : 1 }}
                            onClick={handleSubmit}
                            disabled={!balance || loading || loadingBookmakers || analysisInProgress}
                        >
                            {loading ? 'üîÆ Analyse en cours...' : analysisInProgress ? '‚è≥ Analyse d√©j√† en cours...' : 'Analyser le match'}
                            {!loading && !analysisInProgress && <Icons.Zap />}
                        </button>
                        
                        {balance && parseInt(balance) > 0 && (
                            <p className="animate-fade-in" style={{ 
                                textAlign: 'center', 
                                color: 'var(--text-muted)', 
                                fontSize: '0.85rem',
                                marginTop: '12px'
                            }}>
                                Budget max recommand√©: <strong style={{ color: 'var(--accent-gold)' }}>
                                    {Math.round(parseInt(balance) * stakePercentage / 100).toLocaleString()} FCFA
                                </strong> ({stakePercentage}% du capital)
                            </p>
                        )}
                    </main>
                    <BottomNav />
                    {loading && <LoadingOverlay text="üß† Analyse IA avec Claude & DeepSeek..." />}
                </>
            );
        };

        const StrategyPage = () => {
            const { currentPrediction, selectedMatch, userBalance, selectedOptions, setSelectedOptions, navigate, showNotification, activePredictions, setActivePredictions, API_BASE_URL, apiCallWithAuth } = useApp();

            // √âtat pour les sections "Pourquoi" d√©pliables
            const [expandedReasons, setExpandedReasons] = useState({});
            
            // Toggle une section "Pourquoi"
            const toggleReason = (optionName, e) => {
                e.stopPropagation(); // √âviter de s√©lectionner l'option
                setExpandedReasons(prev => ({
                    ...prev,
                    [optionName]: !prev[optionName]
                }));
            };
            
            // ========== NOUVEAU WORKFLOW: CAPITAL ALLOU√â ==========
            // Phase 1: Pourcentage choisi par l'utilisateur (ex: 5%)
            const stakePercentage = currentPrediction?.stakePercentage || 6;
            
            // Phase 2: Capital allou√© = Pourcentage √ó Capital total
            const allocatedCapital = Math.round(userBalance * stakePercentage / 100);
            
            console.log(`üí∞ Capital allou√©: ${stakePercentage}% de ${userBalance} = ${allocatedCapital} FCFA`);
            
            // Calculer l'Edge: (Probabilit√© estim√©e √ó Cote) - 1
            const calculateEdge = (probability, odds) => {
                if (!probability || !odds) return 0;
                const edge = (probability * odds - 1) * 100;
                return Math.round(edge * 10) / 10;
            };
            
            // Obtenir la cat√©gorie et couleur de l'Edge
            const getEdgeCategory = (edge) => {
                if (edge > 15) {
                    return { label: '‚úÖ Excellent', color: '#10b981', bg: 'rgba(16, 185, 129, 0.2)', description: 'Fort d√©s√©quilibre valeur/risque' };
                } else if (edge >= 5) {
                    return { label: '‚ö†Ô∏è Moyen', color: '#f59e0b', bg: 'rgba(245, 158, 11, 0.2)', description: 'Opportunit√© int√©ressante' };
                } else if (edge > 0) {
                    return { label: 'üî¥ Faible', color: '#ef4444', bg: 'rgba(239, 68, 68, 0.2)', description: 'Pari risqu√©' };
                } else {
                    return { label: '‚õî N√©gatif', color: '#dc2626', bg: 'rgba(220, 38, 38, 0.3)', description: 'Value n√©gative - d√©conseill√©' };
                }
            };
            
            // ========== CALCUL KELLY AVEC CAPITAL ALLOU√â ==========
            // Calcule la mise Kelly pour une option en utilisant le capital ALLOU√â (pas le total)
            const calculateKellyStake = (probability, odds, capital) => {
                if (!probability || !odds || !capital) return { stake: 0, kellyPercentage: 0, kellyRaw: 0 };
                
                const b = odds - 1; // Gain net par unit√© mis√©e
                const p = probability;
                const q = 1 - p;
                
                // Formule Kelly: f* = (bp - q) / b
                let kellyFraction = Math.max(0, (b * p - q) / b);
                
                // Kelly brut (avant limitation) pour l'affichage
                const kellyRaw = Math.round(kellyFraction * 100 * 10) / 10;
                
                // Limiter √† 100% du capital allou√© max
                kellyFraction = Math.min(kellyFraction, 1);
                
                const stake = Math.round(capital * kellyFraction);
                const kellyPercentage = Math.round(kellyFraction * 100 * 10) / 10;
                
                return { 
                    stake: stake || Math.round(capital / 3), // Fallback: 1/3 du capital allou√©
                    kellyPercentage,
                    kellyRaw 
                };
            };
            
            // ========== RECALCUL DYNAMIQUE DES MISES ==========
            // Recalcule les mises pour toutes les options s√©lectionn√©es
            // R√©partit le capital allou√© proportionnellement selon Kelly
            const recalculateStakes = (options) => {
                if (options.length === 0) return [];
                
                // 1. Calculer le Kelly brut pour chaque option
                const optionsWithKelly = options.map(opt => {
                    const prob = opt.probability || opt.estimatedProbability || 0.5;
                    const odds = opt.odds || 1.5;
                    const { kellyRaw } = calculateKellyStake(prob, odds, allocatedCapital);
                    return { ...opt, kellyRaw, probability: prob, odds };
                });
                
                // 2. Calculer la somme des Kelly pour normaliser
                const totalKelly = optionsWithKelly.reduce((sum, opt) => sum + Math.max(opt.kellyRaw, 1), 0);
                
                // 3. R√©partir le capital allou√© proportionnellement
                return optionsWithKelly.map(opt => {
                    const kellyWeight = Math.max(opt.kellyRaw, 1) / totalKelly;
                    const stake = Math.round(allocatedCapital * kellyWeight);
                    
                    return {
                        ...opt,
                        stake,
                        adjustedStake: stake,
                        potentialReturn: Math.round(stake * opt.odds),
                        kellyPercentage: Math.round(kellyWeight * 100 * 10) / 10
                    };
                });
            };

            // V√©rifier si les options ont d√©j√† √©t√© valid√©es (mode lecture seule)
            const alreadyValidated = currentPrediction?.selectedOptions && currentPrediction.selectedOptions.length > 0;
            const isReadOnly = alreadyValidated || currentPrediction?.status === 'active' || currentPrediction?.status === 'won' || currentPrediction?.status === 'lost';

            // Charger les options existantes si elles existent
            useEffect(() => {
                if (currentPrediction?.selectedOptions?.length > 0 && selectedOptions.length === 0) {
                    console.log('üìã Loading existing selected options:', currentPrediction.selectedOptions);
                    setSelectedOptions(currentPrediction.selectedOptions);
                }
            }, [currentPrediction?.id]);
            
            // ========== RECALCUL AUTOMATIQUE QUAND S√âLECTION CHANGE ==========
            // Recalculer les mises √† chaque changement de s√©lection
            const [calculatedOptions, setCalculatedOptions] = useState([]);
            
            useEffect(() => {
                if (selectedOptions.length > 0 && !isReadOnly) {
                    const recalculated = recalculateStakes(selectedOptions);
                    setCalculatedOptions(recalculated);
                    console.log(`üìä Mises recalcul√©es pour ${recalculated.length} options:`, 
                        recalculated.map(o => `${o.option}: ${o.stake} FCFA (${o.kellyPercentage}%)`));
                } else {
                    setCalculatedOptions([]);
                }
            }, [selectedOptions, allocatedCapital]);

            // R√©cup√©rer les stakes pour fusionner avec les options
            const stakes = currentPrediction?.stakes;

            // ========== TOGGLE OPTION SIMPLIFI√â ==========
            const toggleOption = (option) => {
                // Bloquer si en mode lecture seule
                if (isReadOnly) {
                    showNotification("Les options ont d√©j√† √©t√© valid√©es et ne peuvent plus √™tre modifi√©es", "warning");
                    return;
                }

                const prob = option.estimatedProbability || option.probability || 0.5;
                const odds = option.odds || 1.5;
                
                // Cr√©er l'option avec les infos de base (les mises seront calcul√©es par recalculateStakes)
                const optionData = {
                    option: option.option,
                    odds: odds,
                    probability: prob,
                    stake: 0, // Sera calcul√©
                    adjustedStake: 0,
                    potentialReturn: 0,
                    kellyPercentage: 0
                };

                console.log('üîÑ Toggle option:', option.option);

                setSelectedOptions(prev => {
                    const exists = prev.find(o => o.option === option.option);
                    if (exists) {
                        // D√©s√©lectionner
                        return prev.filter(o => o.option !== option.option);
                    } else {
                        // S√©lectionner
                        return [...prev, optionData];
                    }
                });
            };

            const isSelected = (option) => {
                // En mode lecture seule, utiliser les options d√©j√† valid√©es
                if (isReadOnly && currentPrediction?.selectedOptions) {
                    return currentPrediction.selectedOptions.some(o => o.option === option.option);
                }
                return selectedOptions.some(o => o.option === option.option);
            };

            const handleValidate = async () => {
                if (isReadOnly) {
                    showNotification("Les options ont d√©j√† √©t√© valid√©es", "info");
                    navigate('pronostics');
                    return;
                }

                if (selectedOptions.length === 0) {
                    showNotification("S√©lectionnez au moins une option", "error");
                    return;
                }
                
                // Utiliser les options avec mises calcul√©es dynamiquement
                const optionsWithStakes = calculatedOptions.length > 0 ? calculatedOptions : recalculateStakes(selectedOptions);
                
                const totalStake = optionsWithStakes.reduce((sum, o) => sum + (o.stake || 0), 0);
                console.log(`üì§ Validating ${optionsWithStakes.length} options, total: ${totalStake} FCFA sur ${allocatedCapital} FCFA allou√©s`);
                
                // Sauvegarder sur Firebase
                if (currentPrediction?.id) {
                    try {
                        // Envoyer les donn√©es compl√®tes de la pr√©diction pour le cas o√π le document n'existe pas
                        const predictionData = {
                            matchInfo: currentPrediction.matchInfo,
                            userBalance: currentPrediction.userBalance,
                            stakePercentage: stakePercentage,
                            allocatedCapital: allocatedCapital,
                            bookmaker: currentPrediction.bookmaker,
                            aiAnalysis: currentPrediction.aiAnalysis,
                            oddsAnalysis: currentPrediction.oddsAnalysis,
                            synthesis: currentPrediction.synthesis,
                            stakes: null, // Calcul√©es au frontend
                            opportunityId: currentPrediction.opportunityId || currentPrediction.matchId
                        };
                        
                        const response = await apiCallWithAuth(
                            `${API_BASE_URL}/predictions/${currentPrediction.id}/validate`,
                            {
                                method: 'POST',
                                body: JSON.stringify({ 
                                    selectedOptions: optionsWithStakes,
                                    predictionData  // Donn√©es compl√®tes pour cr√©er le doc si n√©cessaire
                                })
                            }
                        );
                        
                        if (response.ok) {
                            console.log('‚úÖ Options validated and saved to Firebase');
                        } else {
                            console.warn('‚ö†Ô∏è Could not save to Firebase:', await response.text());
                        }
                    } catch (error) {
                        console.warn('Could not save to Firebase:', error);
                    }
                }

                // Mettre √† jour le statut du pronostic actif localement
                if (currentPrediction) {
                    setActivePredictions(prev => prev.map(p => 
                        p.id === currentPrediction.id 
                            ? { ...p, status: 'active', selectedOptions: optionsWithStakes, validatedAt: new Date().toISOString() }
                            : p
                    ));
                }
                
                showNotification("Options valid√©es ! Pr√™t pour le suivi live", "success");
                navigate('pronostics');
            };

            if (!currentPrediction) {
                return (
                    <>
                        <Header showBack={true} title="Strat√©gie" />
                        <main className="main-content">
                            <div className="empty-state">
                                <Icons.AlertCircle />
                                <p>Aucune analyse disponible</p>
                                <button 
                                    className="btn btn-primary" 
                                    style={{ marginTop: '16px' }}
                                    onClick={() => navigate('home')}
                                >
                                    S√©lectionner un match
                                </button>
                            </div>
                        </main>
                        <BottomNav />
                    </>
                );
            }

            // Adapter aux diff√©rentes structures possibles 
            // Backend sauvegarde matchAnalysis sous aiAnalysis
            const getAnalysisData = () => {
                // Essayer plusieurs chemins possibles
                const paths = [
                    currentPrediction.matchAnalysis?.claude,
                    currentPrediction.aiAnalysis?.claude,
                    currentPrediction.matchAnalysis?.deepseek,
                    currentPrediction.aiAnalysis?.deepseek,
                    currentPrediction.aiAnalysis, // Si aiAnalysis EST directement l'objet claude
                    currentPrediction.matchAnalysis
                ];
                
                for (const path of paths) {
                    if (path && (path.winner || path.btts || path.totalGoals)) {
                        console.log('üìä Found valid analysis data');
                        return path;
                    }
                }
                
                console.log('‚ö†Ô∏è No valid analysis data found in:', {
                    matchAnalysisKeys: currentPrediction.matchAnalysis ? Object.keys(currentPrediction.matchAnalysis) : 'null',
                    aiAnalysisKeys: currentPrediction.aiAnalysis ? Object.keys(currentPrediction.aiAnalysis) : 'null'
                });
                return null;
            };
            
            const analysis = getAnalysisData();
            const deepseekAnalysis = currentPrediction.matchAnalysis?.deepseek || currentPrediction.aiAnalysis?.deepseek;
            
            // Chercher les options dans plusieurs sources possibles
            const getRecommendedOptions = () => {
                console.log('üîç Looking for options in currentPrediction:', {
                    hasOddsAnalysis: !!currentPrediction.oddsAnalysis,
                    hasRecommendedOptions: !!currentPrediction.oddsAnalysis?.recommendedOptions,
                    recommendedOptionsLength: currentPrediction.oddsAnalysis?.recommendedOptions?.length,
                    hasRawResponse: !!currentPrediction.oddsAnalysis?.rawResponse,
                    hasAiAnalysis: !!currentPrediction.aiAnalysis,
                    hasMatchAnalysis: !!currentPrediction.matchAnalysis,
                    analysisKeys: analysis ? Object.keys(analysis) : 'null'
                });
                
                // 1. oddsAnalysis.recommendedOptions (source principale)
                if (currentPrediction.oddsAnalysis?.recommendedOptions?.length > 0) {
                    console.log('üìã Options from oddsAnalysis.recommendedOptions');
                    return currentPrediction.oddsAnalysis.recommendedOptions;
                }
                
                // 1.5 Essayer de parser rawResponse si present dans oddsAnalysis
                if (currentPrediction.oddsAnalysis?.rawResponse) {
                    console.log('üìã Trying to parse rawResponse from oddsAnalysis');
                    try {
                        const raw = currentPrediction.oddsAnalysis.rawResponse;
                        // Nettoyer et parser
                        const cleanJson = raw.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                        const parsed = JSON.parse(cleanJson);
                        if (parsed.recommendedOptions?.length > 0) {
                            console.log('üìã Successfully parsed recommendedOptions from rawResponse');
                            return parsed.recommendedOptions;
                        }
                    } catch (e) {
                        console.log('‚ö†Ô∏è Failed to parse rawResponse:', e.message);
                    }
                }
                
                // 2. Chercher dans synthesis si elle contient des options
                if (currentPrediction.synthesis?.recommendedOptions?.length > 0) {
                    console.log('üìã Options from synthesis.recommendedOptions');
                    return currentPrediction.synthesis.recommendedOptions;
                }
                
                // 3. G√©n√©rer des options bas√©es sur l'analyse IA
                const homeTeam = currentPrediction.matchInfo?.homeTeam || currentPrediction.meta?.homeTeam || '√âquipe Domicile';
                const awayTeam = currentPrediction.matchInfo?.awayTeam || currentPrediction.meta?.awayTeam || '√âquipe Ext√©rieur';
                
                if (analysis) {
                    console.log('üìã Generating options from AI analysis, keys:', Object.keys(analysis));
                    const generatedOptions = [];
                    
                    // Option victoire domicile
                    const winProb = analysis.winner?.teamA?.probability || 
                                   analysis.winner?.home?.probability || 
                                   (analysis.winner?.prediction === 'teamA' ? 0.55 : 0);
                    if (winProb > 0.3) {
                        generatedOptions.push({
                            option: `Victoire ${homeTeam}`,
                            odds: winProb > 0 ? Math.round((1 / winProb) * 100) / 100 : 1.60,
                            estimatedProbability: winProb,
                            riskLevel: winProb > 0.6 ? 'low' : winProb > 0.4 ? 'medium' : 'high',
                            reasoning: analysis.winner?.teamA?.analysis || `Probabilit√©: ${Math.round(winProb * 100)}%`
                        });
                    }
                    
                    // Option victoire ext√©rieur
                    const awayProb = analysis.winner?.teamB?.probability || 
                                    analysis.winner?.away?.probability || 0;
                    if (awayProb > 0.3) {
                        generatedOptions.push({
                            option: `Victoire ${awayTeam}`,
                            odds: awayProb > 0 ? Math.round((1 / awayProb) * 100) / 100 : 2.20,
                            estimatedProbability: awayProb,
                            riskLevel: awayProb > 0.5 ? 'low' : 'medium',
                            reasoning: analysis.winner?.teamB?.analysis || `Probabilit√©: ${Math.round(awayProb * 100)}%`
                        });
                    }
                    
                    // Option match nul
                    const drawProb = analysis.winner?.draw?.probability || 0;
                    if (drawProb > 0.2) {
                        generatedOptions.push({
                            option: 'Match Nul',
                            odds: drawProb > 0 ? Math.round((1 / drawProb) * 100) / 100 : 3.20,
                            estimatedProbability: drawProb,
                            riskLevel: 'medium',
                            reasoning: analysis.winner?.draw?.analysis || `Probabilit√©: ${Math.round(drawProb * 100)}%`
                        });
                    }
                    
                    // Option BTTS
                    const bttsProb = analysis.btts?.probability || 0;
                    if (bttsProb > 0.4) {
                        generatedOptions.push({
                            option: 'BTTS Oui',
                            odds: bttsProb > 0 ? Math.round((1 / bttsProb) * 100) / 100 : 1.80,
                            estimatedProbability: bttsProb,
                            riskLevel: 'medium',
                            reasoning: analysis.btts?.analysis || `Les deux √©quipes marquent: ${Math.round(bttsProb * 100)}%`
                        });
                    }
                    
                    // Option Over 2.5
                    const over25Prob = analysis.totalGoals?.over25 || 0;
                    if (over25Prob > 0.4) {
                        generatedOptions.push({
                            option: 'Plus de 2.5 buts',
                            odds: over25Prob > 0 ? Math.round((1 / over25Prob) * 100) / 100 : 1.70,
                            estimatedProbability: over25Prob,
                            riskLevel: 'medium',
                            reasoning: analysis.totalGoals?.analysis || `Buts attendus: ${analysis.totalGoals?.expected || 'N/A'}`
                        });
                    }
                    
                    // Option Over 1.5 (plus s√ªr)
                    const over15Prob = analysis.totalGoals?.over15 || 0;
                    if (over15Prob > 0.6) {
                        generatedOptions.push({
                            option: 'Plus de 1.5 buts',
                            odds: over15Prob > 0 ? Math.round((1 / over15Prob) * 100) / 100 : 1.30,
                            estimatedProbability: over15Prob,
                            riskLevel: 'low',
                            reasoning: `Option s√ªre: ${Math.round(over15Prob * 100)}%`
                        });
                    }
                    
                    if (generatedOptions.length > 0) {
                        console.log(`üìã Generated ${generatedOptions.length} options from analysis`);
                        return generatedOptions;
                    }
                }
                
                // 4. FALLBACK FINAL: Options g√©n√©riques bas√©es sur les infos du match
                console.log('üìã Using FALLBACK generic options (no AI data found)');
                return [
                    {
                        option: `Victoire ${homeTeam}`,
                        odds: 1.75,
                        estimatedProbability: 0.50,
                        riskLevel: 'medium',
                        reasoning: '‚ö†Ô∏è Option par d√©faut - donn√©es IA non disponibles',
                        isFallback: true
                    },
                    {
                        option: 'Plus de 1.5 buts',
                        odds: 1.35,
                        estimatedProbability: 0.72,
                        riskLevel: 'low',
                        reasoning: '‚ö†Ô∏è Option s√ªre par d√©faut',
                        isFallback: true
                    },
                    {
                        option: 'BTTS Oui',
                        odds: 1.85,
                        estimatedProbability: 0.52,
                        riskLevel: 'medium',
                        reasoning: '‚ö†Ô∏è Option par d√©faut - donn√©es IA non disponibles',
                        isFallback: true
                    }
                ];
            };
            
            const options = getRecommendedOptions();
            console.log('üìä Final options:', options.length, options);
            
            // stakes d√©j√† d√©clar√© plus haut
            const synthesis = currentPrediction.synthesis;
            const bookmaker = currentPrediction.selectedBookmaker || currentPrediction.bookmaker;
            const meta = currentPrediction.meta || currentPrediction.matchInfo;

            // R√©cup√©rer les probabilit√©s (adapt√©es aux diff√©rentes structures)
            const bttsProb = analysis?.btts?.probability || 0;
            const over25Prob = analysis?.totalGoals?.over25 || 0;
            const winnerProb = analysis?.winner?.teamA?.probability || 0;

            return (
                <>
                    <Header showBack={true} title="R√©sum√© & Pronos" />
                    <main className="main-content">
                        {/* Info Match */}
                        {(selectedMatch || meta) && (
                            <div className="card animate-fade-in">
                                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                    <div style={{ flex: 1 }}>
                                        <h3 style={{ marginBottom: '4px' }}>
                                            {selectedMatch?.homeTeam || meta?.homeTeam} vs {selectedMatch?.awayTeam || meta?.awayTeam}
                                        </h3>
                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>
                                            {selectedMatch?.league || meta?.league}
                                            {bookmaker && ` ‚Ä¢ Cotes ${typeof bookmaker === 'object' ? bookmaker.name : bookmaker}`}
                                        </p>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Moteurs IA utilis√©s */}
                        <div className="animate-fade-in" style={{
                            display: 'flex',
                            gap: '8px',
                            marginBottom: '16px',
                            flexWrap: 'wrap'
                        }}>
                            <span style={{
                                background: 'rgba(139, 92, 246, 0.2)',
                                color: '#a78bfa',
                                padding: '4px 12px',
                                borderRadius: '20px',
                                fontSize: '0.75rem',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '4px'
                            }}>
                                üß† Claude {analysis?._thinking ? '‚úì' : ''}
                            </span>
                            <span style={{
                                background: 'rgba(59, 130, 246, 0.2)',
                                color: '#60a5fa',
                                padding: '4px 12px',
                                borderRadius: '20px',
                                fontSize: '0.75rem',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '4px'
                            }}>
                                üîÆ DeepSeek {deepseekAnalysis?._thinking ? '‚úì' : ''}
                            </span>
                        </div>

                        {/* Analyse IA */}
                        <div className="analysis-box animate-fade-in delay-1">
                            <div className="analysis-title">
                                <Icons.Zap />
                                Analyse IA
                            </div>
                            <div className="analysis-text">
                                {analysis?.btts?.analysis || analysis?.trend?.globalAnalysis || "L'analyse sugg√®re que ce match devrait √™tre disput√© avec plusieurs opportunit√©s."}
                            </div>
                            
                            {/* Probabilit√©s */}
                            <div style={{ marginTop: '16px', display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '12px' }}>
                                <div style={{ textAlign: 'center' }}>
                                    <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem', display: 'block' }}>Victoire Dom.</span>
                                    <div style={{ fontFamily: 'Space Mono', color: 'var(--accent-green)', fontSize: '1.2rem', fontWeight: 'bold' }}>
                                        {Math.round(winnerProb * 100)}%
                                    </div>
                                </div>
                                <div style={{ textAlign: 'center' }}>
                                    <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem', display: 'block' }}>BTTS</span>
                                    <div style={{ fontFamily: 'Space Mono', color: 'var(--accent-gold)', fontSize: '1.2rem', fontWeight: 'bold' }}>
                                        {Math.round(bttsProb * 100)}%
                                    </div>
                                </div>
                                <div style={{ textAlign: 'center' }}>
                                    <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem', display: 'block' }}>+2.5 buts</span>
                                    <div style={{ fontFamily: 'Space Mono', color: 'var(--accent-blue)', fontSize: '1.2rem', fontWeight: 'bold' }}>
                                        {Math.round(over25Prob * 100)}%
                                    </div>
                                </div>
                            </div>

                            {/* Enjeu du match */}
                            {analysis?.enjeu && (
                                <div style={{ marginTop: '16px', padding: '12px', background: 'rgba(255,255,255,0.03)', borderRadius: '8px' }}>
                                    <p style={{ fontSize: '0.8rem', color: 'var(--text-muted)', marginBottom: '8px' }}>üìä Enjeu du match</p>
                                    <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>
                                        <strong style={{ color: 'var(--accent-green)' }}>Dom:</strong> {analysis.enjeu.teamA?.description || 'N/A'}
                                    </p>
                                    <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginTop: '4px' }}>
                                        <strong style={{ color: 'var(--accent-red)' }}>Ext:</strong> {analysis.enjeu.teamB?.description || 'N/A'}
                                    </p>
                                </div>
                            )}
                        </div>

                        {/* Synth√®se des 2 IA */}
                        {synthesis && (
                            <div className="animate-fade-in delay-1" style={{
                                background: 'rgba(16, 185, 129, 0.1)',
                                border: '1px solid rgba(16, 185, 129, 0.3)',
                                borderRadius: '12px',
                                padding: '16px',
                                marginBottom: '16px'
                            }}>
                                <p style={{ color: 'var(--accent-green)', fontSize: '0.85rem', marginBottom: '8px', fontWeight: '600' }}>
                                    ü§ù Consensus des IA
                                </p>
                                <p style={{ color: 'var(--text-secondary)', fontSize: '0.85rem' }}>
                                    {synthesis.synthesis || synthesis.finalRecommendation}
                                </p>
                                {synthesis.consensusPoints?.length > 0 && (
                                    <div style={{ marginTop: '8px', display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                                        {synthesis.consensusPoints.slice(0, 3).map((point, i) => (
                                            <span key={i} style={{
                                                background: 'rgba(16, 185, 129, 0.2)',
                                                padding: '2px 8px',
                                                borderRadius: '10px',
                                                fontSize: '0.75rem',
                                                color: 'var(--accent-green-light)'
                                            }}>‚úì {point}</span>
                                        ))}
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Banni√®re mode lecture seule */}
                        {isReadOnly && (
                            <div className="animate-fade-in delay-2" style={{
                                background: 'rgba(59, 130, 246, 0.1)',
                                border: '1px solid rgba(59, 130, 246, 0.3)',
                                borderRadius: '12px',
                                padding: '12px 16px',
                                marginBottom: '16px',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '10px'
                            }}>
                                <span style={{ fontSize: '1.2rem' }}>üîí</span>
                                <div>
                                    <p style={{ color: 'var(--accent-blue)', fontSize: '0.85rem', margin: 0, fontWeight: '600' }}>
                                        Options valid√©es
                                    </p>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.75rem', margin: 0 }}>
                                        Les paris ont √©t√© enregistr√©s et ne peuvent plus √™tre modifi√©s
                                    </p>
                                </div>
                            </div>
                        )}

                        <h3 className="section-title animate-fade-in delay-2">
                            {isReadOnly ? 'Options s√©lectionn√©es ‚úì' : 'Options recommand√©es'}
                        </h3>
                        
                        {/* Bandeau Capital Allou√© */}
                        {!isReadOnly && (
                            <div style={{ 
                                background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(59, 130, 246, 0.15) 100%)',
                                border: '1px solid rgba(139, 92, 246, 0.3)',
                                borderRadius: '12px',
                                padding: '12px 16px',
                                marginBottom: '16px',
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center'
                            }}>
                                <div>
                                    <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>üí∞ Capital allou√© ({stakePercentage}%)</div>
                                    <div style={{ fontSize: '1.2rem', fontWeight: '700', color: 'var(--accent-purple)' }}>
                                        {allocatedCapital.toLocaleString()} FCFA
                                    </div>
                                </div>
                                <div style={{ textAlign: 'right' }}>
                                    <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>Sur capital total</div>
                                    <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
                                        {userBalance?.toLocaleString()} FCFA
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {!isReadOnly && options.length > 0 && (
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                <p className="section-subtitle" style={{ margin: 0 }}>
                                    S√©lectionnez vos paris ({selectedOptions.length} s√©lectionn√©{selectedOptions.length > 1 ? 's' : ''})
                                </p>
                                <button 
                                    className="btn btn-secondary"
                                    style={{ padding: '6px 12px', fontSize: '0.75rem' }}
                                    onClick={() => {
                                        // S√©lectionner toutes les options (les mises seront calcul√©es automatiquement)
                                        const allOptions = options.map(opt => ({
                                            option: opt.option,
                                            odds: opt.odds || 1.5,
                                            probability: opt.estimatedProbability || opt.probability || 0.5,
                                            stake: 0, // Calcul√© par recalculateStakes
                                            adjustedStake: 0,
                                            potentialReturn: 0,
                                            kellyPercentage: 0
                                        }));
                                        
                                        console.log(`üì§ All ${allOptions.length} options selected`);
                                        setSelectedOptions(allOptions);
                                        showNotification(`${allOptions.length} options s√©lectionn√©es`, "success");
                                    }}
                                >
                                    ‚úÖ Tout s√©lectionner
                                </button>
                            </div>
                        )}

                        {/* Message si aucune option */}
                        {options.length === 0 && !isReadOnly && (
                            <div style={{ 
                                padding: '20px', 
                                textAlign: 'center', 
                                background: 'rgba(239, 68, 68, 0.1)',
                                borderRadius: '12px',
                                marginBottom: '16px'
                            }}>
                                <Icons.AlertCircle style={{ color: 'var(--accent-red)', marginBottom: '8px' }} />
                                <p style={{ color: 'var(--accent-red)', margin: 0 }}>
                                    Aucune option recommand√©e disponible
                                </p>
                                <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem', marginTop: '8px' }}>
                                    L'analyse n'a pas pu g√©n√©rer d'options. Veuillez r√©essayer.
                                </p>
                            </div>
                        )}

                        {options.map((option, index) => {
                            const prob = option.estimatedProbability || option.probability || 0;
                            const value = option.value || (prob * option.odds);
                            const selected = isSelected(option);
                            
                            // R√©cup√©rer la mise calcul√©e dynamiquement si l'option est s√©lectionn√©e
                            const calcOption = calculatedOptions.find(o => o.option === option.option);
                            
                            // Calculer l'Edge
                            const edge = calculateEdge(prob, option.odds);
                            const edgeCategory = getEdgeCategory(edge);
                            
                            // Mise √† afficher: soit calcul√©e (si s√©lectionn√©e), soit estimation Kelly
                            const kellyResult = calculateKellyStake(prob, option.odds, allocatedCapital);
                            const displayStake = selected && calcOption ? calcOption.stake : kellyResult.stake;
                            const displayKelly = selected && calcOption ? calcOption.kellyPercentage : kellyResult.kellyPercentage;
                            
                            // Donn√©es pour la section "Pourquoi"
                            const factors = option.factors || option.keyFactors || [];
                            const stats = option.statistics || option.stats || [];
                            const conditions = option.conditions || [];
                            const isExpanded = expandedReasons[option.option];
                            
                            // En mode lecture seule, n'afficher que les options s√©lectionn√©es
                            if (isReadOnly && !selected) return null;
                            
                            return (
                                <div 
                                    key={option.option}
                                    className={`option-card animate-fade-in delay-${Math.min(index + 2, 5)} ${selected ? 'selected' : ''}`}
                                    onClick={() => toggleOption(option)}
                                    style={{ cursor: isReadOnly ? 'default' : 'pointer' }}
                                >
                                    {/* Header avec nom et cote */}
                                    <div className="option-header">
                                        <span className="option-name">{option.option}</span>
                                        <span className="option-odds">{option.odds?.toFixed(2) || 'N/A'}</span>
                                    </div>
                                    
                                    {/* Ligne Confiance IA et Edge */}
                                    <div style={{ 
                                        display: 'flex', 
                                        justifyContent: 'space-between', 
                                        alignItems: 'center',
                                        marginTop: '8px',
                                        marginBottom: '8px'
                                    }}>
                                        <div style={{ 
                                            padding: '4px 10px',
                                            borderRadius: '20px',
                                            background: 'rgba(139, 92, 246, 0.15)',
                                            border: '1px solid rgba(139, 92, 246, 0.3)'
                                        }}>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>ü§ñ Confiance IA </span>
                                            <strong style={{ color: 'var(--accent-purple)', fontFamily: 'Space Mono' }}>{Math.round(prob * 100)}%</strong>
                                        </div>
                                        
                                        {/* Edge Badge avec couleur */}
                                        <div style={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '6px',
                                            padding: '4px 10px',
                                            borderRadius: '20px',
                                            background: edgeCategory.bg,
                                            border: `1px solid ${edgeCategory.color}40`
                                        }}>
                                            <span style={{ fontSize: '0.75rem', color: edgeCategory.color, fontWeight: '600' }}>
                                                {edgeCategory.label}
                                            </span>
                                            <span style={{ 
                                                fontFamily: 'Space Mono', 
                                                fontSize: '0.85rem', 
                                                fontWeight: '700',
                                                color: edgeCategory.color
                                            }}>
                                                {edge > 0 ? '+' : ''}{edge}%
                                            </span>
                                        </div>
                                    </div>
                                    
                                    {/* Mise calcul√©e (dynamique si s√©lectionn√©e) */}
                                    <div style={{ 
                                        display: 'flex', 
                                        justifyContent: 'space-between',
                                        alignItems: 'center',
                                        padding: '8px 10px',
                                        background: selected ? 'rgba(16, 185, 129, 0.15)' : 'rgba(245, 158, 11, 0.1)',
                                        borderRadius: '8px',
                                        marginBottom: '8px',
                                        border: selected ? '1px solid rgba(16, 185, 129, 0.3)' : 'none'
                                    }}>
                                        <div>
                                            <span style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>
                                                {selected ? '‚úÖ Mise allou√©e' : 'üí∞ Mise estim√©e'}
                                            </span>
                                            <div style={{ fontFamily: 'Space Mono', fontSize: '1rem', color: selected ? 'var(--accent-green)' : 'var(--accent-gold)', fontWeight: '700' }}>
                                                {displayStake.toLocaleString()} F
                                            </div>
                                        </div>
                                        <div style={{ textAlign: 'center' }}>
                                            <span style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>R√©part.</span>
                                            <div style={{ fontFamily: 'Space Mono', fontSize: '0.85rem', color: 'var(--accent-blue)' }}>
                                                {displayKelly}%
                                            </div>
                                        </div>
                                        <div style={{ textAlign: 'right' }}>
                                            <span style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Gain pot.</span>
                                            <div style={{ fontFamily: 'Space Mono', fontSize: '0.85rem', color: 'var(--accent-green)' }}>
                                                +{Math.round(displayStake * (option.odds || 1.5) - displayStake).toLocaleString()} F
                                            </div>
                                        </div>
                                    </div>
                                    
                                    {/* Bouton "Pourquoi cette option?" */}
                                    {!isReadOnly && (
                                        <button
                                            onClick={(e) => toggleReason(option.option, e)}
                                            style={{
                                                width: '100%',
                                                padding: '8px',
                                                background: isExpanded ? 'rgba(139, 92, 246, 0.2)' : 'rgba(255,255,255,0.05)',
                                                border: '1px solid rgba(139, 92, 246, 0.3)',
                                                borderRadius: '6px',
                                                color: '#a78bfa',
                                                fontSize: '0.8rem',
                                                cursor: 'pointer',
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                gap: '6px',
                                                transition: 'all 0.2s ease'
                                            }}
                                        >
                                            üîç Pourquoi cette option ?
                                            <span style={{ transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>‚ñº</span>
                                        </button>
                                    )}
                                    
                                    {/* Section d√©pliable "Pourquoi" */}
                                    {isExpanded && (
                                        <div style={{
                                            marginTop: '10px',
                                            padding: '12px',
                                            background: 'rgba(139, 92, 246, 0.1)',
                                            borderRadius: '8px',
                                            border: '1px solid rgba(139, 92, 246, 0.2)'
                                        }}>
                                            {/* Edge explication */}
                                            <div style={{ marginBottom: '10px' }}>
                                                <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)', marginBottom: '4px' }}>
                                                    üìà Analyse de valeur (Edge)
                                                </div>
                                                <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', margin: 0, lineHeight: '1.4' }}>
                                                    Edge de <strong style={{ color: edgeCategory.color }}>{edge}%</strong>: {edgeCategory.description}.
                                                    {edge > 10 && " Les bookmakers sous-estiment cette probabilit√©."}
                                                    {edge < 5 && edge > 0 && " Petite marge, mise conservatrice recommand√©e."}
                                                </p>
                                            </div>
                                            
                                            {/* Facteurs cl√©s */}
                                            {(factors.length > 0 || option.reasoning) && (
                                                <div style={{ marginBottom: '10px' }}>
                                                    <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)', marginBottom: '4px' }}>
                                                        üéØ Facteurs cl√©s
                                                    </div>
                                                    {factors.length > 0 ? (
                                                        <ul style={{ margin: 0, paddingLeft: '16px', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                            {factors.slice(0, 3).map((f, i) => (
                                                                <li key={i} style={{ marginBottom: '4px' }}>{f}</li>
                                                            ))}
                                                        </ul>
                                                    ) : option.reasoning && (
                                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', margin: 0, fontStyle: 'italic' }}>
                                                            {option.reasoning}
                                                        </p>
                                                    )}
                                                </div>
                                            )}
                                            
                                            {/* Statistiques */}
                                            {stats.length > 0 && (
                                                <div style={{ marginBottom: '10px' }}>
                                                    <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)', marginBottom: '4px' }}>
                                                        üìä Statistiques d√©terminantes
                                                    </div>
                                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                                                        {stats.slice(0, 3).map((stat, i) => (
                                                            <span key={i} style={{
                                                                padding: '4px 8px',
                                                                background: 'rgba(59, 130, 246, 0.2)',
                                                                borderRadius: '4px',
                                                                fontSize: '0.75rem',
                                                                color: 'var(--accent-blue)'
                                                            }}>
                                                                {stat}
                                                            </span>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                            
                                            {/* Conditions sp√©cifiques */}
                                            {conditions.length > 0 && (
                                                <div style={{ marginBottom: '10px' }}>
                                                    <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)', marginBottom: '4px' }}>
                                                        ‚ö†Ô∏è Conditions sp√©cifiques
                                                    </div>
                                                    <p style={{ fontSize: '0.8rem', color: 'var(--accent-gold)', margin: 0 }}>
                                                        {conditions.join(' ‚Ä¢ ')}
                                                    </p>
                                                </div>
                                            )}
                                            
                                            {/* Logique du mod√®le */}
                                            <div style={{ 
                                                marginTop: '10px', 
                                                paddingTop: '10px', 
                                                borderTop: '1px solid rgba(255,255,255,0.1)',
                                                fontSize: '0.75rem',
                                                color: 'var(--text-muted)'
                                            }}>
                                                üß† <strong>Logique IA:</strong> Prob ({Math.round(prob * 100)}%) √ó Cote ({option.odds?.toFixed(2)}) = Value {value?.toFixed(2)}
                                                {value > 1 && <span style={{ color: 'var(--accent-green)' }}> ‚Üí Value positive ‚úì</span>}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            );
                        })}

                        {/* R√©capitulatif des s√©lections avec mises calcul√©es */}
                        {selectedOptions.length > 0 && !isReadOnly && (
                            <div className="recommendation-box animate-fade-in delay-4" style={{
                                background: 'linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%)',
                                border: '1px solid rgba(16, 185, 129, 0.3)'
                            }}>
                                <div className="recommendation-title">
                                    <Icons.DollarSign />
                                    üìä R√©capitulatif - Mises calcul√©es
                                </div>
                                
                                {/* Info Capital Allou√© */}
                                <div style={{ 
                                    display: 'flex', 
                                    justifyContent: 'space-between', 
                                    alignItems: 'center',
                                    padding: '10px 12px',
                                    background: 'rgba(139, 92, 246, 0.1)',
                                    borderRadius: '8px',
                                    marginBottom: '12px'
                                }}>
                                    <div>
                                        <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>Capital allou√© ({stakePercentage}%)</div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.1rem', fontWeight: '700', color: 'var(--accent-purple)' }}>
                                            {allocatedCapital.toLocaleString()} FCFA
                                        </div>
                                    </div>
                                    <div style={{ textAlign: 'right' }}>
                                        <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>R√©parti sur</div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.1rem', fontWeight: '700', color: 'var(--accent-blue)' }}>
                                            {calculatedOptions.length} option{calculatedOptions.length > 1 ? 's' : ''}
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Liste des options s√©lectionn√©es avec mises */}
                                {calculatedOptions.map((opt, i) => (
                                    <div key={i} style={{ 
                                        display: 'flex', 
                                        justifyContent: 'space-between', 
                                        alignItems: 'center',
                                        padding: '10px 0',
                                        borderBottom: i < calculatedOptions.length - 1 ? '1px solid var(--border-color)' : 'none'
                                    }}>
                                        <div style={{ flex: 1 }}>
                                            <span style={{ color: 'var(--text-primary)', fontWeight: '500' }}>{opt.option}</span>
                                            <div style={{ display: 'flex', gap: '12px', marginTop: '4px' }}>
                                                <span style={{ color: 'var(--accent-gold)', fontSize: '0.8rem', fontFamily: 'Space Mono' }}>
                                                    @{opt.odds?.toFixed(2)}
                                                </span>
                                                <span style={{ color: 'var(--accent-purple)', fontSize: '0.8rem' }}>
                                                    ü§ñ {Math.round(opt.probability * 100)}%
                                                </span>
                                                <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem' }}>
                                                    ({opt.kellyPercentage}%)
                                                </span>
                                            </div>
                                        </div>
                                        <div style={{ textAlign: 'right' }}>
                                            <div style={{ fontFamily: 'Space Mono', color: 'var(--accent-green)', fontWeight: 'bold', fontSize: '1rem' }}>
                                                {opt.stake?.toLocaleString()} F
                                            </div>
                                            <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                                ‚Üí {opt.potentialReturn?.toLocaleString()} F
                                            </div>
                                        </div>
                                    </div>
                                ))}
                                
                                {/* Total */}
                                <div style={{ 
                                    marginTop: '12px', 
                                    padding: '12px',
                                    background: 'rgba(16, 185, 129, 0.15)',
                                    borderRadius: '8px',
                                    display: 'flex',
                                    justifyContent: 'space-between'
                                }}>
                                    <div>
                                        <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>Total mis√©</div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.1rem', fontWeight: '700', color: 'var(--accent-green)' }}>
                                            {calculatedOptions.reduce((sum, o) => sum + (o.stake || 0), 0).toLocaleString()} FCFA
                                        </div>
                                    </div>
                                    <div style={{ textAlign: 'right' }}>
                                        <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>Gain max potentiel</div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.1rem', fontWeight: '700', color: 'var(--accent-gold)' }}>
                                            +{calculatedOptions.reduce((sum, o) => sum + ((o.potentialReturn || 0) - (o.stake || 0)), 0).toLocaleString()} FCFA
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Message si aucune s√©lection */}
                        {selectedOptions.length === 0 && !isReadOnly && options.length > 0 && (
                            <div style={{ 
                                padding: '16px', 
                                textAlign: 'center',
                                background: 'rgba(245, 158, 11, 0.1)',
                                borderRadius: '12px',
                                marginTop: '16px'
                            }}>
                                <p style={{ color: 'var(--accent-gold)', margin: 0, fontSize: '0.9rem' }}>
                                    üëÜ S√©lectionnez des options pour voir les mises calcul√©es automatiquement
                                </p>
                            </div>
                        )}

                        {/* Bouton Valider ou Retour */}
                        {isReadOnly ? (
                            <button 
                                className="btn btn-secondary animate-fade-in delay-5" 
                                style={{ width: '100%', marginTop: '20px', marginBottom: '20px' }}
                                onClick={() => navigate('pronostics')}
                            >
                                <Icons.ArrowLeft />
                                Retour aux pronostics
                            </button>
                        ) : (
                            <button 
                                className="btn btn-primary animate-fade-in delay-5" 
                                style={{ width: '100%', marginTop: '20px', marginBottom: '20px' }}
                                onClick={handleValidate}
                                disabled={selectedOptions.length === 0}
                            >
                                {selectedOptions.length === 0 ? 'S√©lectionnez des options' : `Valider ${selectedOptions.length} option${selectedOptions.length > 1 ? 's' : ''}`}
                                <Icons.Check />
                            </button>
                        )}
                    </main>
                    <BottomNav />
                </>
            );
        };

        const PronosticsPage = () => {
            const { activePredictions, setActivePredictions, navigate, user, requireAuth, setCurrentPrediction, currentPrediction, selectedOptions, setSelectedOptions, fetchUserPredictions, showNotification, livePollingActive, API_BASE_URL, apiCallWithAuth, setSelectedMatch, analysisLock } = useApp();

            // Fonction pour demander le hedging
            const requestHedging = async (prediction) => {
                try {
                    const response = await apiCallWithAuth(
                        `${API_BASE_URL}/hedging/strategy`,
                        {
                            method: 'POST',
                            body: JSON.stringify({ predictionId: prediction.id })
                        }
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        setCurrentPrediction({ ...prediction, hedgingStrategy: data.strategy });
                        navigate('cashout');
                    } else {
                        const error = await response.json();
                        showNotification(error.message || 'Hedging non disponible', 'warning');
                    }
                } catch (error) {
                    showNotification('Erreur lors de la demande de hedging', 'error');
                }
            };

            // Extraire les infos du match depuis diff√©rentes structures possibles
            const getMatchInfo = (pred) => {
                const match = pred.match || pred.matchInfo || {};
                return {
                    homeTeam: match.homeTeam || pred.meta?.homeTeam || '√âquipe A',
                    awayTeam: match.awayTeam || pred.meta?.awayTeam || '√âquipe B',
                    league: match.league || pred.meta?.league || 'Championnat'
                };
            };

            // Extraire les options (valid√©es ou recommand√©es)
            const getOptions = (pred) => {
                console.log('üìã getOptions called for:', pred.id, {
                    selectedOptions: pred.selectedOptions?.length || 0,
                    stakesStakes: pred.stakes?.stakes?.length || 0,
                    recommendedOptions: pred.oddsAnalysis?.recommendedOptions?.length || 0
                });
                
                // 1. D'abord chercher les options VALID√âES par l'utilisateur
                if (pred.selectedOptions && pred.selectedOptions.length > 0) {
                    const stakesList = pred.stakes?.stakes || [];
                    
                    return pred.selectedOptions.map(opt => {
                        const stakeInfo = stakesList.find(s => s.option === opt.option);
                        // Essayer plusieurs sources pour la mise
                        const stake = opt.stake || opt.adjustedStake || stakeInfo?.adjustedStake || stakeInfo?.stake || 0;
                        const odds = opt.odds || stakeInfo?.odds || 0;
                        
                        console.log(`  Option "${opt.option}": stake=${stake}, odds=${odds}`);
                        
                        return {
                            option: opt.option,
                            stake: stake,
                            odds: odds,
                            potentialReturn: opt.potentialReturn || stakeInfo?.potentialReturn || Math.round(stake * odds),
                            isValidated: true
                        };
                    });
                }
                
                // 2. Sinon, retourner les options recommand√©es (pour permettre validation)
                if (pred.stakes?.stakes && pred.stakes.stakes.length > 0) {
                    return pred.stakes.stakes.map(s => ({
                        option: s.option,
                        stake: s.adjustedStake || s.stake || 0,
                        odds: s.odds || 0,
                        potentialReturn: s.potentialReturn || Math.round((s.adjustedStake || s.stake || 0) * (s.odds || 1)),
                        isValidated: false
                    }));
                }
                
                // 3. Ou depuis oddsAnalysis
                if (pred.oddsAnalysis?.recommendedOptions && pred.oddsAnalysis.recommendedOptions.length > 0) {
                    return pred.oddsAnalysis.recommendedOptions.map(opt => ({
                        option: opt.option,
                        stake: 0,
                        odds: opt.odds || 0,
                        potentialReturn: 0,
                        isValidated: false
                    }));
                }
                
                return [];
            };

            // V√©rifier si l'utilisateur a valid√© des options
            const hasValidatedOptions = (pred) => {
                return pred.selectedOptions && pred.selectedOptions.length > 0;
            };
            
            // V√©rifier si des options recommand√©es existent
            const hasRecommendedOptions = (pred) => {
                return (pred.stakes?.stakes?.length > 0) || 
                       (pred.oddsAnalysis?.recommendedOptions?.length > 0);
            };

            // V√©rifier si le match est termin√©
            const isMatchFinished = (pred) => {
                // V√©rifier via le statut live
                if (pred.liveStatus?.matchStatus?.isFinished) {
                    return true;
                }
                // V√©rifier via le statut de la pr√©diction
                const status = pred.status?.toLowerCase();
                if (status === 'won' || status === 'lost' || status === 'finished') {
                    return true;
                }
                return false;
            };

            const handleHedging = (pred) => {
                // V√©rifier si le match a commenc√© avant d'autoriser
                if (!isMatchStarted(pred)) {
                    showNotification("Le match n'a pas encore commenc√©. La couverture sera disponible apr√®s le coup d'envoi.", "warning");
                    return;
                }
                setCurrentPrediction(pred);
                navigate('cashout');
            };

            const handleViewDetails = (pred) => {
                // R√©initialiser les options s√©lectionn√©es pour charger celles de la pr√©diction
                setSelectedOptions([]);
                setCurrentPrediction(pred);
                navigate('strategy');
            };

            // Rafra√Æchir les pr√©dictions
            const handleRefresh = async () => {
                showNotification('Actualisation...', 'info');
                await fetchUserPredictions();
                showNotification('Liste actualis√©e', 'success');
            };

            // Filtrer et d√©dupliquer les pr√©dictions
            // Afficher: pr√©dictions non termin√©es, d√©dupliqu√©es par match (garder celle avec options valid√©es)
            const activePreds = (() => {
                const filtered = activePredictions.filter(p => {
                    // Exclure les matchs termin√©s
                    const status = p.status?.toLowerCase();
                    if (status === 'won' || status === 'lost' || status === 'finished' || status === 'cancelled') {
                        return false;
                    }
                    
                    // V√©rifier le statut live s'il existe
                    if (p.liveStatus?.matchStatus?.isFinished) {
                        return false;
                    }
                    
                    return true;
                });
                
                // D√©dupliquer par MATCH (pas seulement par ID)
                // Utiliser fixtureId ou combinaison homeTeam+awayTeam comme cl√© unique
                const matchMap = new Map();
                
                filtered.forEach(pred => {
                    // Cr√©er une cl√© unique pour le match
                    const homeTeam = pred.matchInfo?.homeTeam || pred.meta?.homeTeam || pred.match?.homeTeam || '';
                    const awayTeam = pred.matchInfo?.awayTeam || pred.meta?.awayTeam || pred.match?.awayTeam || '';
                    const fixtureId = pred.matchInfo?.fixtureId || pred.meta?.matchId || pred.opportunityId || '';
                    
                    // Cl√© unique: fixtureId si disponible, sinon homeTeam vs awayTeam
                    const matchKey = fixtureId ? `fixture_${fixtureId}` : `${homeTeam}_vs_${awayTeam}`.toLowerCase();
                    
                    if (!matchMap.has(matchKey)) {
                        matchMap.set(matchKey, pred);
                    } else {
                        const existing = matchMap.get(matchKey);
                        
                        // Garder la pr√©diction la plus avanc√©e:
                        // 1. Celle avec selectedOptions valid√©es (status: 'active')
                        // 2. Celle avec le plus d'options s√©lectionn√©es
                        // 3. Celle avec le statut le plus avanc√©
                        // 4. La plus r√©cente
                        
                        const existingHasOptions = existing.selectedOptions?.length > 0;
                        const newHasOptions = pred.selectedOptions?.length > 0;
                        
                        // Priorit√© 1: Celle avec options valid√©es
                        if (newHasOptions && !existingHasOptions) {
                            matchMap.set(matchKey, pred);
                        }
                        // Priorit√© 2: Si les deux ont des options, garder celle avec plus d'options
                        else if (newHasOptions && existingHasOptions) {
                            if (pred.selectedOptions.length > existing.selectedOptions.length) {
                                matchMap.set(matchKey, pred);
                            }
                        }
                        // Priorit√© 3: Statut 'active' > 'analyzed' > autres
                        else if (!newHasOptions && !existingHasOptions) {
                            const statusPriority = { 'active': 3, 'analyzed': 2, 'analyzing': 1 };
                            const existingPriority = statusPriority[existing.status] || 0;
                            const newPriority = statusPriority[pred.status] || 0;
                            
                            if (newPriority > existingPriority) {
                                matchMap.set(matchKey, pred);
                            }
                            // Priorit√© 4: La plus r√©cente (validatedAt ou analyzedAt)
                            else if (newPriority === existingPriority) {
                                const existingTime = new Date(existing.validatedAt || existing.analyzedAt || existing.createdAt || 0).getTime();
                                const newTime = new Date(pred.validatedAt || pred.analyzedAt || pred.createdAt || 0).getTime();
                                if (newTime > existingTime) {
                                    matchMap.set(matchKey, pred);
                                }
                            }
                        }
                    }
                });
                
                console.log(`üìã Deduplicated: ${filtered.length} ‚Üí ${matchMap.size} predictions`);
                
                return Array.from(matchMap.values());
            })();

            // D√©terminer si un match est commenc√©
            const isMatchStarted = (pred) => {
                // V√©rifier le statut live s'il existe
                if (pred.liveStatus?.matchStatus?.hasStarted) {
                    return true;
                }
                // Sinon v√©rifier la date
                const matchDate = pred.matchInfo?.matchDate || pred.meta?.matchDate || pred.match?.matchDate;
                if (!matchDate) return false;
                
                // G√©rer diff√©rents formats de date (Firestore timestamp, ISO string, etc.)
                let date;
                if (matchDate._seconds) {
                    // Firestore Timestamp
                    date = new Date(matchDate._seconds * 1000);
                } else if (matchDate.seconds) {
                    // Firestore Timestamp (autre format)
                    date = new Date(matchDate.seconds * 1000);
                } else {
                    date = new Date(matchDate);
                }
                
                return date <= new Date();
            };

            // Formater la date du match
            const formatMatchDate = (pred) => {
                const matchDate = pred.matchInfo?.matchDate || pred.meta?.matchDate || pred.match?.matchDate;
                if (!matchDate) return null;
                
                // G√©rer diff√©rents formats de date
                let date;
                if (matchDate._seconds) {
                    date = new Date(matchDate._seconds * 1000);
                } else if (matchDate.seconds) {
                    date = new Date(matchDate.seconds * 1000);
                } else {
                    date = new Date(matchDate);
                }
                
                // V√©rifier si la date est valide
                if (isNaN(date.getTime())) return null;
                
                const now = new Date();
                
                if (date > now) {
                    // Match √† venir
                    const diffMs = date - now;
                    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                    const diffDays = Math.floor(diffHours / 24);
                    
                    if (diffDays > 0) {
                        return `Dans ${diffDays}j`;
                    } else if (diffHours > 0) {
                        return `Dans ${diffHours}h`;
                    } else {
                        const diffMins = Math.floor(diffMs / (1000 * 60));
                        return `Dans ${diffMins}min`;
                    }
                } else {
                    return 'En cours';
                }
            };

            // Formater la date de cr√©ation
            const formatCreatedAt = (createdAt) => {
                if (!createdAt) return null;
                
                let date;
                if (createdAt._seconds) {
                    date = new Date(createdAt._seconds * 1000);
                } else if (createdAt.seconds) {
                    date = new Date(createdAt.seconds * 1000);
                } else {
                    date = new Date(createdAt);
                }
                
                if (isNaN(date.getTime())) return null;
                
                return date.toLocaleDateString('fr-FR', { 
                    day: 'numeric', 
                    month: 'short',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            };

            return (
                <>
                    <Header showBack={false} title="Pronostics en cours" />
                    <main className="main-content">
                        {/* Indicateur de suivi live */}
                        {livePollingActive && (
                            <div className="animate-fade-in" style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px',
                                padding: '8px 12px',
                                marginBottom: '12px',
                                background: 'rgba(34, 197, 94, 0.1)',
                                border: '1px solid rgba(34, 197, 94, 0.3)',
                                borderRadius: '8px'
                            }}>
                                <div style={{
                                    width: '10px',
                                    height: '10px',
                                    borderRadius: '50%',
                                    background: '#22c55e',
                                    animation: 'pulse 1.5s ease-in-out infinite'
                                }}></div>
                                <span style={{ color: '#22c55e', fontSize: '0.85rem', fontWeight: '500' }}>
                                    üì° Suivi live actif - Mise √† jour auto toutes les 60s
                                </span>
                            </div>
                        )}
                        
                        {/* Bouton refresh */}
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
                            <p style={{ color: 'var(--text-muted)', margin: 0 }}>
                                {activePreds.length} pronostic{activePreds.length > 1 ? 's' : ''} actif{activePreds.length > 1 ? 's' : ''}
                            </p>
                            <button 
                                className="btn btn-secondary" 
                                style={{ padding: '6px 12px', fontSize: '0.8rem' }}
                                onClick={handleRefresh}
                            >
                                üîÑ Actualiser
                            </button>
                        </div>

                        {activePreds.length === 0 ? (
                            <div className="empty-state animate-fade-in">
                                <Icons.Target />
                                <p>Aucun pronostic en cours</p>
                                <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem', marginTop: '8px' }}>
                                    Analysez un match pour commencer
                                </p>
                                <button 
                                    className="btn btn-primary" 
                                    style={{ marginTop: '20px' }}
                                    onClick={() => navigate('home')}
                                >
                                    <Icons.Zap />
                                    S√©lectionner un match
                                </button>
                            </div>
                        ) : (
                            <>
                                {activePreds.map((pred, index) => {
                                    const matchInfo = getMatchInfo(pred);
                                    const options = getOptions(pred);
                                    const totalStake = options.reduce((sum, opt) => sum + (opt.stake || 0), 0);
                                    const matchStarted = isMatchStarted(pred);
                                    const matchDateDisplay = formatMatchDate(pred);
                                    const fixtureId = pred.matchInfo?.fixtureId || pred.meta?.matchId || pred.opportunityId;
                                    
                                    // D√©terminer le statut et les couleurs
                                    const getStatusDisplay = () => {
                                        switch(pred.status) {
                                            case 'analyzing':
                                                return { label: 'üîÑ Analyse en cours', bg: 'var(--accent-blue)', color: '#fff' };
                                            case 'analyzed':
                                                return { label: '‚úÖ Analyse termin√©e', bg: 'var(--accent-gold)', color: '#000' };
                                            case 'active':
                                                return { label: 'üü¢ Valid√©', bg: 'var(--accent-green)', color: '#000' };
                                            case 'error':
                                                return { label: '‚ùå Erreur', bg: 'var(--accent-red)', color: '#fff' };
                                            default:
                                                return { label: '‚ö™ En attente', bg: 'rgba(107, 114, 128, 0.3)', color: '#fff' };
                                        }
                                    };
                                    const statusDisplay = getStatusDisplay();
                                    
                                    return (
                                        <div key={pred.id || index} className={`card animate-fade-in delay-${Math.min(index + 1, 5)}`} style={{ marginBottom: '16px' }}>
                                            {/* Header */}
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '12px' }}>
                                                <div>
                                                    <h3 style={{ marginBottom: '4px' }}>{matchInfo.homeTeam} vs {matchInfo.awayTeam}</h3>
                                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>{matchInfo.league}</p>
                                                </div>
                                                <div style={{ textAlign: 'right' }}>
                                                    <span style={{ 
                                                        background: statusDisplay.bg,
                                                        color: statusDisplay.color,
                                                        padding: '4px 12px',
                                                        borderRadius: '20px',
                                                        fontSize: '0.7rem',
                                                        fontWeight: '600',
                                                        whiteSpace: 'nowrap',
                                                        display: 'inline-block'
                                                    }}>
                                                        {statusDisplay.label}
                                                    </span>
                                                    {matchDateDisplay && (
                                                        <p style={{ 
                                                            color: matchStarted ? 'var(--accent-green)' : 'var(--text-muted)', 
                                                            fontSize: '0.7rem', 
                                                            marginTop: '4px' 
                                                        }}>
                                                            {matchStarted ? '‚öΩ En cours' : `‚è∞ ${matchDateDisplay}`}
                                                        </p>
                                                    )}
                                                </div>
                                            </div>

                                            {/* === STATUT: ANALYZING === */}
                                            {pred.status === 'analyzing' && (
                                                <div style={{ marginBottom: '16px' }}>
                                                    <div style={{ 
                                                        padding: '20px', 
                                                        background: 'rgba(59, 130, 246, 0.1)', 
                                                        borderRadius: '12px',
                                                        textAlign: 'center'
                                                    }}>
                                                        <div className="spinner" style={{ margin: '0 auto 12px', width: '30px', height: '30px' }}></div>
                                                        <p style={{ color: 'var(--accent-blue)', fontWeight: '500', margin: 0 }}>
                                                            üß† Analyse IA en cours...
                                                        </p>
                                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem', marginTop: '8px' }}>
                                                            Claude + DeepSeek analysent le match
                                                        </p>
                                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginTop: '4px' }}>
                                                            ‚è±Ô∏è Temps estim√©: 30-60 secondes
                                                        </p>
                                                        <div style={{ 
                                                            marginTop: '12px',
                                                            padding: '8px',
                                                            background: 'rgba(245, 158, 11, 0.1)',
                                                            borderRadius: '6px',
                                                            fontSize: '0.75rem',
                                                            color: 'var(--accent-gold)'
                                                        }}>
                                                            ‚ö†Ô∏è Ne fermez pas l'application pendant l'analyse
                                                        </div>
                                                    </div>
                                                </div>
                                            )}

                                            {/* === STATUT: ANALYZED (en attente de validation) === */}
                                            {pred.status === 'analyzed' && (
                                                <div style={{ marginBottom: '16px' }}>
                                                    {/* Avertissement si l'IA a √©chou√© */}
                                                    {pred.aiError && (
                                                        <div style={{ 
                                                            padding: '12px', 
                                                            background: 'rgba(239, 68, 68, 0.15)', 
                                                            borderRadius: '10px',
                                                            marginBottom: '12px',
                                                            border: '1px solid rgba(239, 68, 68, 0.3)'
                                                        }}>
                                                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                                                                <span style={{ fontSize: '1.2rem' }}>‚ö†Ô∏è</span>
                                                                <span style={{ color: '#f59e0b', fontWeight: '600', fontSize: '0.9rem' }}>
                                                                    Analyse partielle
                                                                </span>
                                                            </div>
                                                            <p style={{ color: 'var(--text-secondary)', fontSize: '0.8rem', margin: '0 0 10px' }}>
                                                                L'analyse IA a rencontr√© un probl√®me ({pred.aiError?.message || 'Erreur de connexion'}). 
                                                                Les r√©sultats sont bas√©s sur des calculs de secours.
                                                            </p>
                                                            {pred.canRetry && (
                                                                <button 
                                                                    className="btn btn-secondary"
                                                                    style={{ 
                                                                        width: '100%', 
                                                                        padding: '10px',
                                                                        background: 'rgba(245, 158, 11, 0.2)',
                                                                        border: '1px solid rgba(245, 158, 11, 0.5)',
                                                                        fontSize: '0.85rem'
                                                                    }}
                                                                    onClick={async () => {
                                                                        showNotification('Relance de l\'analyse...', 'info');
                                                                        try {
                                                                            const token = await getValidToken();
                                                                            const response = await fetch(`${API_BASE_URL}/predictions/${pred.id}/retry`, {
                                                                                method: 'POST',
                                                                                headers: { 'Authorization': `Bearer ${token}` }
                                                                            });
                                                                            const data = await response.json();
                                                                            if (response.ok && data.success) {
                                                                                showNotification('‚úÖ Analyse relanc√©e avec succ√®s!', 'success');
                                                                                // Rafra√Æchir les pr√©dictions
                                                                                await refreshPredictions();
                                                                            } else {
                                                                                showNotification(data.error || 'Erreur lors de la relance', 'error');
                                                                            }
                                                                        } catch (err) {
                                                                            showNotification('Erreur de connexion', 'error');
                                                                        }
                                                                    }}
                                                                >
                                                                    üîÑ Relancer l'analyse IA
                                                                </button>
                                                            )}
                                                        </div>
                                                    )}
                                                    
                                                    <div style={{ 
                                                        padding: '16px', 
                                                        background: pred.aiError ? 'rgba(107, 114, 128, 0.1)' : 'rgba(245, 158, 11, 0.1)', 
                                                        borderRadius: '12px',
                                                        marginBottom: '12px'
                                                    }}>
                                                        <p style={{ color: pred.aiError ? 'var(--text-secondary)' : 'var(--accent-gold)', fontWeight: '500', margin: '0 0 8px' }}>
                                                            üìã Analyse termin√©e{pred.isDemo ? ' (Mode d√©mo)' : ''} - En attente de validation
                                                        </p>
                                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem', margin: 0 }}>
                                                            {pred.aiError 
                                                                ? 'Vous pouvez utiliser ces r√©sultats ou relancer l\'analyse' 
                                                                : 'Consultez les options recommand√©es et validez vos choix'}
                                                        </p>
                                                    </div>
                                                    
                                                    {/* Aper√ßu des options recommand√©es */}
                                                    {options.length > 0 && (
                                                        <div style={{ marginTop: '12px' }}>
                                                            <p style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginBottom: '8px' }}>
                                                                üìä {options.length} option{options.length > 1 ? 's' : ''} recommand√©e{options.length > 1 ? 's' : ''}
                                                            </p>
                                                            {options.slice(0, 2).map((opt, i) => (
                                                                <div key={i} style={{ 
                                                                    display: 'flex', 
                                                                    justifyContent: 'space-between',
                                                                    padding: '6px 0',
                                                                    opacity: 0.8
                                                                }}>
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.85rem' }}>{opt.option}</span>
                                                                    <span style={{ color: 'var(--accent-gold)', fontSize: '0.85rem' }}>@{opt.odds?.toFixed(2)}</span>
                                                                </div>
                                                            ))}
                                                            {options.length > 2 && (
                                                                <p style={{ color: 'var(--text-muted)', fontSize: '0.75rem' }}>
                                                                    +{options.length - 2} autres...
                                                                </p>
                                                            )}
                                                        </div>
                                                    )}
                                                    
                                                    <button 
                                                        className="btn btn-primary" 
                                                        style={{ width: '100%', marginTop: '12px' }}
                                                        onClick={() => handleViewDetails(pred)}
                                                    >
                                                        <Icons.Eye />
                                                        Voir les r√©sultats et valider
                                                    </button>
                                                </div>
                                            )}

                                            {/* === STATUT: ERROR === */}
                                            {pred.status === 'error' && (
                                                <div style={{ marginBottom: '16px' }}>
                                                    <div style={{ 
                                                        padding: '16px', 
                                                        background: 'rgba(239, 68, 68, 0.1)', 
                                                        borderRadius: '12px',
                                                        textAlign: 'center'
                                                    }}>
                                                        <div style={{ marginBottom: '8px' }}>
                                                            <Icons.AlertCircle />
                                                        </div>
                                                        <p style={{ color: 'var(--accent-red)', fontWeight: '500', margin: '0 0 8px' }}>
                                                            Erreur lors de l'analyse
                                                        </p>
                                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem', margin: '0 0 12px' }}>
                                                            {pred.error || "Une erreur est survenue"}
                                                        </p>
                                                        {pred.canRetry && (
                                                            <button 
                                                                className="btn btn-secondary"
                                                                style={{ marginTop: '8px' }}
                                                                onClick={() => {
                                                                    // Supprimer cette pr√©diction et permettre une nouvelle analyse
                                                                    setActivePredictions(prev => prev.filter(p => p.id !== pred.id));
                                                                    setSelectedMatch(pred.match || { 
                                                                        id: pred.matchId,
                                                                        homeTeam: matchInfo.homeTeam,
                                                                        awayTeam: matchInfo.awayTeam,
                                                                        league: matchInfo.league,
                                                                        fixtureId: fixtureId
                                                                    });
                                                                    navigate('balance-input');
                                                                    showNotification("Vous pouvez relancer l'analyse", "info");
                                                                }}
                                                            >
                                                                üîÑ R√©essayer l'analyse
                                                            </button>
                                                        )}
                                                    </div>
                                                </div>
                                            )}

                                            {/* === STATUT: ACTIVE (valid√© et verrouill√©) === */}
                                            {pred.status === 'active' && (
                                                <>
                                                    {/* Info live si disponible */}
                                                    {pred.liveStatus?.matchStatus && (
                                                        <div style={{ 
                                                            marginBottom: '12px', 
                                                            padding: '8px 12px', 
                                                            background: 'rgba(59, 130, 246, 0.1)', 
                                                            borderRadius: '8px',
                                                            display: 'flex',
                                                            justifyContent: 'space-between',
                                                            alignItems: 'center'
                                                        }}>
                                                            <span style={{ color: 'var(--accent-blue)', fontSize: '0.8rem' }}>üìä Live</span>
                                                            <div style={{ textAlign: 'right' }}>
                                                                <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-gold)' }}>
                                                                    {pred.liveStatus.matchStatus.score?.home ?? 0} - {pred.liveStatus.matchStatus.score?.away ?? 0}
                                                                </span>
                                                                {pred.liveStatus.matchStatus.elapsed && (
                                                                    <span style={{ marginLeft: '8px', color: 'var(--text-muted)', fontSize: '0.8rem' }}>
                                                                        ({pred.liveStatus.matchStatus.elapsed}')
                                                                    </span>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}

                                                    {/* Badge Verrouill√© */}
                                                    <div style={{ 
                                                        display: 'flex', 
                                                        alignItems: 'center', 
                                                        gap: '8px',
                                                        padding: '8px 12px',
                                                        background: 'rgba(16, 185, 129, 0.1)',
                                                        borderRadius: '8px',
                                                        marginBottom: '12px'
                                                    }}>
                                                        <Icons.Lock style={{ color: 'var(--accent-green)', width: '16px', height: '16px' }} />
                                                        <span style={{ color: 'var(--accent-green)', fontSize: '0.8rem', fontWeight: '500' }}>
                                                            Pronostic valid√© et verrouill√©
                                                        </span>
                                                    </div>

                                                    {/* Bookmaker */}
                                                    {pred.selectedBookmaker && (
                                                        <div style={{ 
                                                            marginBottom: '12px', 
                                                            padding: '8px 12px', 
                                                            background: 'rgba(255,255,255,0.03)', 
                                                            borderRadius: '8px',
                                                            display: 'flex',
                                                            justifyContent: 'space-between'
                                                        }}>
                                                            <span style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>Bookmaker</span>
                                                            <span style={{ color: 'var(--accent-blue)', fontSize: '0.85rem', fontWeight: '500' }}>
                                                                {typeof pred.selectedBookmaker === 'object' ? pred.selectedBookmaker.name : pred.selectedBookmaker}
                                                            </span>
                                                        </div>
                                                    )}

                                                    {/* Options valid√©es */}
                                                    {hasValidatedOptions(pred) && (
                                                        <div style={{ marginBottom: '16px' }}>
                                                            <p style={{ color: 'var(--accent-green)', fontSize: '0.75rem', marginBottom: '8px' }}>
                                                                ‚úÖ Options valid√©es
                                                            </p>
                                                            {options.map((opt, i) => (
                                                                <div key={i} style={{ 
                                                                    display: 'flex', 
                                                                    justifyContent: 'space-between',
                                                                    alignItems: 'center',
                                                                    padding: '10px 0',
                                                                    borderBottom: i < options.length - 1 ? '1px solid var(--border-color)' : 'none'
                                                                }}>
                                                                    <div>
                                                                        <span style={{ color: 'var(--text-primary)' }}>{opt.option}</span>
                                                                        <span style={{ 
                                                                            marginLeft: '8px', 
                                                                            color: 'var(--accent-gold)', 
                                                                            fontFamily: 'Space Mono',
                                                                            fontSize: '0.85rem'
                                                                        }}>
                                                                            @{opt.odds?.toFixed(2)}
                                                                        </span>
                                                                    </div>
                                                                    <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-green)' }}>
                                                                        {opt.stake?.toLocaleString()} FCFA
                                                                    </span>
                                                                </div>
                                                            ))}
                                                            
                                                            {/* Total */}
                                                            <div style={{ 
                                                                display: 'flex', 
                                                                justifyContent: 'space-between',
                                                                marginTop: '12px',
                                                                paddingTop: '12px',
                                                                borderTop: '2px solid var(--border-color)'
                                                            }}>
                                                                <span style={{ fontWeight: '600' }}>Total mis√©</span>
                                                                <span style={{ fontFamily: 'Space Mono', color: 'var(--accent-gold)', fontWeight: 'bold' }}>
                                                                    {totalStake.toLocaleString()} FCFA
                                                                </span>
                                                            </div>
                                                        </div>
                                                    )}

                                                    {/* Boutons pour pronostic valid√© */}
                                                    <div style={{ display: 'flex', gap: '8px' }}>
                                                        <button 
                                                            className="btn btn-secondary" 
                                                            style={{ flex: 1 }}
                                                            onClick={() => handleViewDetails(pred)}
                                                        >
                                                            <Icons.Eye />
                                                            D√©tails
                                                        </button>
                                                        
                                                        {/* Bouton Couverture - toujours accessible */}
                                                        <button 
                                                            className={`btn ${matchStarted ? 'btn-primary' : 'btn-secondary'}`}
                                                            style={{ 
                                                                flex: 1,
                                                                opacity: matchStarted ? 1 : 0.6,
                                                                cursor: matchStarted ? 'pointer' : 'not-allowed',
                                                                background: pred.hedgingStrategy ? 'linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%)' : undefined
                                                            }}
                                                            onClick={() => handleHedging(pred)}
                                                            disabled={!matchStarted}
                                                            title={matchStarted ? (pred.hedgingStrategy ? 'Relancer l\'analyse de couverture' : 'Analyser la strat√©gie de couverture') : 'Disponible apr√®s le coup d\'envoi'}
                                                        >
                                                            {matchStarted ? <Icons.Shield /> : <Icons.Lock />}
                                                            {matchStarted ? (pred.hedgingStrategy ? 'üîÑ Couverture' : 'Couverture') : 'En attente'}
                                                        </button>
                                                    </div>
                                                </>
                                            )}

                                            {/* Timestamp */}
                                            {formatCreatedAt(pred.createdAt) && (
                                                <p style={{ 
                                                    color: 'var(--text-muted)', 
                                                    fontSize: '0.7rem', 
                                                    textAlign: 'right',
                                                    marginTop: '12px'
                                                }}>
                                                    Cr√©√© le {formatCreatedAt(pred.createdAt)}
                                                </p>
                                            )}
                                        </div>
                                    );
                                })}
                            </>
                        )}
                    </main>
                    <BottomNav />
                </>
            );
        };

        const CashoutPage = () => {
            const { navigate, showNotification, currentPrediction, setCurrentPrediction, selectedOptions: globalSelectedOptions, loading, setLoading, API_BASE_URL, user, goBack, getValidToken, apiCallWithAuth, activePredictions, setActivePredictions, analysisLock, acquireAnalysisLock, releaseAnalysisLock, isAnalysisInProgress } = useApp();
            const [cashouts, setCashouts] = useState({});
            const [actualStakes, setActualStakes] = useState({}); // Mises r√©elles de l'utilisateur
            const [liveData, setLiveData] = useState({ score: '0 - 0', minute: '0', stats: {} });
            const [matchStatus, setMatchStatus] = useState(null);
            const [canHedge, setCanHedge] = useState(false);
            const [statusMessage, setStatusMessage] = useState('');
            const [checkingStatus, setCheckingStatus] = useState(true);
            const [evaluatedOptions, setEvaluatedOptions] = useState([]);
            const [trackingData, setTrackingData] = useState(null);
            const [autoRefresh, setAutoRefresh] = useState(true);
            const [hedgingStrategy, setHedgingStrategy] = useState(null);
            const [calculatingStrategy, setCalculatingStrategy] = useState(false);
            const [liveOdds, setLiveOdds] = useState({});
            
            // ========== NOUVEAUX √âTATS POUR LE SUIVI AVANC√â ==========
            const [liveEvents, setLiveEvents] = useState([]); // √âv√©nements du match (buts, cartons...)
            const [globalStatus, setGlobalStatus] = useState(null); // Statut global de la pr√©diction
            const [showEvents, setShowEvents] = useState(true); // Afficher/masquer les √©v√©nements
            const [refreshInterval, setRefreshInterval] = useState(30); // Intervalle en secondes (30 par d√©faut)
            const [lastRefresh, setLastRefresh] = useState(null);

            // V√©rifier si une strat√©gie a d√©j√† √©t√© g√©n√©r√©e (informatif seulement, pas de blocage)
            const hasExistingStrategy = currentPrediction?.hedgingStrategy || currentPrediction?.hedgingStrategyGenerated;

            // R√©cup√©rer le pourcentage de mise de la pr√©diction
            const predStakePercentage = currentPrediction?.stakePercentage || 6;

            // R√©cup√©rer les options valid√©es depuis PLUSIEURS sources possibles
            const getValidatedOptions = () => {
                // 1. selectedOptions (source principale)
                if (currentPrediction?.selectedOptions?.length > 0) {
                    console.log('üìã Cashout: Options from selectedOptions');
                    return currentPrediction.selectedOptions;
                }
                
                // 2. stakes.stakes (options avec mises calcul√©es)
                if (currentPrediction?.stakes?.stakes?.length > 0) {
                    console.log('üìã Cashout: Options from stakes.stakes');
                    return currentPrediction.stakes.stakes.map(s => ({
                        option: s.option,
                        odds: s.odds,
                        stake: s.adjustedStake || s.stake || 0,
                        potentialReturn: s.potentialReturn || Math.round((s.adjustedStake || s.stake || 0) * (s.odds || 1))
                    }));
                }
                
                // 3. oddsAnalysis.recommendedOptions (options recommand√©es par l'IA)
                if (currentPrediction?.oddsAnalysis?.recommendedOptions?.length > 0) {
                    console.log('üìã Cashout: Options from oddsAnalysis.recommendedOptions');
                    const totalBudget = currentPrediction?.userBalance || 10000;
                    const stakePerOption = Math.round(totalBudget * predStakePercentage / 100); // Utiliser le % choisi
                    return currentPrediction.oddsAnalysis.recommendedOptions.map(opt => ({
                        option: opt.option,
                        odds: opt.odds,
                        stake: stakePerOption,
                        potentialReturn: Math.round(stakePerOption * (opt.odds || 1))
                    }));
                }
                
                console.log('‚ö†Ô∏è Cashout: No options found');
                return [];
            };

            const options = getValidatedOptions();
            const hasValidatedOptions = options.length > 0;

            const fixtureId = currentPrediction?.matchInfo?.fixtureId || currentPrediction?.meta?.matchId || currentPrediction?.opportunityId;
            const predictionId = currentPrediction?.id;

            // ========== CALCUL BREAK-EVEN ==========
            // Formule: Pour sortir √† 0 (break-even), on doit parier sur l'oppos√©
            // Mise de couverture = (Mise initiale √ó Cote initiale) / Cote oppos√©e
            const calculateBreakEven = (liveOddsData) => {
                const bets = [];
                const totalInvested = options.reduce((sum, opt) => sum + (opt.stake || 0), 0);
                
                for (const opt of options) {
                    const stake = opt.stake || 0;
                    const originalOdds = opt.odds || 1.5;
                    const potentialReturn = stake * originalOdds;
                    
                    // Trouver la cote oppos√©e dans les cotes live
                    let oppositeOdds = null;
                    let oppositeBet = null;
                    
                    const optLower = (opt.option || '').toLowerCase();
                    
                    // Logique pour trouver l'oppos√©
                    if (optLower.includes('plus de') || optLower.includes('over')) {
                        // Oppos√© = Moins de (Under)
                        const goals = optLower.match(/(\d+\.?\d*)/);
                        if (goals) {
                            oppositeBet = `Moins de ${goals[1]} buts`;
                            oppositeOdds = liveOddsData?.under?.[goals[1]] || liveOddsData?.goals?.under || 2.0;
                        }
                    } else if (optLower.includes('moins de') || optLower.includes('under')) {
                        // Oppos√© = Plus de (Over)
                        const goals = optLower.match(/(\d+\.?\d*)/);
                        if (goals) {
                            oppositeBet = `Plus de ${goals[1]} buts`;
                            oppositeOdds = liveOddsData?.over?.[goals[1]] || liveOddsData?.goals?.over || 2.0;
                        }
                    } else if (optLower.includes('btts') || optLower.includes('deux √©quipes marquent')) {
                        // Oppos√© = BTTS Non
                        oppositeBet = 'Les deux √©quipes ne marquent pas';
                        oppositeOdds = liveOddsData?.bttsNo || 1.8;
                    } else if (optLower.includes('victoire') && optLower.includes('domicile')) {
                        // Oppos√© = Double chance X2
                        oppositeBet = 'Match nul ou Victoire ext√©rieur (X2)';
                        oppositeOdds = liveOddsData?.doubleChance?.X2 || liveOddsData?.x2 || 1.5;
                    } else if (optLower.includes('victoire') && optLower.includes('ext√©rieur')) {
                        // Oppos√© = Double chance 1X
                        oppositeBet = 'Victoire domicile ou Match nul (1X)';
                        oppositeOdds = liveOddsData?.doubleChance?.['1X'] || liveOddsData?.['1x'] || 1.4;
                    } else if (optLower.includes('nul') || optLower.includes('draw')) {
                        // Oppos√© = 1 ou 2 (pas nul)
                        oppositeBet = 'Pas de match nul (1 ou 2)';
                        oppositeOdds = liveOddsData?.noDrawOdds || 1.3;
                    }
                    
                    if (oppositeOdds && oppositeBet) {
                        // Formule break-even: Mise = (Mise initiale √ó Cote initiale) / Cote oppos√©e
                        const hedgeStake = Math.ceil(potentialReturn / oppositeOdds);
                        const guaranteedReturn = hedgeStake * oppositeOdds;
                        
                        // Calcul du r√©sultat dans chaque sc√©nario
                        const scenarioOriginalWins = potentialReturn - stake - hedgeStake; // Original gagne, hedge perd
                        const scenarioHedgeWins = guaranteedReturn - stake - hedgeStake; // Hedge gagne, original perd
                        
                        bets.push({
                            originalOption: opt.option,
                            originalStake: stake,
                            originalOdds: originalOdds,
                            oppositeBet,
                            oppositeOdds,
                            hedgeStake,
                            guaranteedReturn: Math.round(guaranteedReturn),
                            scenarioOriginalWins: Math.round(scenarioOriginalWins),
                            scenarioHedgeWins: Math.round(scenarioHedgeWins),
                            breakEvenAchieved: Math.abs(scenarioOriginalWins - scenarioHedgeWins) < 100
                        });
                    }
                }
                
                setBreakEvenBets(bets);
                return bets;
            };

            // NE PAS rediriger automatiquement - juste afficher un message si pas d'options
            // L'utilisateur peut retourner manuellement

            // ========== SUIVI EN TEMPS R√âEL AVANC√â ==========
            const checkMatchStatus = async () => {
                // Obtenir un token frais
                const token = await getValidToken();
                if (!token) {
                    console.warn('‚ö†Ô∏è Pas de token disponible');
                    setCheckingStatus(false);
                    setStatusMessage("‚ö†Ô∏è Session expir√©e - Reconnectez-vous");
                    return;
                }
                
                // Utiliser le nouveau endpoint de live-tracking avanc√©
                if (predictionId && user) {
                    try {
                        console.log('üî¥ Fetching live tracking for prediction:', predictionId);
                        const trackResponse = await fetch(`${API_BASE_URL}/predictions/${predictionId}/live-tracking`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (trackResponse.ok) {
                            const trackData = await trackResponse.json();
                            console.log('üìä Live tracking data:', trackData);
                            setTrackingData(trackData.tracking);
                            setLastRefresh(new Date());
                            
                            if (trackData.tracking?.matchStatus) {
                                const ms = trackData.tracking.matchStatus;
                                setMatchStatus(ms);
                                setCanHedge(ms.canHedge || false);
                                
                                // Message bas√© sur le statut r√©el
                                if (!ms.hasStarted) {
                                    setStatusMessage(`Le match n'a pas encore commenc√©. Coup d'envoi pr√©vu.`);
                                } else if (ms.isFinished) {
                                    setStatusMessage(`Match termin√© (${ms.statusLong || 'FT'})`);
                                } else if (!ms.canHedge) {
                                    const waitTime = Math.max(0, 40 - (ms.elapsed || 0));
                                    setStatusMessage(`Match en cours (${ms.elapsed}'). Hedging disponible dans ${waitTime} min.`);
                                } else {
                                    setStatusMessage("‚úÖ Strat√©gie de couverture disponible!");
                                }
                                
                                // Score live
                                if (ms.score) {
                                    setLiveData({
                                        score: `${ms.score.home ?? 0} - ${ms.score.away ?? 0}`,
                                        minute: ms.elapsed || '0',
                                        status: ms.statusLong || ms.status
                                    });
                                }
                            }
                            
                            // Options √©valu√©es avec probabilit√©s dynamiques et √©volution des cotes
                            if (trackData.tracking?.options) {
                                setEvaluatedOptions(trackData.tracking.options);
                            }
                            
                            // √âv√©nements du match
                            if (trackData.tracking?.events) {
                                setLiveEvents(trackData.tracking.events);
                            }
                            
                            // Statut global de la pr√©diction
                            if (trackData.tracking?.globalStatus) {
                                setGlobalStatus(trackData.tracking.globalStatus);
                            }
                            
                            // Cotes live
                            if (trackData.tracking?.liveOdds) {
                                setLiveOdds(trackData.tracking.liveOdds);
                            }
                            
                            setCheckingStatus(false);
                            return;
                        }
                    } catch (error) {
                        console.warn("Live tracking error:", error);
                    }
                }
                
                // Fallback vers l'ancien endpoint de tracking simple
                if (predictionId && user) {
                    try {
                        const trackResponse = await fetch(`${API_BASE_URL}/predictions/${predictionId}/track`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (trackResponse.ok) {
                            const trackData = await trackResponse.json();
                            setTrackingData(trackData.tracking);
                            
                            if (trackData.tracking?.matchStatus) {
                                const ms = trackData.tracking.matchStatus;
                                setMatchStatus(ms);
                                setCanHedge(ms.canHedge || false);
                                
                                if (!ms.hasStarted) {
                                    setStatusMessage(`Le match n'a pas encore commenc√©.`);
                                } else if (!ms.canHedge) {
                                    const waitTime = Math.max(0, 40 - (ms.elapsed || 0));
                                    setStatusMessage(`Match en cours (${ms.elapsed}'). Hedging dans ${waitTime} min.`);
                                } else {
                                    setStatusMessage("‚úÖ Strat√©gie de couverture disponible!");
                                }
                                
                                if (ms.score) {
                                    setLiveData({
                                        score: `${ms.score.home ?? 0} - ${ms.score.away ?? 0}`,
                                        minute: ms.elapsed || '0',
                                        status: ms.statusLong || ms.status
                                    });
                                }
                            }
                            
                            if (trackData.tracking?.options) {
                                setEvaluatedOptions(trackData.tracking.options);
                            }
                            
                            setCheckingStatus(false);
                            return;
                        }
                    } catch (error) {
                        console.warn("Tracking error:", error);
                    }
                }

                // Fallback: utiliser l'endpoint de statut simple si on a un fixtureId
                if (fixtureId) {
                    try {
                        const response = await fetch(`${API_BASE_URL}/live/${fixtureId}/status`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            setMatchStatus(data.status);
                            setCanHedge(data.status?.canHedge || false);
                            setStatusMessage(data.status?.message || '');
                            
                            if (data.status?.score) {
                                setLiveData({
                                    score: `${data.status.score.home ?? 0} - ${data.status.score.away ?? 0}`,
                                    minute: data.status.elapsed || '0',
                                    status: data.status.statusLong || data.status.status
                                });
                            }
                            setCheckingStatus(false);
                            return;
                        }
                    } catch (error) {
                        console.warn("Status check error:", error);
                    }
                }

                // Mode d√©mo si pas de donn√©es live disponibles
                setCheckingStatus(false);
                setStatusMessage("‚ö†Ô∏è Donn√©es live non disponibles - Mode d√©mo");
                setCanHedge(true);
            };

            // Effet pour le chargement initial et le rafra√Æchissement automatique
            useEffect(() => {
                checkMatchStatus();
                
                // Rafra√Æchir automatiquement avec intervalle configurable
                let interval;
                if (autoRefresh && matchStatus?.hasStarted && !matchStatus?.isFinished) {
                    interval = setInterval(() => {
                        checkMatchStatus();
                    }, refreshInterval * 1000); // Convertir en millisecondes
                }

                return () => {
                    if (interval) clearInterval(interval);
                };
            }, [fixtureId, predictionId, autoRefresh]);

            // Initialiser les cashouts et mises r√©elles pour chaque option
            useEffect(() => {
                const initialCashouts = {};
                const initialStakes = {};
                options.forEach((opt, i) => {
                    initialCashouts[`option_${i}`] = '';
                    // Pr√©-remplir avec la mise recommand√©e par l'IA
                    initialStakes[`option_${i}`] = opt.adjustedStake || opt.stake || '';
                });
                setCashouts(initialCashouts);
                setActualStakes(initialStakes);
            }, [options.length]);

            const handleSubmit = async (withCashouts = true) => {
                // ========== V√âRIFICATION DU VERROUILLAGE ==========
                if (isAnalysisInProgress()) {
                    showNotification("‚è≥ Une analyse est d√©j√† en cours. Veuillez patienter.", "warning");
                    return;
                }
                
                if (!canHedge && matchStatus && !matchStatus.canHedge) {
                    showNotification(statusMessage || "La strat√©gie de couverture n'est pas encore disponible", "error");
                    return;
                }

                // V√©rifier que les mises sont renseign√©es
                const hasAnyStake = Object.values(actualStakes).some(v => v && v !== '' && parseFloat(v) > 0);
                if (!hasAnyStake) {
                    showNotification("Veuillez entrer vos mises r√©elles pour au moins un pari", "warning");
                    return;
                }

                if (withCashouts) {
                    const hasAnyCashout = Object.values(cashouts).some(v => v && v !== '');
                    if (!hasAnyCashout) {
                        showNotification("Entrez au moins un cashout ou cliquez sur 'Strat√©gie rapide'", "warning");
                        return;
                    }
                }
                
                // ========== ACQU√âRIR LE VERROU ==========
                const lockId = `hedging_${currentPrediction?.id}_${Date.now()}`;
                if (!acquireAnalysisLock('hedging', lockId)) {
                    showNotification("‚è≥ Impossible de lancer le calcul. Une analyse est en cours.", "warning");
                    return;
                }
                
                setCalculatingStrategy(true);
                setLoading(true);
                showNotification("üß† Analyse IA en cours (Claude + DeepSeek)...", "info");
                
                try {
                    // Obtenir un token frais
                    const token = await getValidToken();
                    if (!token) {
                        throw new Error("Session expir√©e - Reconnectez-vous");
                    }
                    
                    // Calculer le total des mises r√©elles
                    const totalActualStakes = Object.values(actualStakes).reduce((sum, v) => sum + (parseFloat(v) || 0), 0);
                    
                    // Pr√©parer les donn√©es de la requ√™te avec mises r√©elles
                    const requestData = {
                        predictionId: currentPrediction?.id,
                        options: options.map((opt, i) => ({
                            option: opt.option,
                            odds: opt.odds,
                            recommendedStake: opt.stake || opt.adjustedStake || 0, // Mise recommand√©e par l'IA
                            actualStake: actualStakes[`option_${i}`] ? parseFloat(actualStakes[`option_${i}`]) : (opt.stake || 0), // Mise r√©elle
                            cashout: withCashouts && cashouts[`option_${i}`] ? parseFloat(cashouts[`option_${i}`]) : null
                        })),
                        liveScore: {
                            home: matchStatus?.score?.home || 0,
                            away: matchStatus?.score?.away || 0,
                            elapsed: matchStatus?.elapsed || 0
                        },
                        totalActualStakes,
                        withCashouts,
                        matchInfo: currentPrediction?.matchInfo || currentPrediction?.meta
                    };
                    
                    console.log('üì° Hedging request with actual stakes:', requestData);
                    
                    const response = await fetch(`${API_BASE_URL}/hedging/strategy`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(requestData)
                    });

                    const data = await response.json();
                    console.log('üì° Hedging response:', data);

                    if (response.status === 403 && data.error === 'hedging_not_available') {
                        showNotification(data.message, "warning");
                        setCanHedge(false);
                        setStatusMessage(data.message);
                        setMatchStatus(data.matchStatus);
                    } else if (response.ok) {
                        showNotification("‚úÖ Strat√©gie calcul√©e!", "success");
                        setHedgingStrategy(data.strategy);
                        // Stocker la strat√©gie dans currentPrediction pour la page suivante
                        if (data.strategy) {
                            const updatedPrediction = {
                                ...currentPrediction, 
                                hedgingStrategy: data.strategy, 
                                hedgingStrategyGenerated: true,
                                lastHedgingAt: new Date().toISOString(),
                                hedgingLiveData: data.liveData || null,
                                isDemo: false
                            };
                            setCurrentPrediction(updatedPrediction);
                            
                            // Mettre √† jour aussi dans activePredictions pour la persistance
                            if (typeof setActivePredictions === 'function' && activePredictions) {
                                const updatedPreds = activePredictions.map(p => 
                                    p.id === currentPrediction.id ? updatedPrediction : p
                                );
                                setActivePredictions(updatedPreds);
                            }
                        }
                        navigate('coverage-strategy');
                    } else if (response.status === 401) {
                        // Token invalide - essayer de rafra√Æchir
                        console.warn("‚ö†Ô∏è Token invalide (401) - Tentative de rafra√Æchissement...");
                        showNotification("Session expir√©e, rafra√Æchissement...", "warning");
                        
                        // Forcer un rafra√Æchissement du token
                        if (firebaseAuth && firebaseAuth.currentUser) {
                            const newToken = await firebaseAuth.currentUser.getIdToken(true);
                            localStorage.setItem('authToken', newToken);
                            showNotification("Token rafra√Æchi ! R√©essayez le calcul.", "info");
                        } else {
                            throw new Error("Session expir√©e - Veuillez vous reconnecter");
                        }
                    } else {
                        throw new Error(data.error || "Erreur serveur lors du calcul de strat√©gie");
                    }
                } catch (error) {
                    // ========== PAS DE MODE DEMO - AFFICHER L'ERREUR ==========
                    console.error("‚ùå Hedging API error:", error);
                    showNotification(`‚ùå Erreur: ${error.message}. V√©rifiez votre connexion et r√©essayez.`, "error");
                } finally {
                    // ========== TOUJOURS LIB√âRER LE VERROU ==========
                    releaseAnalysisLock();
                    setCalculatingStrategy(false);
                    setLoading(false);
                }
            };

            const matchInfo = currentPrediction?.match || currentPrediction?.matchInfo || currentPrediction?.meta;

            // Composant de statut
            const StatusBanner = () => {
                if (checkingStatus) {
                    return (
                        <div className="card animate-fade-in" style={{ marginBottom: '16px', textAlign: 'center' }}>
                            <div className="spinner" style={{ margin: '0 auto 8px' }}></div>
                            <p style={{ color: 'var(--text-muted)' }}>V√©rification du statut du match...</p>
                        </div>
                    );
                }

                if (!canHedge && matchStatus && !matchStatus.canHedge) {
                    return (
                        <div className="card animate-fade-in" style={{ 
                            marginBottom: '16px', 
                            background: 'rgba(239, 68, 68, 0.1)',
                            border: '1px solid rgba(239, 68, 68, 0.3)'
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                                <span style={{ fontSize: '1.5rem' }}>‚è≥</span>
                                <h4 style={{ color: 'var(--accent-red)' }}>Strat√©gie de couverture non disponible</h4>
                            </div>
                            <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem', lineHeight: '1.5' }}>
                                {statusMessage}
                            </p>
                            {matchStatus && (
                                <div style={{ 
                                    marginTop: '12px', 
                                    padding: '8px 12px', 
                                    background: 'rgba(0,0,0,0.2)', 
                                    borderRadius: '8px',
                                    fontSize: '0.85rem'
                                }}>
                                    <span style={{ color: 'var(--text-muted)' }}>Statut: </span>
                                    <span style={{ color: 'var(--text-primary)' }}>{matchStatus.statusLong || matchStatus.status}</span>
                                    {matchStatus.elapsed > 0 && (
                                        <span style={{ marginLeft: '8px', color: 'var(--accent-gold)' }}>({matchStatus.elapsed}')</span>
                                    )}
                                </div>
                            )}
                        </div>
                    );
                }

                return (
                    <div className="card animate-fade-in" style={{ 
                        marginBottom: '16px', 
                        background: 'rgba(16, 185, 129, 0.1)',
                        border: '1px solid rgba(16, 185, 129, 0.3)'
                    }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                            <span style={{ fontSize: '1.5rem' }}>‚úÖ</span>
                            <span style={{ color: 'var(--accent-green)' }}>
                                {statusMessage || 'Strat√©gie de couverture disponible'}
                            </span>
                        </div>
                    </div>
                );
            };

            return (
                <>
                    <Header showBack={true} title="Cashouts & Live" />
                    <main className="main-content">
                        {/* Info match */}
                        {matchInfo && (
                            <div className="card animate-fade-in" style={{ marginBottom: '16px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                    <div>
                                        <h3 style={{ fontSize: '1rem' }}>{matchInfo.homeTeam} vs {matchInfo.awayTeam}</h3>
                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>{matchInfo.league}</p>
                                    </div>
                                    <div style={{ textAlign: 'right' }}>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.5rem', color: 'var(--accent-gold)' }}>
                                            {liveData.score}
                                        </div>
                                        <span style={{ 
                                            background: matchStatus?.hasStarted ? 'var(--accent-green)' : 'var(--text-muted)', 
                                            color: '#000', 
                                            padding: '2px 8px', 
                                            borderRadius: '10px',
                                            fontSize: '0.7rem'
                                        }}>
                                            {matchStatus?.hasStarted ? `‚è±Ô∏è ${liveData.minute}'` : '‚è∏Ô∏è Non commenc√©'}
                                        </span>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Banni√®re de statut */}
                        <StatusBanner />

                        {options.length === 0 ? (
                            <div className="empty-state animate-fade-in">
                                <Icons.AlertCircle />
                                <p>Aucune option s√©lectionn√©e</p>
                                <button 
                                    className="btn btn-primary" 
                                    style={{ marginTop: '16px' }}
                                    onClick={() => navigate('pronostics')}
                                >
                                    Retour aux pronostics
                                </button>
                            </div>
                        ) : (
                            <>
                                {/* Bandeau info si strat√©gie existante (pas de blocage) */}
                                {hasExistingStrategy && (
                                    <div className="card animate-fade-in" style={{ 
                                        marginBottom: '16px',
                                        background: 'rgba(139, 92, 246, 0.1)',
                                        border: '1px solid rgba(139, 92, 246, 0.3)'
                                    }}>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '10px' }}>
                                            <span style={{ fontSize: '1.3rem' }}>üìä</span>
                                            <h4 style={{ color: '#a78bfa', margin: 0 }}>Strat√©gie pr√©c√©dente disponible</h4>
                                        </div>
                                        <p style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', marginBottom: '12px' }}>
                                            Derni√®re recommandation: <strong style={{ color: 'var(--accent-gold)' }}>
                                                {(currentPrediction?.hedgingStrategy?.recommendedStrategy || currentPrediction?.hedgingStrategy?.recommendation || 'analyse').toUpperCase()}
                                            </strong>
                                            {currentPrediction?.lastHedgingAt && (
                                                <span style={{ marginLeft: '8px', fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                                    ({new Date(currentPrediction.lastHedgingAt).toLocaleTimeString('fr-FR')})
                                                </span>
                                            )}
                                        </p>
                                        <button 
                                            className="btn btn-secondary"
                                            style={{ width: '100%', padding: '10px' }}
                                            onClick={() => navigate('coverage-strategy')}
                                        >
                                            <Icons.Eye /> Voir les d√©tails de la strat√©gie
                                        </button>
                                    </div>
                                )}

                                {/* Section Suivi Live des Options - VERSION AM√âLIOR√âE */}
                                {matchStatus?.hasStarted && (
                                    <div className="card animate-fade-in" style={{ 
                                        marginBottom: '16px',
                                        background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%)',
                                        border: '1px solid rgba(59, 130, 246, 0.3)'
                                    }}>
                                        {/* Header avec contr√¥les */}
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                            <h4 style={{ color: 'var(--accent-blue)', display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                üî¥ Suivi Live
                                                {autoRefresh && <span style={{ 
                                                    width: '8px', height: '8px', 
                                                    borderRadius: '50%', 
                                                    background: 'var(--accent-green)',
                                                    animation: 'pulse 2s infinite'
                                                }}></span>}
                                            </h4>
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                                <select 
                                                    value={refreshInterval}
                                                    onChange={(e) => setRefreshInterval(parseInt(e.target.value))}
                                                    style={{ 
                                                        background: 'var(--bg-secondary)', 
                                                        border: '1px solid var(--border-color)',
                                                        borderRadius: '6px',
                                                        padding: '4px 8px',
                                                        fontSize: '0.7rem',
                                                        color: 'var(--text-secondary)'
                                                    }}
                                                >
                                                    <option value={15}>15s</option>
                                                    <option value={30}>30s</option>
                                                    <option value={60}>1min</option>
                                                </select>
                                                <label style={{ display: 'flex', alignItems: 'center', gap: '6px', fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                                    <input 
                                                        type="checkbox" 
                                                        checked={autoRefresh} 
                                                        onChange={(e) => setAutoRefresh(e.target.checked)}
                                                        style={{ accentColor: 'var(--accent-gold)' }}
                                                    />
                                                    Auto
                                                </label>
                                            </div>
                                        </div>
                                        
                                        {/* Statut Global de la Pr√©diction */}
                                        {globalStatus && (
                                            <div style={{
                                                padding: '12px',
                                                marginBottom: '12px',
                                                borderRadius: '10px',
                                                background: globalStatus.status === 'favorable' || globalStatus.status === 'won' || globalStatus.status === 'partial_win' 
                                                    ? 'rgba(16, 185, 129, 0.15)' 
                                                    : globalStatus.status === 'unfavorable' || globalStatus.status === 'lost' || globalStatus.status === 'partial_loss'
                                                    ? 'rgba(239, 68, 68, 0.15)'
                                                    : 'rgba(245, 158, 11, 0.15)',
                                                border: `1px solid ${globalStatus.status === 'favorable' || globalStatus.status === 'won' || globalStatus.status === 'partial_win' 
                                                    ? 'rgba(16, 185, 129, 0.3)' 
                                                    : globalStatus.status === 'unfavorable' || globalStatus.status === 'lost' || globalStatus.status === 'partial_loss'
                                                    ? 'rgba(239, 68, 68, 0.3)'
                                                    : 'rgba(245, 158, 11, 0.3)'}`
                                            }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                                                        <span style={{ fontSize: '1.5rem' }}>{globalStatus.emoji}</span>
                                                        <div>
                                                            <div style={{ fontWeight: '600', fontSize: '0.95rem' }}>{globalStatus.message}</div>
                                                            <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                                                {globalStatus.won > 0 && `‚úÖ ${globalStatus.won} gagn√©(s)`}
                                                                {globalStatus.winning > 0 && ` üìà ${globalStatus.winning} en gain`}
                                                                {globalStatus.pending > 0 && ` ‚è≥ ${globalStatus.pending} en attente`}
                                                                {globalStatus.losing > 0 && ` üìâ ${globalStatus.losing} en perte`}
                                                                {globalStatus.lost > 0 && ` ‚ùå ${globalStatus.lost} perdu(s)`}
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div style={{ 
                                                        padding: '8px 14px',
                                                        borderRadius: '20px',
                                                        background: 'rgba(255,255,255,0.1)',
                                                        textAlign: 'center'
                                                    }}>
                                                        <div style={{ fontSize: '1.3rem', fontWeight: '700', fontFamily: 'Space Mono' }}>
                                                            {globalStatus.avgProbability}%
                                                        </div>
                                                        <div style={{ fontSize: '0.65rem', color: 'var(--text-muted)' }}>Prob. r√©ussite</div>
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                        
                                        {/* √âv√©nements du Match */}
                                        {liveEvents.length > 0 && (
                                            <div style={{ marginBottom: '12px' }}>
                                                <div 
                                                    style={{ 
                                                        display: 'flex', 
                                                        justifyContent: 'space-between', 
                                                        alignItems: 'center',
                                                        cursor: 'pointer',
                                                        marginBottom: '8px'
                                                    }}
                                                    onClick={() => setShowEvents(!showEvents)}
                                                >
                                                    <span style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                        ‚öΩ √âv√©nements ({liveEvents.length})
                                                    </span>
                                                    <span style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>
                                                        {showEvents ? '‚ñº' : '‚ñ∂'}
                                                    </span>
                                                </div>
                                                {showEvents && (
                                                    <div style={{ 
                                                        maxHeight: '120px', 
                                                        overflowY: 'auto',
                                                        background: 'rgba(0,0,0,0.2)',
                                                        borderRadius: '8px',
                                                        padding: '8px'
                                                    }}>
                                                        {liveEvents.map((event, idx) => (
                                                            <div key={idx} style={{
                                                                display: 'flex',
                                                                alignItems: 'center',
                                                                gap: '8px',
                                                                padding: '4px 0',
                                                                borderBottom: idx < liveEvents.length - 1 ? '1px solid rgba(255,255,255,0.1)' : 'none',
                                                                fontSize: '0.75rem'
                                                            }}>
                                                                <span style={{ 
                                                                    fontFamily: 'Space Mono', 
                                                                    color: 'var(--accent-gold)',
                                                                    minWidth: '30px'
                                                                }}>
                                                                    {event.time}'
                                                                </span>
                                                                <span style={{ fontSize: '1rem' }}>
                                                                    {event.type === 'Goal' ? '‚öΩ' : 
                                                                     event.type === 'Card' && event.detail === 'Yellow Card' ? 'üü®' :
                                                                     event.type === 'Card' && event.detail === 'Red Card' ? 'üü•' :
                                                                     event.type === 'subst' ? 'üîÑ' :
                                                                     event.type === 'Var' ? 'üì∫' : 'üìã'}
                                                                </span>
                                                                <span style={{ color: 'var(--text-secondary)', flex: 1 }}>
                                                                    {event.player} ({event.team})
                                                                </span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                        
                                        {/* Options avec √©volution des cotes */}
                                        {evaluatedOptions.map((evalOpt, index) => {
                                            const getStatusStyle = (status) => {
                                                switch(status) {
                                                    case 'won': return { bg: 'rgba(16, 185, 129, 0.25)', color: 'var(--accent-green)', icon: '‚úÖ', text: 'GAGN√â' };
                                                    case 'winning': return { bg: 'rgba(16, 185, 129, 0.15)', color: '#34d399', icon: 'üìà', text: 'En gain' };
                                                    case 'lost': return { bg: 'rgba(239, 68, 68, 0.25)', color: 'var(--accent-red)', icon: '‚ùå', text: 'PERDU' };
                                                    case 'losing': return { bg: 'rgba(239, 68, 68, 0.15)', color: '#f87171', icon: 'üìâ', text: 'En perte' };
                                                    default: return { bg: 'rgba(245, 158, 11, 0.15)', color: 'var(--accent-gold)', icon: '‚è≥', text: 'En cours' };
                                                }
                                            };
                                            const style = getStatusStyle(evalOpt.currentStatus);
                                            
                                            // √âvolution des cotes
                                            const oddsChange = evalOpt.oddsChange;
                                            const hasOddsChange = oddsChange && oddsChange.isSignificant;
                                            
                                            return (
                                                <div key={index} style={{
                                                    padding: '12px',
                                                    marginBottom: index < evaluatedOptions.length - 1 ? '10px' : 0,
                                                    background: style.bg,
                                                    borderRadius: '10px'
                                                }}>
                                                    {/* Ligne 1: Nom et Statut */}
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                                                        <div style={{ fontWeight: '600', fontSize: '0.9rem' }}>{evalOpt.option}</div>
                                                        <div style={{ 
                                                            display: 'flex', 
                                                            alignItems: 'center', 
                                                            gap: '6px',
                                                            padding: '4px 10px',
                                                            borderRadius: '15px',
                                                            background: 'rgba(0,0,0,0.2)',
                                                            color: style.color,
                                                            fontWeight: '600',
                                                            fontSize: '0.8rem'
                                                        }}>
                                                            <span>{style.icon}</span>
                                                            <span>{style.text}</span>
                                                        </div>
                                                    </div>
                                                    
                                                    {/* Ligne 2: Cotes avec √©volution */}
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>Cote:</span>
                                                            <span style={{ 
                                                                fontFamily: 'Space Mono', 
                                                                color: 'var(--text-muted)',
                                                                textDecoration: hasOddsChange ? 'line-through' : 'none',
                                                                fontSize: '0.8rem'
                                                            }}>
                                                                {(evalOpt.originalOdds || evalOpt.odds)?.toFixed(2)}
                                                            </span>
                                                            {hasOddsChange && (
                                                                <>
                                                                    <span style={{ color: 'var(--text-muted)' }}>‚Üí</span>
                                                                    <span style={{ 
                                                                        fontFamily: 'Space Mono', 
                                                                        fontWeight: '700',
                                                                        fontSize: '0.9rem',
                                                                        color: oddsChange.direction === 'down' ? 'var(--accent-green)' : 
                                                                               oddsChange.direction === 'up' ? 'var(--accent-red)' : 'var(--text-primary)'
                                                                    }}>
                                                                        {evalOpt.currentOdds?.toFixed(2)}
                                                                    </span>
                                                                    <span style={{ 
                                                                        fontSize: '0.7rem',
                                                                        padding: '2px 6px',
                                                                        borderRadius: '8px',
                                                                        background: oddsChange.direction === 'down' ? 'rgba(16, 185, 129, 0.2)' : 
                                                                                   oddsChange.direction === 'up' ? 'rgba(239, 68, 68, 0.2)' : 'transparent',
                                                                        color: oddsChange.direction === 'down' ? 'var(--accent-green)' : 
                                                                               oddsChange.direction === 'up' ? 'var(--accent-red)' : 'var(--text-muted)'
                                                                    }}>
                                                                        {oddsChange.direction === 'down' ? '‚ñº' : oddsChange.direction === 'up' ? '‚ñ≤' : '='} 
                                                                        {Math.abs(oddsChange.percentageChange)}%
                                                                    </span>
                                                                </>
                                                            )}
                                                        </div>
                                                        
                                                        {/* Probabilit√© dynamique */}
                                                        <div style={{ 
                                                            display: 'flex', 
                                                            alignItems: 'center', 
                                                            gap: '6px',
                                                            padding: '4px 10px',
                                                            borderRadius: '12px',
                                                            background: 'rgba(139, 92, 246, 0.2)'
                                                        }}>
                                                            <span style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Prob:</span>
                                                            <span style={{ 
                                                                fontFamily: 'Space Mono', 
                                                                fontWeight: '700',
                                                                color: 'var(--accent-purple)',
                                                                fontSize: '0.9rem'
                                                            }}>
                                                                {evalOpt.dynamicProbability || evalOpt.probability || 50}%
                                                            </span>
                                                            {evalOpt.probabilityTrend && (
                                                                <span style={{ fontSize: '0.8rem' }}>
                                                                    {evalOpt.probabilityTrend === 'up' ? 'üìà' : 
                                                                     evalOpt.probabilityTrend === 'down' ? 'üìâ' : ''}
                                                                </span>
                                                            )}
                                                        </div>
                                                    </div>
                                                    
                                                    {/* Ligne 3: Mise et Gain potentiel */}
                                                    <div style={{ 
                                                        display: 'flex', 
                                                        justifyContent: 'space-between',
                                                        fontSize: '0.75rem',
                                                        color: 'var(--text-muted)',
                                                        paddingTop: '8px',
                                                        borderTop: '1px solid rgba(255,255,255,0.1)'
                                                    }}>
                                                        <span>
                                                            Mise: <strong style={{ color: 'var(--accent-gold)' }}>
                                                                {(evalOpt.stake || evalOpt.adjustedStake || 0).toLocaleString()} F
                                                            </strong>
                                                        </span>
                                                        <span>
                                                            Gain: <strong style={{ color: 'var(--accent-green)' }}>
                                                                +{Math.round((evalOpt.stake || 0) * ((evalOpt.currentOdds || evalOpt.odds || 1.5) - 1)).toLocaleString()} F
                                                            </strong>
                                                        </span>
                                                    </div>
                                                    
                                                    {/* Suggestion de recalcul si cotes chang√©es significativement */}
                                                    {hasOddsChange && evalOpt.suggestedStake && (
                                                        <div style={{
                                                            marginTop: '8px',
                                                            padding: '8px',
                                                            background: 'rgba(245, 158, 11, 0.1)',
                                                            borderRadius: '6px',
                                                            fontSize: '0.7rem',
                                                            color: 'var(--accent-gold)'
                                                        }}>
                                                            üí° Nouvelle mise sugg√©r√©e: <strong>{evalOpt.suggestedStake.recommendedStake?.toLocaleString()} F</strong>
                                                            {' '}(Kelly: {evalOpt.suggestedStake.kellyPercentage}%)
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })}
                                        
                                        {/* Footer avec derni√®re mise √† jour */}
                                        <div style={{ 
                                            marginTop: '12px', 
                                            display: 'flex',
                                            justifyContent: 'space-between',
                                            alignItems: 'center',
                                            fontSize: '0.7rem', 
                                            color: 'var(--text-muted)'
                                        }}>
                                            <span>
                                                {lastRefresh ? `Mise √† jour: ${lastRefresh.toLocaleTimeString('fr-FR')}` : ''}
                                            </span>
                                            <button 
                                                onClick={checkMatchStatus}
                                                style={{
                                                    background: 'rgba(59, 130, 246, 0.2)',
                                                    border: '1px solid rgba(59, 130, 246, 0.3)',
                                                    borderRadius: '6px',
                                                    padding: '4px 10px',
                                                    color: 'var(--accent-blue)',
                                                    cursor: 'pointer',
                                                    fontSize: '0.7rem'
                                                }}
                                            >
                                                üîÑ Actualiser
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {/* Formulaire de Mises et Cashouts */}
                                <h4 style={{ marginBottom: '8px', marginTop: '16px' }}>üí∞ Vos paris et cashouts</h4>
                                <p style={{ 
                                    fontSize: '0.75rem', 
                                    color: 'var(--text-muted)', 
                                    marginBottom: '12px',
                                    lineHeight: '1.4'
                                }}>
                                    Entrez vos <strong>mises r√©elles</strong> et les <strong>cashouts propos√©s</strong> par votre bookmaker. 
                                    L'IA calculera les meilleures strat√©gies de couverture.
                                </p>
                                {options.map((opt, index) => {
                                    const recommendedStake = opt.adjustedStake || opt.stake || 0;
                                    const actualStake = actualStakes[`option_${index}`] ? parseFloat(actualStakes[`option_${index}`]) : recommendedStake;
                                    const cashoutValue = cashouts[`option_${index}`] ? parseFloat(cashouts[`option_${index}`]) : 0;
                                    const potentialReturn = actualStake * (opt.odds || 1.5);
                                    const potentialProfit = potentialReturn - actualStake;
                                    
                                    // Trouver l'option √©valu√©e correspondante
                                    const evalOpt = evaluatedOptions.find(e => e.option === opt.option);
                                    const statusBadge = evalOpt?.currentStatus ? (
                                        <span style={{
                                            padding: '2px 6px',
                                            borderRadius: '8px',
                                            fontSize: '0.65rem',
                                            marginLeft: '8px',
                                            background: evalOpt.currentStatus === 'won' || evalOpt.currentStatus === 'winning' ? 'rgba(16, 185, 129, 0.2)' :
                                                       evalOpt.currentStatus === 'lost' || evalOpt.currentStatus === 'losing' ? 'rgba(239, 68, 68, 0.2)' : 'rgba(245, 158, 11, 0.2)',
                                            color: evalOpt.currentStatus === 'won' || evalOpt.currentStatus === 'winning' ? 'var(--accent-green)' :
                                                   evalOpt.currentStatus === 'lost' || evalOpt.currentStatus === 'losing' ? 'var(--accent-red)' : 'var(--accent-gold)'
                                        }}>
                                            {evalOpt.currentStatus === 'won' ? '‚úÖ Gagn√©' : 
                                             evalOpt.currentStatus === 'winning' ? 'üìà En gain' :
                                             evalOpt.currentStatus === 'lost' ? '‚ùå Perdu' :
                                             evalOpt.currentStatus === 'losing' ? 'üìâ En perte' : '‚è≥ En cours'}
                                        </span>
                                    ) : null;
                                    
                                    return (
                                        <div key={index} className={`card animate-fade-in delay-${index + 1}`} style={{ marginBottom: '12px', padding: '14px' }}>
                                            {/* Titre de l'option */}
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
                                                <div style={{ flex: 1 }}>
                                                    <span style={{ fontWeight: '600', fontSize: '0.9rem' }}>{opt.option}</span>
                                                    {statusBadge}
                                                </div>
                                                <span style={{ 
                                                    padding: '3px 8px', 
                                                    background: 'rgba(245, 158, 11, 0.2)', 
                                                    borderRadius: '6px',
                                                    fontFamily: 'Space Mono',
                                                    fontSize: '0.85rem',
                                                    color: 'var(--accent-gold)'
                                                }}>
                                                    @{(opt.odds || 1.5).toFixed(2)}
                                                </span>
                                            </div>
                                            
                                            {/* Grille des inputs */}
                                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px' }}>
                                                {/* Mise r√©elle */}
                                                <div>
                                                    <label style={{ fontSize: '0.7rem', color: 'var(--text-muted)', display: 'block', marginBottom: '4px' }}>
                                                        üíµ Mise r√©elle (FCFA)
                                                    </label>
                                                    <input
                                                        type="number"
                                                        className="input"
                                                        placeholder={`Ex: ${recommendedStake}`}
                                                        value={actualStakes[`option_${index}`] || ''}
                                                        onChange={(e) => setActualStakes({...actualStakes, [`option_${index}`]: e.target.value})}
                                                        style={{ fontSize: '1rem', padding: '10px', fontFamily: 'Space Mono' }}
                                                    />
                                                    {recommendedStake > 0 && (
                                                        <div style={{ fontSize: '0.65rem', color: 'var(--text-muted)', marginTop: '2px' }}>
                                                            Recommand√©: {recommendedStake.toLocaleString()} F
                                                        </div>
                                                    )}
                                                </div>
                                                
                                                {/* Cashout propos√© */}
                                                <div>
                                                    <label style={{ fontSize: '0.7rem', color: 'var(--text-muted)', display: 'block', marginBottom: '4px' }}>
                                                        üè¶ Cashout propos√© (FCFA)
                                                    </label>
                                                    <input
                                                        type="number"
                                                        className="input"
                                                        placeholder={`Ex: ${Math.round(actualStake * 0.85)}`}
                                                        value={cashouts[`option_${index}`] || ''}
                                                        onChange={(e) => setCashouts({...cashouts, [`option_${index}`]: e.target.value})}
                                                        style={{ fontSize: '1rem', padding: '10px', fontFamily: 'Space Mono' }}
                                                    />
                                                    <div style={{ fontSize: '0.65rem', color: 'var(--text-muted)', marginTop: '2px' }}>
                                                        Optionnel
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            {/* R√©sum√© des gains/pertes potentiels */}
                                            {actualStake > 0 && (
                                                <div style={{ 
                                                    marginTop: '10px', 
                                                    padding: '8px', 
                                                    background: 'rgba(0,0,0,0.2)', 
                                                    borderRadius: '6px',
                                                    display: 'grid',
                                                    gridTemplateColumns: '1fr 1fr 1fr',
                                                    gap: '8px',
                                                    fontSize: '0.75rem'
                                                }}>
                                                    <div>
                                                        <div style={{ color: 'var(--text-muted)' }}>Retour si gagn√©</div>
                                                        <div style={{ fontFamily: 'Space Mono', color: 'var(--accent-green)', fontWeight: '600' }}>
                                                            +{Math.round(potentialReturn).toLocaleString()} F
                                                        </div>
                                                    </div>
                                                    <div>
                                                        <div style={{ color: 'var(--text-muted)' }}>Profit net</div>
                                                        <div style={{ fontFamily: 'Space Mono', color: 'var(--accent-green)', fontWeight: '600' }}>
                                                            +{Math.round(potentialProfit).toLocaleString()} F
                                                        </div>
                                                    </div>
                                                    <div>
                                                        <div style={{ color: 'var(--text-muted)' }}>Si perdu</div>
                                                        <div style={{ fontFamily: 'Space Mono', color: 'var(--accent-red)', fontWeight: '600' }}>
                                                            -{Math.round(actualStake).toLocaleString()} F
                                                        </div>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                                
                                {/* Total des mises */}
                                {Object.values(actualStakes).some(v => v && parseFloat(v) > 0) && (
                                    <div style={{ 
                                        padding: '12px', 
                                        background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%)',
                                        borderRadius: '10px',
                                        marginBottom: '16px',
                                        border: '1px solid rgba(59, 130, 246, 0.3)'
                                    }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                                            <span style={{ color: 'var(--text-secondary)' }}>üí∞ Total mis√©:</span>
                                            <span style={{ fontFamily: 'Space Mono', fontWeight: '700' }}>
                                                {Object.values(actualStakes).reduce((sum, v) => sum + (parseFloat(v) || 0), 0).toLocaleString()} FCFA
                                            </span>
                                        </div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                                            <span style={{ color: 'var(--text-secondary)' }}>üìä Total cashouts:</span>
                                            <span style={{ fontFamily: 'Space Mono', fontWeight: '700', color: 'var(--accent-gold)' }}>
                                                {Object.values(cashouts).reduce((sum, v) => sum + (parseFloat(v) || 0), 0).toLocaleString()} FCFA
                                            </span>
                                        </div>
                                    </div>
                                )}

                                {/* Donn√©es live */}
                                <div className="card animate-fade-in" style={{ marginTop: '16px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                                        <h4 style={{ color: 'var(--accent-blue)' }}>üìä Statut du Match</h4>
                                        <span style={{ 
                                            fontSize: '0.7rem', 
                                            padding: '4px 8px', 
                                            borderRadius: '8px',
                                            background: matchStatus?.hasStarted ? 'rgba(16, 185, 129, 0.2)' : 'rgba(107, 114, 128, 0.2)',
                                            color: matchStatus?.hasStarted ? 'var(--accent-green)' : 'var(--text-muted)'
                                        }}>
                                            {liveData.status || (matchStatus?.hasStarted ? 'En cours' : 'Non commenc√©')}
                                        </span>
                                    </div>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
                                        <div>
                                            <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem' }}>Score</span>
                                            <div style={{ fontFamily: 'Space Mono', fontSize: '1.2rem', color: 'var(--accent-gold)' }}>{liveData.score}</div>
                                        </div>
                                        <div>
                                            <span style={{ color: 'var(--text-muted)', fontSize: '0.75rem' }}>Temps</span>
                                            <div style={{ fontFamily: 'Space Mono', fontSize: '1.2rem' }}>{liveData.minute}'</div>
                                        </div>
                                    </div>
                                    {fixtureId && (
                                        <div style={{ marginTop: '12px', fontSize: '0.7rem', color: 'var(--text-muted)' }}>
                                            Match ID: {fixtureId} ‚Ä¢ Donn√©es via API-Football
                                        </div>
                                    )}
                                </div>

                                {/* Boutons d'action */}
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '12px', marginTop: '20px' }}>
                                    {/* Bouton Strat√©gie rapide (sans cashouts) */}
                                    <button 
                                        className={`btn ${canHedge ? 'btn-primary' : 'btn-secondary'} animate-fade-in`}
                                        style={{ width: '100%', opacity: canHedge ? 1 : 0.5 }}
                                        onClick={() => handleSubmit(false)}
                                        disabled={calculatingStrategy || (!canHedge && matchStatus && !matchStatus.canHedge)}
                                    >
                                        {calculatingStrategy ? 'üß† Calcul en cours...' : (canHedge ? '‚ö° Strat√©gie rapide (IA)' : 'En attente du match...')}
                                        {!calculatingStrategy && <Icons.Zap />}
                                    </button>
                                    
                                    {/* Bouton avec cashouts */}
                                    <button 
                                        className={`btn btn-secondary animate-fade-in`}
                                        style={{ width: '100%', opacity: canHedge ? 1 : 0.5 }}
                                        onClick={() => handleSubmit(true)}
                                        disabled={calculatingStrategy || (!canHedge && matchStatus && !matchStatus.canHedge)}
                                    >
                                        {calculatingStrategy ? 'üß† Calcul...' : 'üí∞ Calculer avec cashouts'}
                                        {!calculatingStrategy && <Icons.Calculator />}
                                    </button>
                                </div>

                                <p style={{ 
                                    fontSize: '0.75rem', 
                                    color: 'var(--text-muted)', 
                                    textAlign: 'center', 
                                    marginTop: '12px' 
                                }}>
                                    üí° "Strat√©gie rapide" analyse vos paris sans cashouts. 
                                    Pour une analyse personnalis√©e, entrez les valeurs de cashout propos√©es par votre bookmaker.
                                </p>
                            </>
                        )}
                    </main>
                    <BottomNav />
                    {(loading || calculatingStrategy) && <LoadingOverlay text="üõ°Ô∏è Analyse de couverture avec Claude..." />}
                </>
            );
        };

        const CoverageStrategyPage = () => {
            const { navigate, currentPrediction, selectedOptions, showNotification, API_BASE_URL, getValidToken } = useApp();
            const [selectedStrategy, setSelectedStrategy] = useState(null);
            const [expandedStrategy, setExpandedStrategy] = useState(null);
            
            // ========== NOUVEAUX √âTATS POUR LE SUIVI LIVE ==========
            const [liveOddsData, setLiveOddsData] = useState(null);
            const [isRefreshing, setIsRefreshing] = useState(false);
            const [lastOddsUpdate, setLastOddsUpdate] = useState(null);
            const [autoRefreshOdds, setAutoRefreshOdds] = useState(true);
            const [oddsChanges, setOddsChanges] = useState({}); // Stocke les changements de cotes
            const [recalculatedStrategies, setRecalculatedStrategies] = useState(null);
            
            // ========== √âTATS POUR LA MODAL BREAK-EVEN MANUEL ==========
            const [showBreakEvenModal, setShowBreakEvenModal] = useState(false);
            const [breakEvenBets, setBreakEvenBets] = useState([{ option: '', stake: '', odds: '' }]);
            const [breakEvenHedgeOptions, setBreakEvenHedgeOptions] = useState([{ type: '', odds: '' }]);
            const [breakEvenResult, setBreakEvenResult] = useState(null);
            const [calculatingBreakEven, setCalculatingBreakEven] = useState(false);
            
            const matchInfo = currentPrediction?.match || currentPrediction?.matchInfo || currentPrediction?.meta;
            const fixtureId = currentPrediction?.matchInfo?.fixtureId || currentPrediction?.meta?.matchId || currentPrediction?.opportunityId;
            const bookmaker = currentPrediction?.bookmaker || currentPrediction?.selectedBookmaker?.key || '1xbet';
            
            // R√©cup√©rer la strat√©gie g√©n√©r√©e (nouveau format avec multiples strat√©gies)
            const strategyData = recalculatedStrategies || currentPrediction?.hedgingStrategy;
            const strategies = strategyData?.strategies || [];
            const optionsStatus = strategyData?.optionsStatus || [];
            const matchAnalysis = strategyData?.matchAnalysis;
            const recommendedStrategyId = strategyData?.recommendedStrategy;
            
            // ========== NOUVEAUX: V√©rifier si strat√©gie optimale trouv√©e ==========
            const optimalStrategyFound = strategyData?.optimalStrategyFound ?? false;
            const optimalStrategyReason = strategyData?.optimalStrategyReason || '';
            const breakEvenFallback = strategyData?.breakEvenFallback;
            const optimalStrategy = strategies.find(s => s.id === 'optimal');
            
            // Options depuis la strat√©gie ou fallback
            const strategyOptions = strategyData?.options || [];
            const options = strategyOptions.length > 0 
                ? strategyOptions
                : (selectedOptions.length > 0 
                    ? selectedOptions 
                    : currentPrediction?.stakes?.stakes || []);
            
            // Calcul des totaux
            const totalStake = options.reduce((sum, opt) => sum + (opt.stake || opt.adjustedStake || 0), 0);
            const totalPotentialProfit = options.reduce((sum, opt) => sum + (opt.potentialProfit || Math.round((opt.stake || 0) * ((opt.odds || 1.5) - 1))), 0);
            const totalCashout = options.reduce((sum, opt) => sum + (opt.cashoutValue || opt.cashout || 0), 0);

            // ========== INITIALISER LES PARIS POUR BREAK-EVEN ==========
            // Charger les options existantes quand la modal s'ouvre
            useEffect(() => {
                if (showBreakEvenModal && options.length > 0) {
                    // Pr√©-remplir avec les paris existants s'ils ont des valeurs
                    const existingBets = options.filter(opt => opt.stake || opt.actualStake).map(opt => ({
                        option: opt.option || opt.name || '',
                        stake: opt.stake || opt.actualStake || '',
                        odds: opt.odds || ''
                    }));
                    if (existingBets.length > 0) {
                        setBreakEvenBets(existingBets);
                    }
                }
            }, [showBreakEvenModal]);

            // ========== AJOUTER/SUPPRIMER PARIS ORIGINAUX ==========
            const addBet = () => {
                setBreakEvenBets([...breakEvenBets, { option: '', stake: '', odds: '' }]);
            };
            
            const removeBet = (index) => {
                if (breakEvenBets.length > 1) {
                    setBreakEvenBets(breakEvenBets.filter((_, i) => i !== index));
                }
            };

            // ========== FONCTION DE CALCUL BREAK-EVEN MANUEL ==========
            const calculateManualBreakEven = async () => {
                // Valider les donn√©es - convertir en nombres
                const validBets = breakEvenBets
                    .map(b => ({
                        option: b.option || 'Pari',
                        stake: parseFloat(b.stake) || 0,
                        odds: parseFloat(b.odds) || 0
                    }))
                    .filter(b => b.stake > 0 && b.odds >= 1);
                    
                const validHedges = breakEvenHedgeOptions
                    .map(h => ({
                        type: h.type || 'Hedge',
                        odds: parseFloat(h.odds) || 0
                    }))
                    .filter(h => h.odds >= 1);
                
                console.log('üìä Break-even validation:', { validBets, validHedges, breakEvenBets, breakEvenHedgeOptions });
                
                if (validBets.length === 0) {
                    showNotification('Veuillez renseigner au moins un pari avec une mise et une cote valide', 'error');
                    return;
                }
                if (validHedges.length === 0) {
                    showNotification('Veuillez renseigner au moins une option de couverture avec une cote valide', 'error');
                    return;
                }
                
                setCalculatingBreakEven(true);
                try {
                    const token = await getValidToken();
                    const response = await fetch(`${API_BASE_URL}/hedging/breakeven-calculate`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            bets: validBets,
                            hedgeOptions: validHedges
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.success) {
                        setBreakEvenResult(data);
                        showNotification('Calcul break-even effectu√©!', 'success');
                    } else {
                        showNotification(data.error || 'Erreur lors du calcul', 'error');
                    }
                } catch (error) {
                    console.error('Break-even calculation error:', error);
                    showNotification('Erreur de calcul', 'error');
                } finally {
                    setCalculatingBreakEven(false);
                }
            };

            // ========== AJOUTER/SUPPRIMER OPTIONS DE HEDGE ==========
            const addHedgeOption = () => {
                setBreakEvenHedgeOptions([...breakEvenHedgeOptions, { type: '', odds: '' }]);
            };
            
            const removeHedgeOption = (index) => {
                if (breakEvenHedgeOptions.length > 1) {
                    setBreakEvenHedgeOptions(breakEvenHedgeOptions.filter((_, i) => i !== index));
                }
            };
            
            const updateHedgeOption = (index, field, value) => {
                const updated = [...breakEvenHedgeOptions];
                updated[index][field] = value; // Garder la valeur brute
                setBreakEvenHedgeOptions(updated);
            };
            
            const updateBet = (index, field, value) => {
                const updated = [...breakEvenBets];
                updated[index][field] = value; // Garder la valeur brute
                setBreakEvenBets(updated);
            };

            // ========== FONCTION DE R√âCUP√âRATION DES COTES LIVE ==========
            const fetchLiveOdds = async () => {
                if (!fixtureId) return;
                
                setIsRefreshing(true);
                try {
                    const token = await getValidToken();
                    if (!token) return;
                    
                    // Utiliser le nouvel endpoint de live-tracking
                    const response = await fetch(`${API_BASE_URL}/predictions/${currentPrediction?.id}/live-tracking`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('üìä Live tracking data for coverage:', data);
                        
                        if (data.tracking?.liveOdds) {
                            setLiveOddsData(data.tracking.liveOdds);
                            setLastOddsUpdate(new Date());
                            
                            // Calculer les changements de cotes
                            const changes = {};
                            if (data.tracking?.options) {
                                data.tracking.options.forEach(opt => {
                                    if (opt.oddsChange?.isSignificant) {
                                        changes[opt.option] = {
                                            original: opt.originalOdds,
                                            current: opt.currentOdds,
                                            change: opt.oddsChange
                                        };
                                    }
                                });
                            }
                            setOddsChanges(changes);
                            
                            // R√©cup√©rer les cotes de couverture
                            const hedgingOdds = data.tracking?.hedgingOdds;
                            
                            // Recalculer les strat√©gies avec les nouvelles cotes
                            if (data.tracking?.options || hedgingOdds) {
                                await recalculateStrategiesWithNewOdds(
                                    data.tracking.options, 
                                    data.tracking.matchStatus,
                                    hedgingOdds
                                );
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error fetching live odds:', error);
                } finally {
                    setIsRefreshing(false);
                }
            };
            
            // ========== RECALCUL DES STRAT√âGIES AVEC NOUVELLES COTES ==========
            const recalculateStrategiesWithNewOdds = async (updatedOptions, matchStatus, hedgingOdds) => {
                if (!strategyData) return;
                
                console.log('üîÑ Recalculating strategies with new odds:', { updatedOptions, hedgingOdds });
                
                // Mettre √† jour les options avec les nouvelles cotes
                const updatedStrategies = { ...strategyData };
                
                // Recalculer les mises pour chaque strat√©gie
                updatedStrategies.strategies = strategies.map(strat => {
                    const newStrat = { ...strat };
                    
                    // Recalculer les actions de hedge avec les nouvelles cotes
                    if (strat.hedgeRequired && (strat.hedgeBet || strat.hedgeOdds)) {
                        const hedgeBetType = typeof strat.hedgeBet === 'string' ? strat.hedgeBet : strat.hedgeBet?.type;
                        const originalOdds = typeof strat.hedgeBet === 'object' ? strat.hedgeBet.odds : strat.hedgeOdds;
                        const originalStake = typeof strat.hedgeBet === 'object' ? strat.hedgeBet.stake : strat.hedgeStake;
                        
                        // Trouver la nouvelle cote dans hedgingOdds
                        const newOdds = findLiveOddsForBet(hedgeBetType, hedgingOdds);
                        
                        if (newOdds && originalOdds && Math.abs(newOdds - originalOdds) > 0.05) {
                            // Recalculer la mise pour garder le m√™me retour potentiel
                            const originalReturn = originalStake * originalOdds;
                            const newStake = Math.ceil(originalReturn / newOdds);
                            
                            newStrat.hedgeBet = {
                                type: hedgeBetType,
                                originalOdds: originalOdds,
                                odds: newOdds,
                                originalStake: originalStake,
                                stake: newStake,
                                oddsChanged: true,
                                changeDirection: newOdds > originalOdds ? 'up' : 'down',
                                changePercent: Math.round(((newOdds - originalOdds) / originalOdds) * 100)
                            };
                            
                            newStrat.hedgeOdds = newOdds;
                            newStrat.hedgeStake = newStake;
                            
                            // Recalculer les sc√©narios
                            newStrat.scenarios = recalculateScenarios(strat, newStake, newOdds, totalStake);
                        }
                    }
                    
                    return newStrat;
                });
                
                // Mettre √† jour le statut des options
                if (updatedOptions) {
                    updatedStrategies.optionsStatus = updatedOptions.map(opt => ({
                        option: opt.option,
                        status: opt.currentStatus,
                        originalOdds: opt.originalOdds,
                        currentOdds: opt.currentOdds,
                        oddsChanged: opt.oddsChange?.isSignificant,
                        probability: opt.dynamicProbability / 100,
                        analysis: `Prob: ${opt.dynamicProbability}% | Cote: ${opt.currentOdds?.toFixed(2) || opt.odds?.toFixed(2)}`
                    }));
                    
                    // Mettre √† jour les options principales aussi
                    updatedStrategies.options = updatedOptions;
                }
                
                setRecalculatedStrategies(updatedStrategies);
            };
            
            // Helper: Trouver les cotes live pour un type de pari
            const findLiveOddsForBet = (betType, hedgingOdds) => {
                if (!betType || !hedgingOdds) return null;
                
                const typeLower = (betType || '').toLowerCase();
                
                // Nouvelle structure: hedgingOdds.doubleChance, hedgingOdds.matchWinner, hedgingOdds.overUnder
                const dc = hedgingOdds?.doubleChance || {};
                const mw = hedgingOdds?.matchWinner || {};
                const ou = hedgingOdds?.overUnder || {};
                const recommends = hedgingOdds?.recommendedHedges || [];
                
                // Chercher d'abord dans les recommandations
                const recommended = recommends.find(r => 
                    r.hedgeBet?.toLowerCase().includes(typeLower) || 
                    r.hedgeBetKey?.toLowerCase().includes(typeLower) ||
                    typeLower.includes(r.hedgeBetKey?.toLowerCase() || '')
                );
                if (recommended?.currentOdds) return recommended.currentOdds;
                
                // Double Chance X2 (Away or Draw)
                if (typeLower.includes('x2') || typeLower.includes('away or draw') || 
                    (typeLower.includes('double chance') && typeLower.includes('away'))) {
                    return dc.awayOrDraw || null;
                }
                
                // Double Chance 1X (Home or Draw)
                if (typeLower.includes('1x') || typeLower.includes('home or draw') ||
                    (typeLower.includes('double chance') && typeLower.includes('home') && typeLower.includes('draw'))) {
                    return dc.homeOrDraw || null;
                }
                
                // Double Chance 12 (Home or Away)
                if (typeLower.includes('12') || typeLower.includes('home or away')) {
                    return dc.homeOrAway || null;
                }
                
                // Over
                if (typeLower.includes('over') || typeLower.includes('plus de')) {
                    const match = typeLower.match(/(\d+\.?\d*)/);
                    if (match && ou[match[1]]) {
                        return ou[match[1]].over || null;
                    }
                }
                
                // Under
                if (typeLower.includes('under') || typeLower.includes('moins de')) {
                    const match = typeLower.match(/(\d+\.?\d*)/);
                    if (match && ou[match[1]]) {
                        return ou[match[1]].under || null;
                    }
                }
                
                // 1X2 - Match Winner
                if (typeLower.includes('home win') || typeLower === 'home' || typeLower === '1') {
                    return mw.home || null;
                }
                if (typeLower.includes('draw') || typeLower === 'x' || typeLower === 'nul') {
                    return mw.draw || null;
                }
                if (typeLower.includes('away win') || typeLower === 'away' || typeLower === '2') {
                    return mw.away || null;
                }
                
                return null;
            };
            
            // Helper: Recalculer les sc√©narios
            const recalculateScenarios = (strat, newStake, newOdds, totalOriginalStake) => {
                if (!strat.scenarios) return [];
                
                return strat.scenarios.map(scenario => {
                    const newScenario = { ...scenario };
                    
                    // Recalculer le profit/perte bas√© sur la nouvelle mise
                    if (scenario.hedgeWins) {
                        newScenario.profit = Math.round(newStake * newOdds - newStake - totalOriginalStake);
                    }
                    
                    return newScenario;
                });
            };
            
            // ========== EFFET: AUTO-REFRESH DES COTES ==========
            useEffect(() => {
                fetchLiveOdds(); // Premier chargement
                
                let interval;
                if (autoRefreshOdds) {
                    interval = setInterval(fetchLiveOdds, 30000); // Toutes les 30s
                }
                
                return () => {
                    if (interval) clearInterval(interval);
                };
            }, [fixtureId, autoRefreshOdds]);

            const handleSelectStrategy = (strategyId) => {
                setSelectedStrategy(strategyId);
                showNotification(`Strat√©gie "${strategyId.toUpperCase()}" s√©lectionn√©e`, "success");
            };

            const toggleExpand = (strategyId) => {
                setExpandedStrategy(expandedStrategy === strategyId ? null : strategyId);
            };

            // Couleur selon le niveau de risque
            const getRiskStyle = (riskLevel, riskScore) => {
                const score = riskScore || (riskLevel === 'low' ? 2 : riskLevel === 'high' ? 8 : 5);
                if (score <= 3) return { bg: 'rgba(16, 185, 129, 0.15)', color: '#10b981', icon: 'üü¢', text: 'Faible' };
                if (score <= 6) return { bg: 'rgba(245, 158, 11, 0.15)', color: '#f59e0b', icon: 'üü°', text: 'Mod√©r√©' };
                return { bg: 'rgba(239, 68, 68, 0.15)', color: '#ef4444', icon: 'üî¥', text: '√âlev√©' };
            };

            // Couleur selon le statut
            const getStatusStyle = (status) => {
                switch(status) {
                    case 'won': return { bg: 'rgba(16, 185, 129, 0.2)', color: '#10b981', icon: '‚úÖ', text: 'GAGN√â' };
                    case 'winning': return { bg: 'rgba(16, 185, 129, 0.15)', color: '#22c55e', icon: 'üìà', text: 'EN BONNE VOIE' };
                    case 'losing': return { bg: 'rgba(239, 68, 68, 0.15)', color: '#ef4444', icon: 'üìâ', text: 'EN DIFFICULT√â' };
                    case 'lost': return { bg: 'rgba(239, 68, 68, 0.2)', color: '#dc2626', icon: '‚ùå', text: 'PERDU' };
                    default: return { bg: 'rgba(245, 158, 11, 0.15)', color: '#f59e0b', icon: '‚è≥', text: 'EN COURS' };
                }
            };

            return (
                <>
                    <Header showBack={true} title="Strat√©gies de couverture" />
                    <main className="main-content" style={{ paddingBottom: '100px' }}>
                        {/* Match info */}
                        {matchInfo && (
                            <div className="card animate-fade-in" style={{ marginBottom: '16px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                    <div>
                                        <h3 style={{ marginBottom: '4px' }}>{matchInfo.homeTeam} vs {matchInfo.awayTeam}</h3>
                                        <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem', margin: 0 }}>{matchInfo.league}</p>
                                    </div>
                                    {strategyData?.calculations?.avgWinProbability !== undefined && (
                                        <div style={{ 
                                            padding: '8px 12px', 
                                            background: 'rgba(59, 130, 246, 0.15)',
                                            borderRadius: '8px',
                                            textAlign: 'center'
                                        }}>
                                            <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Prob. succ√®s</div>
                                            <div style={{ fontSize: '1.2rem', fontWeight: '700', color: 'var(--accent-blue)' }}>
                                                {strategyData.calculations.avgWinProbability}%
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        {/* Avertissement si l'IA a √©chou√© */}
                        {strategyData?.aiErrors?.length > 0 && (
                            <div className="card animate-fade-in" style={{ 
                                marginBottom: '16px',
                                background: 'rgba(239, 68, 68, 0.1)',
                                border: '1px solid rgba(239, 68, 68, 0.3)'
                            }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '10px' }}>
                                    <span style={{ fontSize: '1.3rem' }}>‚ö†Ô∏è</span>
                                    <div>
                                        <h4 style={{ margin: 0, color: '#ef4444', fontSize: '0.95rem' }}>
                                            {strategyData.usedFallback ? 'Analyse de secours utilis√©e' : 'Erreur lors de l\'analyse IA'}
                                        </h4>
                                        <p style={{ margin: '4px 0 0', color: 'var(--text-muted)', fontSize: '0.8rem' }}>
                                            {strategyData.warningMessage || `${strategyData.aiErrors.map(e => e.engine).join(' et ')} a rencontr√© une erreur de connexion`}
                                        </p>
                                    </div>
                                </div>
                                
                                {/* Liste des erreurs */}
                                <div style={{
                                    padding: '10px',
                                    background: 'rgba(0,0,0,0.2)',
                                    borderRadius: '8px',
                                    marginBottom: '10px',
                                    fontSize: '0.75rem'
                                }}>
                                    {strategyData.aiErrors.map((err, i) => (
                                        <div key={i} style={{ 
                                            display: 'flex', 
                                            justifyContent: 'space-between',
                                            padding: '4px 0',
                                            borderBottom: i < strategyData.aiErrors.length - 1 ? '1px solid var(--border-color)' : 'none'
                                        }}>
                                            <span style={{ color: 'var(--text-secondary)' }}>
                                                {err.engine === 'claude' ? 'üß† Claude' : 'üîÆ DeepSeek'}:
                                            </span>
                                            <span style={{ color: err.retryable ? '#f59e0b' : '#ef4444' }}>
                                                {err.message?.substring(0, 40)}...
                                            </span>
                                        </div>
                                    ))}
                                </div>
                                
                                {/* Boutons d'action */}
                                <div style={{ display: 'flex', gap: '10px' }}>
                                    {strategyData.canRetry && (
                                        <button
                                            className="btn btn-primary"
                                            style={{
                                                flex: 1,
                                                padding: '12px',
                                                background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                                                border: 'none',
                                                fontSize: '0.85rem',
                                                fontWeight: '600'
                                            }}
                                            onClick={async () => {
                                                showNotification('üîÑ Relance de l\'analyse en cours...', 'info');
                                                setIsGenerating(true);
                                                try {
                                                    const token = await getValidToken();
                                                    const response = await fetch(`${API_BASE_URL}/hedging/retry`, {
                                                        method: 'POST',
                                                        headers: {
                                                            'Authorization': `Bearer ${token}`,
                                                            'Content-Type': 'application/json'
                                                        },
                                                        body: JSON.stringify({
                                                            predictionId: currentPrediction?.id,
                                                            options: selectedOptions.length > 0 ? selectedOptions : currentPrediction?.selectedOptions,
                                                            currentScore: strategyData?.matchAnalysis?.currentScore || { home: 0, away: 0 },
                                                            currentElapsed: strategyData?.calculations?.timeRemaining ? 90 - strategyData.calculations.timeRemaining : 45,
                                                            fixtureId: currentPrediction?.matchInfo?.fixtureId,
                                                            matchInfo: currentPrediction?.matchInfo
                                                        })
                                                    });
                                                    const data = await response.json();
                                                    if (response.ok && data.strategy) {
                                                        setRecalculatedStrategies(data.strategy);
                                                        if (!data.strategy.aiErrors || data.strategy.aiErrors.length === 0) {
                                                            showNotification('‚úÖ Analyse IA relanc√©e avec succ√®s!', 'success');
                                                        } else if (data.strategy.usedFallback) {
                                                            showNotification('‚ö†Ô∏è Analyse locale utilis√©e (IA indisponible)', 'warning');
                                                        } else {
                                                            showNotification('Analyse mise √† jour', 'info');
                                                        }
                                                    } else {
                                                        showNotification(data.error || 'Erreur lors de la relance', 'error');
                                                    }
                                                } catch (err) {
                                                    console.error('Retry error:', err);
                                                    showNotification('Erreur de connexion. Veuillez r√©essayer.', 'error');
                                                } finally {
                                                    setIsGenerating(false);
                                                }
                                            }}
                                            disabled={isGenerating}
                                        >
                                            {isGenerating ? '‚è≥ Analyse en cours...' : 'üîÑ Relancer l\'analyse IA'}
                                        </button>
                                    )}
                                    
                                    <button
                                        className="btn btn-secondary"
                                        style={{
                                            flex: 1,
                                            padding: '12px',
                                            background: 'rgba(107, 114, 128, 0.2)',
                                            border: '1px solid var(--border-color)',
                                            fontSize: '0.85rem'
                                        }}
                                        onClick={() => setShowBreakEvenModal(true)}
                                    >
                                        üßÆ Calcul manuel
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Analyse du match */}
                        {matchAnalysis && (
                            <div className="card animate-fade-in delay-1" style={{ marginBottom: '16px' }}>
                                <h4 style={{ marginBottom: '12px', color: 'var(--accent-gold)' }}>üìä Analyse en direct</h4>
                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', lineHeight: '1.6' }}>
                                    <p style={{ marginBottom: '6px' }}>üéØ {matchAnalysis.currentSituation}</p>
                                    <p style={{ marginBottom: '6px' }}>üìà {matchAnalysis.trendsObserved}</p>
                                    <p style={{ margin: 0 }}>‚ö†Ô∏è {matchAnalysis.riskAssessment}</p>
                                </div>
                            </div>
                        )}

                        {/* Statut des paris */}
                        {optionsStatus.length > 0 && (
                            <div className="card animate-fade-in delay-1" style={{ marginBottom: '16px' }}>
                                <h4 style={{ marginBottom: '12px', color: 'var(--accent-gold)' }}>üìã Statut de vos paris</h4>
                                {optionsStatus.map((opt, idx) => {
                                    const statusStyle = getStatusStyle(opt.status);
                                    return (
                                        <div key={idx} style={{
                                            padding: '12px',
                                            marginBottom: idx < optionsStatus.length - 1 ? '10px' : 0,
                                            background: statusStyle.bg,
                                            borderRadius: '10px',
                                            borderLeft: `4px solid ${statusStyle.color}`
                                        }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '4px' }}>
                                                <span style={{ fontWeight: '600', fontSize: '0.9rem' }}>{opt.option}</span>
                                                <span style={{ 
                                                    padding: '3px 8px', 
                                                    background: 'rgba(0,0,0,0.2)', 
                                                    color: statusStyle.color,
                                                    borderRadius: '10px',
                                                    fontSize: '0.7rem',
                                                    fontWeight: '600'
                                                }}>
                                                    {statusStyle.icon} {statusStyle.text}
                                                </span>
                                            </div>
                                            <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', margin: 0 }}>{opt.analysis}</p>
                                            {opt.probability !== undefined && (
                                                <div style={{ marginTop: '6px', display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                    <div style={{ flex: 1, height: '5px', background: 'rgba(0,0,0,0.3)', borderRadius: '3px', overflow: 'hidden' }}>
                                                        <div style={{ 
                                                            width: `${opt.probability * 100}%`, 
                                                            height: '100%', 
                                                            background: statusStyle.color
                                                        }}></div>
                                                    </div>
                                                    <span style={{ fontSize: '0.75rem', fontFamily: 'Space Mono', color: statusStyle.color }}>
                                                        {Math.round(opt.probability * 100)}%
                                                    </span>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        )}

                        {/* ========== INDICATEUR STRAT√âGIE OPTIMALE ========== */}
                        {strategyData && (
                            <div className="card animate-fade-in delay-1" style={{ 
                                marginBottom: '16px',
                                background: strategyData.ratioQuality === 'excellent' || strategyData.ratioQuality === 'good'
                                    ? 'linear-gradient(135deg, rgba(16, 185, 129, 0.15) 0%, rgba(5, 150, 105, 0.1) 100%)'
                                    : strategyData.ratioQuality === 'moderate'
                                    ? 'linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(217, 119, 6, 0.1) 100%)'
                                    : 'linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(185, 28, 28, 0.1) 100%)',
                                border: strategyData.ratioQuality === 'excellent' || strategyData.ratioQuality === 'good'
                                    ? '2px solid rgba(16, 185, 129, 0.5)'
                                    : strategyData.ratioQuality === 'moderate'
                                    ? '2px solid rgba(245, 158, 11, 0.5)'
                                    : '2px solid rgba(239, 68, 68, 0.5)'
                            }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '10px' }}>
                                    <div style={{
                                        width: '50px',
                                        height: '50px',
                                        borderRadius: '50%',
                                        background: strategyData.ratioQuality === 'excellent' || strategyData.ratioQuality === 'good'
                                            ? 'rgba(16, 185, 129, 0.2)'
                                            : strategyData.ratioQuality === 'moderate'
                                            ? 'rgba(245, 158, 11, 0.2)'
                                            : 'rgba(239, 68, 68, 0.2)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        fontSize: '1.5rem'
                                    }}>
                                        {strategyData.ratioEmoji || (strategyData.ratioQuality === 'excellent' ? 'üèÜ' : strategyData.ratioQuality === 'good' ? '‚úÖ' : strategyData.ratioQuality === 'moderate' ? 'üî∂' : '‚ö†Ô∏è')}
                                    </div>
                                    <div>
                                        <h4 style={{ 
                                            margin: 0, 
                                            color: strategyData.ratioQuality === 'excellent' || strategyData.ratioQuality === 'good' 
                                                ? '#10b981' 
                                                : strategyData.ratioQuality === 'moderate' 
                                                ? '#f59e0b' 
                                                : '#ef4444',
                                            fontSize: '1rem'
                                        }}>
                                            {strategyData.ratioQuality === 'excellent' 
                                                ? 'Ratio Excellent!' 
                                                : strategyData.ratioQuality === 'good'
                                                ? 'Bon Ratio'
                                                : strategyData.ratioQuality === 'moderate'
                                                ? 'Ratio Mod√©r√©'
                                                : 'Ratio Faible'}
                                        </h4>
                                        <p style={{ margin: '4px 0 0 0', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                            {optimalStrategyReason || `Ratio gain/perte: ${strategyData.calculations?.bestGainLossRatio?.toFixed(1) || '?'}x`}
                                        </p>
                                    </div>
                                </div>
                                
                                {/* Afficher le ratio et les r√©sultats */}
                                {optimalStrategy && (
                                    <div style={{
                                        display: 'flex',
                                        gap: '12px',
                                        padding: '10px',
                                        background: 'rgba(0,0,0,0.2)',
                                        borderRadius: '8px',
                                        marginBottom: '10px'
                                    }}>
                                        <div style={{ flex: 1, textAlign: 'center' }}>
                                            <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Meilleur cas</div>
                                            <div style={{ fontSize: '1.1rem', fontWeight: '700', color: '#10b981' }}>
                                                +{optimalStrategy.bestCase?.toLocaleString() || 0} F
                                            </div>
                                        </div>
                                        <div style={{ flex: 1, textAlign: 'center' }}>
                                            <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Pire cas</div>
                                            <div style={{ fontSize: '1.1rem', fontWeight: '700', color: '#ef4444' }}>
                                                {optimalStrategy.worstCase?.toLocaleString() || 0} F
                                            </div>
                                        </div>
                                        <div style={{ flex: 1, textAlign: 'center' }}>
                                            <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Ratio</div>
                                            <div style={{ 
                                                fontSize: '1.1rem', 
                                                fontWeight: '700', 
                                                color: strategyData.ratioColor || 'var(--accent-gold)' 
                                            }}>
                                                {optimalStrategy.gainLossRatio?.toFixed(1) || strategyData.calculations?.bestGainLossRatio?.toFixed(1) || '?'}x
                                            </div>
                                        </div>
                                    </div>
                                )}
                                
                                {/* Message selon la qualit√© du ratio */}
                                <div style={{
                                    padding: '10px',
                                    background: 'rgba(0,0,0,0.15)',
                                    borderRadius: '8px',
                                    fontSize: '0.8rem',
                                    color: 'var(--text-secondary)',
                                    marginBottom: '12px'
                                }}>
                                    {strategyData.ratioQuality === 'excellent' 
                                        ? 'üéØ Ce ratio est excellent! La strat√©gie optimale est fortement recommand√©e.'
                                        : strategyData.ratioQuality === 'good'
                                        ? 'üëç Ce ratio est bon. La strat√©gie optimale est une bonne option.'
                                        : strategyData.ratioQuality === 'moderate'
                                        ? 'ü§î Ce ratio est mod√©r√©. √âvaluez si le risque vous convient ou utilisez le break-even.'
                                        : '‚ö†Ô∏è Ce ratio est faible. Le break-even manuel est conseill√© pour minimiser les pertes.'}
                                </div>
                                
                                {/* Bouton Break-even - toujours disponible */}
                                <button
                                    className="btn btn-secondary"
                                    style={{
                                        width: '100%',
                                        background: strategyData.breakEvenFallback?.suggested
                                            ? 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)'
                                            : 'rgba(107, 114, 128, 0.3)',
                                        border: strategyData.breakEvenFallback?.suggested
                                            ? 'none'
                                            : '1px solid var(--border-color)',
                                        padding: '12px',
                                        fontSize: '0.85rem',
                                        fontWeight: '600',
                                        color: 'var(--text-primary)'
                                    }}
                                    onClick={() => setShowBreakEvenModal(true)}
                                >
                                    üßÆ {strategyData.breakEvenFallback?.suggested 
                                        ? 'Calculer le Break-even (Recommand√©)' 
                                        : 'Calculer le Break-even (Optionnel)'}
                                </button>
                            </div>
                        )}

                        {/* ========== LES 4 STRAT√âGIES ========== */}
                        {strategies.length > 0 ? (
                            <>
                                <h3 className="section-title animate-fade-in delay-2" style={{ marginBottom: '12px' }}>
                                    üéØ Choisissez votre strat√©gie
                                </h3>
                                <p style={{ color: 'var(--text-muted)', fontSize: '0.8rem', marginBottom: '16px' }}>
                                    {strategies.length} options avec calculs d√©taill√©s. Cliquez pour voir les d√©tails.
                                </p>

                                {strategies.map((strat, idx) => {
                                    const riskStyle = getRiskStyle(strat.riskLevel, strat.riskScore);
                                    const isRecommended = strat.id === recommendedStrategyId || strat.recommended;
                                    const isSelected = selectedStrategy === strat.id;
                                    const isExpanded = expandedStrategy === strat.id;

                                    return (
                                        <div 
                                            key={strat.id}
                                            className={`card animate-fade-in delay-${Math.min(idx + 2, 5)}`}
                                            style={{ 
                                                marginBottom: '14px',
                                                border: isRecommended ? '2px solid var(--accent-gold)' : isSelected ? '2px solid var(--accent-blue)' : '1px solid var(--border-color)',
                                                position: 'relative'
                                            }}
                                        >
                                            {/* Badge recommand√© ou badge ratio pour strat√©gie optimale */}
                                            {strat.id === 'optimal' && strat.ratioQuality ? (
                                                <div style={{
                                                    position: 'absolute',
                                                    top: '-1px',
                                                    right: '-1px',
                                                    background: strat.ratioColor || (
                                                        strat.ratioQuality === 'excellent' ? '#10b981' :
                                                        strat.ratioQuality === 'good' ? '#22c55e' :
                                                        strat.ratioQuality === 'moderate' ? '#f59e0b' : '#ef4444'
                                                    ),
                                                    color: strat.ratioQuality === 'moderate' ? 'black' : 'white',
                                                    padding: '3px 10px',
                                                    fontSize: '0.65rem',
                                                    fontWeight: '700',
                                                    borderBottomLeftRadius: '8px',
                                                    borderTopRightRadius: '8px'
                                                }}>
                                                    {strat.ratioEmoji || 'üìä'} {strat.gainLossRatio?.toFixed(1) || '?'}x {
                                                        strat.ratioQuality === 'excellent' ? 'EXCELLENT' :
                                                        strat.ratioQuality === 'good' ? 'BON' :
                                                        strat.ratioQuality === 'moderate' ? 'MOD√âR√â' : 'FAIBLE'
                                                    }
                                                </div>
                                            ) : isRecommended && (
                                                <div style={{
                                                    position: 'absolute',
                                                    top: '-1px',
                                                    right: '-1px',
                                                    background: 'var(--accent-gold)',
                                                    color: 'black',
                                                    padding: '3px 10px',
                                                    fontSize: '0.65rem',
                                                    fontWeight: '700',
                                                    borderBottomLeftRadius: '8px',
                                                    borderTopRightRadius: '8px'
                                                }}>
                                                    ‚≠ê RECOMMAND√â
                                                </div>
                                            )}

                                            {/* En-t√™te cliquable */}
                                            <div 
                                                onClick={() => toggleExpand(strat.id)}
                                                style={{ cursor: 'pointer' }}
                                            >
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '10px' }}>
                                                    <div style={{ flex: 1 }}>
                                                        <h4 style={{ fontSize: '1rem', marginBottom: '4px' }}>{strat.name}</h4>
                                                        <p style={{ fontSize: '0.8rem', color: 'var(--text-muted)', margin: 0 }}>{strat.description}</p>
                                                    </div>
                                                    <div style={{
                                                        padding: '5px 10px',
                                                        background: riskStyle.bg,
                                                        borderRadius: '8px',
                                                        textAlign: 'center',
                                                        marginLeft: '10px'
                                                    }}>
                                                        <div style={{ fontSize: '0.6rem', color: 'var(--text-muted)' }}>Risque</div>
                                                        <div style={{ fontSize: '0.85rem', fontWeight: '700', color: riskStyle.color }}>
                                                            {riskStyle.icon} {strat.riskScore}/10
                                                        </div>
                                                    </div>
                                                </div>

                                                {/* Sc√©narios principaux */}
                                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', marginBottom: '10px' }}>
                                                    {strat.scenarios?.slice(0, 2).map((scenario, sIdx) => {
                                                        const value = scenario.profit ?? scenario.result ?? 0;
                                                        return (
                                                            <div key={sIdx} style={{
                                                                padding: '8px 10px',
                                                                background: value >= 0 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)',
                                                                borderRadius: '8px',
                                                                borderLeft: `3px solid ${value >= 0 ? '#10b981' : '#ef4444'}`
                                                            }}>
                                                                <div style={{ fontSize: '0.65rem', color: 'var(--text-muted)', marginBottom: '2px' }}>
                                                                    {scenario.name?.substring(0, 25)}
                                                                </div>
                                                                <div style={{ 
                                                                    fontSize: '1rem', 
                                                                    fontWeight: '700',
                                                                    fontFamily: 'Space Mono',
                                                                    color: value >= 0 ? '#10b981' : '#ef4444'
                                                                }}>
                                                                    {value >= 0 ? '+' : ''}{value.toLocaleString()} F
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                                </div>

                                                <div style={{ 
                                                    textAlign: 'center', 
                                                    color: 'var(--text-muted)', 
                                                    fontSize: '0.75rem',
                                                    padding: '6px',
                                                    background: 'rgba(255,255,255,0.03)',
                                                    borderRadius: '6px'
                                                }}>
                                                    {isExpanded ? 'üîº Masquer les d√©tails' : 'üîΩ Voir les calculs d√©taill√©s'}
                                                </div>
                                            </div>

                                            {/* D√©tails (collapsible) */}
                                            {isExpanded && (
                                                <div style={{ marginTop: '12px', paddingTop: '12px', borderTop: '1px solid var(--border-color)' }}>
                                                    {/* Calculs */}
                                                    <div style={{
                                                        padding: '12px',
                                                        background: 'rgba(0,0,0,0.3)',
                                                        borderRadius: '8px',
                                                        marginBottom: '12px'
                                                    }}>
                                                        <h5 style={{ marginBottom: '8px', color: 'var(--accent-gold)', fontSize: '0.85rem' }}>
                                                            üìê Formule & Calculs
                                                        </h5>
                                                        
                                                        <div style={{
                                                            padding: '8px',
                                                            background: 'rgba(59, 130, 246, 0.1)',
                                                            borderRadius: '6px',
                                                            marginBottom: '8px',
                                                            fontFamily: 'Space Mono',
                                                            fontSize: '0.75rem',
                                                            color: 'var(--accent-blue)'
                                                        }}>
                                                            {strat.calculations?.formula}
                                                        </div>

                                                        {strat.calculations?.details?.map((detail, dIdx) => (
                                                            <div key={dIdx} style={{
                                                                padding: '5px 8px',
                                                                background: 'rgba(255,255,255,0.03)',
                                                                borderRadius: '4px',
                                                                marginBottom: '4px',
                                                                fontSize: '0.8rem',
                                                                color: 'var(--text-secondary)',
                                                                borderLeft: '2px solid var(--accent-gold)'
                                                            }}>
                                                                {detail}
                                                            </div>
                                                        ))}

                                                        {/* Explications des sc√©narios */}
                                                        {strat.scenarios?.map((scenario, sIdx) => {
                                                            const val = scenario.profit ?? scenario.result ?? 0;
                                                            return (
                                                                <div key={sIdx} style={{
                                                                    marginTop: '8px',
                                                                    padding: '8px',
                                                                    background: 'rgba(255,255,255,0.02)',
                                                                    borderRadius: '6px',
                                                                    fontSize: '0.8rem'
                                                                }}>
                                                                    <div style={{ fontWeight: '600', marginBottom: '3px', color: val >= 0 ? '#10b981' : '#ef4444' }}>
                                                                        {scenario.name} ({val >= 0 ? '+' : ''}{val.toLocaleString()} F)
                                                                    </div>
                                                                    <div style={{ color: 'var(--text-muted)', fontFamily: 'Space Mono', fontSize: '0.75rem' }}>
                                                                        {scenario.explanation}
                                                                    </div>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>

                                                    {/* Actions */}
                                                    {(strat.actions?.length > 0 || strat.hedgeRequired) && (
                                                        <div style={{
                                                            padding: '10px',
                                                            background: 'rgba(245, 158, 11, 0.1)',
                                                            borderRadius: '8px',
                                                            marginBottom: '10px'
                                                        }}>
                                                            <div style={{ fontWeight: '600', marginBottom: '6px', fontSize: '0.8rem', color: 'var(--accent-gold)' }}>
                                                                üìù Action √† effectuer:
                                                            </div>
                                                            
                                                            {/* Affichage sp√©cial si hedge requis - AVEC √âVOLUTION DES COTES */}
                                                            {strat.hedgeRequired && strat.hedgeBet && (
                                                                <div style={{
                                                                    padding: '12px',
                                                                    background: 'linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(234, 88, 12, 0.1) 100%)',
                                                                    borderRadius: '8px',
                                                                    border: strat.hedgeBet.oddsChanged ? '2px solid rgba(59, 130, 246, 0.5)' : '1px solid rgba(245, 158, 11, 0.3)',
                                                                    marginBottom: '8px'
                                                                }}>
                                                                    {/* Badge si cotes ont chang√© */}
                                                                    {strat.hedgeBet.oddsChanged && (
                                                                        <div style={{
                                                                            display: 'flex',
                                                                            alignItems: 'center',
                                                                            gap: '6px',
                                                                            marginBottom: '8px',
                                                                            padding: '4px 8px',
                                                                            background: strat.hedgeBet.changeDirection === 'down' ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)',
                                                                            borderRadius: '6px',
                                                                            fontSize: '0.7rem',
                                                                            color: strat.hedgeBet.changeDirection === 'down' ? '#10b981' : '#ef4444'
                                                                        }}>
                                                                            {strat.hedgeBet.changeDirection === 'down' ? 'üìâ Cote en baisse - FAVORABLE!' : 'üìà Cote en hausse - mise ajust√©e'}
                                                                        </div>
                                                                    )}
                                                                    
                                                                    <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)', marginBottom: '4px' }}>
                                                                        üéØ PARI DE COUVERTURE √Ä PLACER:
                                                                    </div>
                                                                    <div style={{ 
                                                                        fontSize: '1rem', 
                                                                        fontWeight: '700', 
                                                                        color: 'var(--accent-gold)',
                                                                        marginBottom: '8px'
                                                                    }}>
                                                                        {typeof strat.hedgeBet === 'object' ? strat.hedgeBet.type : strat.hedgeBet}
                                                                    </div>
                                                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                                                                        {/* MISE - avec √©volution */}
                                                                        <div style={{ 
                                                                            padding: '8px', 
                                                                            background: 'rgba(0,0,0,0.2)', 
                                                                            borderRadius: '6px',
                                                                            textAlign: 'center'
                                                                        }}>
                                                                            <div style={{ fontSize: '0.65rem', color: 'var(--text-muted)' }}>MISE</div>
                                                                            {strat.hedgeBet.oddsChanged && strat.hedgeBet.originalStake ? (
                                                                                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px' }}>
                                                                                    <span style={{ 
                                                                                        fontSize: '0.75rem', 
                                                                                        textDecoration: 'line-through', 
                                                                                        color: 'var(--text-muted)' 
                                                                                    }}>
                                                                                        {strat.hedgeBet.originalStake.toLocaleString()} F
                                                                                    </span>
                                                                                    <span style={{ 
                                                                                        fontSize: '1.1rem', 
                                                                                        fontWeight: '700', 
                                                                                        fontFamily: 'Space Mono',
                                                                                        color: '#f59e0b'
                                                                                    }}>
                                                                                        {(strat.hedgeBet.stake || strat.hedgeStake || 0).toLocaleString()} F
                                                                                    </span>
                                                                                </div>
                                                                            ) : (
                                                                                <div style={{ 
                                                                                    fontSize: '1.1rem', 
                                                                                    fontWeight: '700', 
                                                                                    fontFamily: 'Space Mono',
                                                                                    color: '#f59e0b'
                                                                                }}>
                                                                                    {(strat.hedgeBet.stake || strat.hedgeStake || 0).toLocaleString()} F
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                        
                                                                        {/* COTE - avec √©volution */}
                                                                        <div style={{ 
                                                                            padding: '8px', 
                                                                            background: 'rgba(0,0,0,0.2)', 
                                                                            borderRadius: '6px',
                                                                            textAlign: 'center'
                                                                        }}>
                                                                            <div style={{ fontSize: '0.65rem', color: 'var(--text-muted)' }}>COTE</div>
                                                                            {strat.hedgeBet.oddsChanged && strat.hedgeBet.originalOdds ? (
                                                                                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px' }}>
                                                                                    <span style={{ 
                                                                                        fontSize: '0.75rem', 
                                                                                        textDecoration: 'line-through', 
                                                                                        color: 'var(--text-muted)' 
                                                                                    }}>
                                                                                        @{strat.hedgeBet.originalOdds.toFixed(2)}
                                                                                    </span>
                                                                                    <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                                                        <span style={{ 
                                                                                            fontSize: '1.1rem', 
                                                                                            fontWeight: '700', 
                                                                                            fontFamily: 'Space Mono',
                                                                                            color: strat.hedgeBet.changeDirection === 'down' ? '#10b981' : '#ef4444'
                                                                                        }}>
                                                                                            @{(strat.hedgeBet.odds || strat.hedgeOdds || 2.0).toFixed(2)}
                                                                                        </span>
                                                                                        <span style={{ fontSize: '0.8rem' }}>
                                                                                            {strat.hedgeBet.changeDirection === 'down' ? '‚ñº' : '‚ñ≤'}
                                                                                        </span>
                                                                                    </div>
                                                                                </div>
                                                                            ) : (
                                                                                <div style={{ 
                                                                                    fontSize: '1.1rem', 
                                                                                    fontWeight: '700', 
                                                                                    fontFamily: 'Space Mono',
                                                                                    color: 'var(--accent-blue)'
                                                                                }}>
                                                                                    @{(strat.hedgeBet.odds || strat.hedgeOdds || 2.0).toFixed(2)}
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                    </div>
                                                                    
                                                                    {/* Indicateur de mise √† jour en temps r√©el */}
                                                                    {lastOddsUpdate && (
                                                                        <div style={{ 
                                                                            marginTop: '8px', 
                                                                            fontSize: '0.65rem', 
                                                                            color: 'var(--text-muted)',
                                                                            textAlign: 'center',
                                                                            display: 'flex',
                                                                            alignItems: 'center',
                                                                            justifyContent: 'center',
                                                                            gap: '6px'
                                                                        }}>
                                                                            <span style={{ 
                                                                                width: '6px', height: '6px', 
                                                                                borderRadius: '50%', 
                                                                                background: isRefreshing ? '#f59e0b' : '#10b981',
                                                                                animation: isRefreshing ? 'pulse 1s infinite' : 'none'
                                                                            }}></span>
                                                                            {isRefreshing ? 'Actualisation...' : `Cotes live @ ${lastOddsUpdate.toLocaleTimeString('fr-FR')}`}
                                                                        </div>
                                                                    )}
                                                                    
                                                                    {strat.capitalNeeded > 0 && (
                                                                        <div style={{ 
                                                                            marginTop: '8px', 
                                                                            fontSize: '0.75rem', 
                                                                            color: 'var(--text-muted)',
                                                                            textAlign: 'center'
                                                                        }}>
                                                                            üí∞ Capital additionnel requis: <strong style={{ color: 'var(--accent-gold)' }}>{strat.capitalNeeded.toLocaleString()} FCFA</strong>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            )}
                                                            
                                                            {/* Actions classiques (cashout, etc.) */}
                                                            {strat.actions?.map((action, aIdx) => (
                                                                <div key={aIdx} style={{
                                                                    padding: '6px 8px',
                                                                    background: 'rgba(0,0,0,0.2)',
                                                                    borderRadius: '4px',
                                                                    marginBottom: aIdx < strat.actions.length - 1 ? '4px' : 0,
                                                                    fontSize: '0.8rem'
                                                                }}>
                                                                    <strong>{action.action}</strong>: {action.bet || action.option}
                                                                    {action.amount && (
                                                                        <span style={{ color: 'var(--accent-gold)', marginLeft: '6px', fontFamily: 'Space Mono' }}>
                                                                            {action.amount.toLocaleString()} F
                                                                        </span>
                                                                    )}
                                                                    {action.odds && <span style={{ color: 'var(--text-muted)' }}> @{action.odds}</span>}
                                                                </div>
                                                            ))}
                                                        </div>
                                                    )}

                                                    {/* Avantages / Inconv√©nients */}
                                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', marginBottom: '10px' }}>
                                                        <div style={{ padding: '8px', background: 'rgba(16, 185, 129, 0.1)', borderRadius: '6px' }}>
                                                            <div style={{ fontSize: '0.7rem', fontWeight: '600', color: '#10b981', marginBottom: '4px' }}>‚úÖ Avantages</div>
                                                            {strat.pros?.slice(0, 2).map((pro, pIdx) => (
                                                                <div key={pIdx} style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', marginBottom: '2px' }}>‚Ä¢ {pro}</div>
                                                            ))}
                                                        </div>
                                                        <div style={{ padding: '8px', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '6px' }}>
                                                            <div style={{ fontSize: '0.7rem', fontWeight: '600', color: '#ef4444', marginBottom: '4px' }}>‚ö†Ô∏è Inconv√©nients</div>
                                                            {strat.cons?.slice(0, 2).map((con, cIdx) => (
                                                                <div key={cIdx} style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', marginBottom: '2px' }}>‚Ä¢ {con}</div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                </div>
                                            )}

                                            {/* R√©sum√© et bouton */}
                                            <div style={{
                                                padding: '8px 10px',
                                                background: 'rgba(255,255,255,0.03)',
                                                borderRadius: '6px',
                                                fontSize: '0.8rem',
                                                color: 'var(--text-secondary)',
                                                marginBottom: '10px'
                                            }}>
                                                üí° {strat.summary}
                                            </div>

                                            <button 
                                                className={`btn ${isSelected ? 'btn-success' : 'btn-primary'}`}
                                                style={{ width: '100%', padding: '10px' }}
                                                onClick={(e) => { e.stopPropagation(); handleSelectStrategy(strat.id); }}
                                            >
                                                {isSelected ? '‚úÖ Strat√©gie s√©lectionn√©e' : 'Choisir cette strat√©gie'}
                                            </button>
                                        </div>
                                    );
                                })}

                                {/* Explication de la recommandation */}
                                {strategyData?.reasoning && (
                                    <div className="card animate-fade-in" style={{
                                        marginBottom: '16px',
                                        background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%)',
                                        border: '1px solid rgba(139, 92, 246, 0.3)'
                                    }}>
                                        <h4 style={{ marginBottom: '8px', color: '#a78bfa', fontSize: '0.9rem' }}>üß† Pourquoi cette recommandation ?</h4>
                                        <p style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', margin: 0, lineHeight: '1.5' }}>
                                            {strategyData.reasoning}
                                        </p>
                                    </div>
                                )}
                            </>
                        ) : (
                            /* Ancien format ou pas de strat√©gies */
                            <div className="card animate-fade-in" style={{ marginBottom: '16px' }}>
                                <h4 style={{ marginBottom: '12px', color: 'var(--accent-gold)' }}>
                                    üìä {strategyData?.recommendation ? `Recommandation: ${strategyData.recommendation.toUpperCase()}` : 'Analyse'}
                                </h4>
                                <p style={{ color: 'var(--text-secondary)', whiteSpace: 'pre-line', fontSize: '0.9rem' }}>
                                    {strategyData?.analysis || "Lancez l'analyse de couverture pour obtenir des strat√©gies."}
                                </p>
                                {strategyData?.summary && (
                                    <div style={{ marginTop: '12px', padding: '10px', background: 'rgba(16, 185, 129, 0.1)', borderRadius: '8px' }}>
                                        üí° {strategyData.summary}
                                    </div>
                                )}
                            </div>
                        )}

                        {/* R√©sum√© de position */}
                        <div className="card animate-fade-in" style={{ marginBottom: '16px' }}>
                            <h4 style={{ marginBottom: '12px' }}>üìä R√©sum√© de votre position</h4>
                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                                <div style={{ padding: '10px', background: 'rgba(59, 130, 246, 0.1)', borderRadius: '8px' }}>
                                    <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Total mis√©</div>
                                    <div style={{ fontSize: '1.1rem', fontWeight: '700', fontFamily: 'Space Mono' }}>{totalStake.toLocaleString()} F</div>
                                </div>
                                <div style={{ padding: '10px', background: 'rgba(16, 185, 129, 0.1)', borderRadius: '8px' }}>
                                    <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Gain potentiel</div>
                                    <div style={{ fontSize: '1.1rem', fontWeight: '700', fontFamily: 'Space Mono', color: '#10b981' }}>+{totalPotentialProfit.toLocaleString()} F</div>
                                </div>
                                {totalCashout > 0 && (
                                    <div style={{ padding: '10px', background: 'rgba(245, 158, 11, 0.1)', borderRadius: '8px' }}>
                                        <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Cashout dispo</div>
                                        <div style={{ fontSize: '1.1rem', fontWeight: '700', fontFamily: 'Space Mono', color: '#f59e0b' }}>{totalCashout.toLocaleString()} F</div>
                                    </div>
                                )}
                                <div style={{ padding: '10px', background: 'rgba(239, 68, 68, 0.1)', borderRadius: '8px' }}>
                                    <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Perte max</div>
                                    <div style={{ fontSize: '1.1rem', fontWeight: '700', fontFamily: 'Space Mono', color: '#ef4444' }}>-{totalStake.toLocaleString()} F</div>
                                </div>
                            </div>
                        </div>

                        {/* Note */}
                        <div className="animate-fade-in" style={{
                            background: 'rgba(139, 92, 246, 0.1)',
                            border: '1px solid rgba(139, 92, 246, 0.3)',
                            borderRadius: '12px',
                            padding: '14px',
                            marginBottom: '16px'
                        }}>
                            <p style={{ color: '#a78bfa', fontSize: '0.8rem', marginBottom: '6px', fontWeight: '600' }}>
                                üß† {strategyData?.isDemo ? 'Analyse calcul√©e' : `Analyse ${strategyData?.engine || 'IA'}`}
                            </p>
                            <p style={{ color: 'var(--text-secondary)', fontSize: '0.75rem', lineHeight: '1.4', margin: 0 }}>
                                {strategies.length > 0 
                                    ? "Ces 4 strat√©gies sont calcul√©es math√©matiquement avec leurs sc√©narios de profit/perte."
                                    : "Renseignez les cashouts pour obtenir des strat√©gies de couverture d√©taill√©es."}
                            </p>
                            {strategyData?.generatedAt && (
                                <p style={{ color: 'var(--text-muted)', fontSize: '0.65rem', marginTop: '6px', marginBottom: 0 }}>
                                    G√©n√©r√©e le {new Date(strategyData.generatedAt).toLocaleString('fr-FR')}
                                </p>
                            )}
                        </div>

                        <button 
                            className="btn btn-success animate-fade-in" 
                            style={{ width: '100%', marginBottom: '20px' }}
                            onClick={() => {
                                if (selectedStrategy) showNotification(`Strat√©gie "${selectedStrategy.toUpperCase()}" appliqu√©e !`, "success");
                                navigate('pronostics');
                            }}
                        >
                            <Icons.Check />
                            {selectedStrategy ? `Appliquer et retourner` : 'Retour aux pronostics'}
                        </button>
                    </main>
                    
                    {/* ========== MODAL BREAK-EVEN MANUEL ========== */}
                    {showBreakEvenModal && (
                        <div style={{
                            position: 'fixed',
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            background: 'rgba(0,0,0,0.85)',
                            zIndex: 1000,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            padding: '20px'
                        }}>
                            <div style={{
                                background: 'var(--bg-card)',
                                borderRadius: '20px',
                                width: '100%',
                                maxWidth: '480px',
                                maxHeight: '90vh',
                                overflow: 'auto',
                                border: '1px solid var(--border-color)'
                            }}>
                                {/* Header */}
                                <div style={{
                                    padding: '20px',
                                    borderBottom: '1px solid var(--border-color)',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center'
                                }}>
                                    <div>
                                        <h3 style={{ margin: 0, marginBottom: '4px' }}>üßÆ Calculer le Break-even</h3>
                                        <p style={{ margin: 0, fontSize: '0.8rem', color: 'var(--text-muted)' }}>
                                            Seuil de rentabilit√© manuel
                                        </p>
                                    </div>
                                    <button
                                        onClick={() => {
                                            setShowBreakEvenModal(false);
                                            setBreakEvenResult(null);
                                        }}
                                        style={{
                                            background: 'rgba(239, 68, 68, 0.2)',
                                            border: 'none',
                                            borderRadius: '50%',
                                            width: '36px',
                                            height: '36px',
                                            cursor: 'pointer',
                                            color: '#ef4444',
                                            fontSize: '1.2rem'
                                        }}
                                    >
                                        ‚úï
                                    </button>
                                </div>
                                
                                <div style={{ padding: '20px' }}>
                                    {/* Section: Paris originaux */}
                                    <div style={{ marginBottom: '20px' }}>
                                        <h4 style={{ marginBottom: '12px', color: 'var(--accent-gold)', fontSize: '0.9rem' }}>
                                            üìã Vos paris originaux
                                        </h4>
                                        
                                        {/* Message si aucun pari */}
                                        {breakEvenBets.length === 0 && (
                                            <div style={{
                                                padding: '16px',
                                                background: 'rgba(245, 158, 11, 0.1)',
                                                border: '1px dashed rgba(245, 158, 11, 0.5)',
                                                borderRadius: '10px',
                                                marginBottom: '10px',
                                                textAlign: 'center'
                                            }}>
                                                <p style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', margin: 0 }}>
                                                    Aucun pari renseign√©. Ajoutez vos paris originaux ci-dessous.
                                                </p>
                                            </div>
                                        )}
                                        
                                        {breakEvenBets.map((bet, idx) => (
                                            <div key={idx} style={{
                                                padding: '12px',
                                                background: 'rgba(245, 158, 11, 0.1)',
                                                borderRadius: '10px',
                                                marginBottom: '10px',
                                                border: '1px solid rgba(245, 158, 11, 0.3)'
                                            }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                                                    <label style={{ fontSize: '0.8rem', color: 'var(--accent-gold)', fontWeight: '600' }}>
                                                        Pari {idx + 1}
                                                    </label>
                                                    {breakEvenBets.length > 1 && (
                                                        <button
                                                            onClick={() => removeBet(idx)}
                                                            style={{
                                                                background: 'rgba(239, 68, 68, 0.2)',
                                                                border: 'none',
                                                                borderRadius: '6px',
                                                                padding: '4px 8px',
                                                                color: '#ef4444',
                                                                cursor: 'pointer',
                                                                fontSize: '0.75rem'
                                                            }}
                                                        >
                                                            üóëÔ∏è Supprimer
                                                        </button>
                                                    )}
                                                </div>
                                                <div style={{ marginBottom: '8px' }}>
                                                    <label style={{ fontSize: '0.75rem', color: 'var(--text-muted)', display: 'block', marginBottom: '4px' }}>
                                                        Nom de l'option (optionnel)
                                                    </label>
                                                    <input
                                                        type="text"
                                                        value={bet.option}
                                                        onChange={(e) => updateBet(idx, 'option', e.target.value)}
                                                        placeholder="Ex: Victoire PSG, Over 2.5..."
                                                        style={{
                                                            width: '100%',
                                                            padding: '10px',
                                                            background: 'var(--bg-secondary)',
                                                            border: '1px solid var(--border-color)',
                                                            borderRadius: '8px',
                                                            color: 'var(--text-primary)',
                                                            fontSize: '0.9rem'
                                                        }}
                                                    />
                                                </div>
                                                <div style={{ display: 'flex', gap: '10px' }}>
                                                    <div style={{ flex: 1 }}>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-muted)', display: 'block', marginBottom: '4px' }}>
                                                            Mise (FCFA) *
                                                        </label>
                                                        <input
                                                            type="number"
                                                            value={bet.stake}
                                                            onChange={(e) => updateBet(idx, 'stake', e.target.value)}
                                                            placeholder="1000"
                                                            style={{
                                                                width: '100%',
                                                                padding: '10px',
                                                                background: 'var(--bg-secondary)',
                                                                border: '1px solid var(--border-color)',
                                                                borderRadius: '8px',
                                                                color: 'var(--text-primary)',
                                                                fontSize: '0.9rem'
                                                            }}
                                                        />
                                                    </div>
                                                    <div style={{ flex: 1 }}>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-muted)', display: 'block', marginBottom: '4px' }}>
                                                            Cote *
                                                        </label>
                                                        <input
                                                            type="number"
                                                            step="0.01"
                                                            value={bet.odds}
                                                            onChange={(e) => updateBet(idx, 'odds', e.target.value)}
                                                            placeholder="1.85"
                                                            style={{
                                                                width: '100%',
                                                                padding: '10px',
                                                                background: 'var(--bg-secondary)',
                                                                border: '1px solid var(--border-color)',
                                                                borderRadius: '8px',
                                                                color: 'var(--text-primary)',
                                                                fontSize: '0.9rem'
                                                            }}
                                                        />
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                        
                                        {/* Bouton ajouter un pari */}
                                        <button
                                            onClick={addBet}
                                            style={{
                                                width: '100%',
                                                padding: '10px',
                                                background: 'rgba(245, 158, 11, 0.1)',
                                                border: '1px dashed rgba(245, 158, 11, 0.5)',
                                                borderRadius: '8px',
                                                color: 'var(--accent-gold)',
                                                cursor: 'pointer',
                                                fontSize: '0.85rem'
                                            }}
                                        >
                                            + Ajouter un pari original
                                        </button>
                                    </div>
                                    
                                    {/* Section: Options de couverture */}
                                    <div style={{ marginBottom: '20px' }}>
                                        <h4 style={{ marginBottom: '12px', color: 'var(--accent-blue)', fontSize: '0.9rem' }}>
                                            üõ°Ô∏è Options de couverture (cotes live)
                                        </h4>
                                        {breakEvenHedgeOptions.map((hedge, idx) => (
                                            <div key={idx} style={{
                                                padding: '12px',
                                                background: 'rgba(59, 130, 246, 0.1)',
                                                borderRadius: '10px',
                                                marginBottom: '10px',
                                                border: '1px solid rgba(59, 130, 246, 0.3)'
                                            }}>
                                                <div style={{ display: 'flex', gap: '10px', alignItems: 'flex-end' }}>
                                                    <div style={{ flex: 2 }}>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-muted)', display: 'block', marginBottom: '4px' }}>
                                                            Type de pari oppos√©
                                                        </label>
                                                        <input
                                                            type="text"
                                                            value={hedge.type}
                                                            onChange={(e) => updateHedgeOption(idx, 'type', e.target.value)}
                                                            placeholder="Ex: Nul ou D√©faite, Under 2.5..."
                                                            style={{
                                                                width: '100%',
                                                                padding: '10px',
                                                                background: 'var(--bg-secondary)',
                                                                border: '1px solid var(--border-color)',
                                                                borderRadius: '8px',
                                                                color: 'var(--text-primary)',
                                                                fontSize: '0.9rem'
                                                            }}
                                                        />
                                                    </div>
                                                    <div style={{ flex: 1 }}>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-muted)', display: 'block', marginBottom: '4px' }}>
                                                            Cote live
                                                        </label>
                                                        <input
                                                            type="number"
                                                            step="0.01"
                                                            value={hedge.odds}
                                                            onChange={(e) => updateHedgeOption(idx, 'odds', e.target.value)}
                                                            placeholder="2.10"
                                                            style={{
                                                                width: '100%',
                                                                padding: '10px',
                                                                background: 'var(--bg-secondary)',
                                                                border: '1px solid var(--border-color)',
                                                                borderRadius: '8px',
                                                                color: 'var(--text-primary)',
                                                                fontSize: '0.9rem'
                                                            }}
                                                        />
                                                    </div>
                                                    {breakEvenHedgeOptions.length > 1 && (
                                                        <button
                                                            onClick={() => removeHedgeOption(idx)}
                                                            style={{
                                                                background: 'rgba(239, 68, 68, 0.2)',
                                                                border: 'none',
                                                                borderRadius: '8px',
                                                                padding: '10px',
                                                                color: '#ef4444',
                                                                cursor: 'pointer'
                                                            }}
                                                        >
                                                            üóëÔ∏è
                                                        </button>
                                                    )}
                                                </div>
                                            </div>
                                        ))}
                                        <button
                                            onClick={addHedgeOption}
                                            style={{
                                                width: '100%',
                                                padding: '10px',
                                                background: 'rgba(59, 130, 246, 0.1)',
                                                border: '1px dashed rgba(59, 130, 246, 0.5)',
                                                borderRadius: '8px',
                                                color: 'var(--accent-blue)',
                                                cursor: 'pointer',
                                                fontSize: '0.85rem'
                                            }}
                                        >
                                            + Ajouter une option de couverture
                                        </button>
                                    </div>
                                    
                                    {/* Bouton Calculer */}
                                    <button
                                        className="btn btn-primary"
                                        style={{
                                            width: '100%',
                                            padding: '14px',
                                            marginBottom: '16px',
                                            background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                                            border: 'none',
                                            fontSize: '1rem',
                                            fontWeight: '600'
                                        }}
                                        onClick={calculateManualBreakEven}
                                        disabled={calculatingBreakEven}
                                    >
                                        {calculatingBreakEven ? 'üßÆ Calcul en cours...' : 'üßÆ Calculer le Break-even'}
                                    </button>
                                    
                                    {/* R√©sultats */}
                                    {breakEvenResult && (
                                        <div style={{
                                            background: 'linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.05) 100%)',
                                            border: '2px solid rgba(16, 185, 129, 0.5)',
                                            borderRadius: '12px',
                                            padding: '16px'
                                        }}>
                                            <h4 style={{ color: '#10b981', marginBottom: '12px' }}>‚úÖ R√©sultats du calcul</h4>
                                            
                                            {/* R√©sum√© */}
                                            <div style={{
                                                display: 'grid',
                                                gridTemplateColumns: 'repeat(2, 1fr)',
                                                gap: '10px',
                                                marginBottom: '16px'
                                            }}>
                                                <div style={{ padding: '10px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px', textAlign: 'center' }}>
                                                    <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Total investi</div>
                                                    <div style={{ fontSize: '1.1rem', fontWeight: '700', color: 'var(--text-primary)' }}>
                                                        {breakEvenResult.summary?.totalInvested?.toLocaleString() || 0} F
                                                    </div>
                                                </div>
                                                <div style={{ padding: '10px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px', textAlign: 'center' }}>
                                                    <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>Retour potentiel</div>
                                                    <div style={{ fontSize: '1.1rem', fontWeight: '700', color: '#10b981' }}>
                                                        {breakEvenResult.summary?.totalPotentialReturn?.toLocaleString() || 0} F
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            {/* Meilleure option */}
                                            {breakEvenResult.bestOption && (
                                                <div style={{
                                                    padding: '14px',
                                                    background: 'rgba(245, 158, 11, 0.15)',
                                                    borderRadius: '10px',
                                                    border: '1px solid rgba(245, 158, 11, 0.3)',
                                                    marginBottom: '12px'
                                                }}>
                                                    <div style={{ fontWeight: '700', color: 'var(--accent-gold)', marginBottom: '8px' }}>
                                                        üéØ RECOMMANDATION
                                                    </div>
                                                    <p style={{ fontSize: '0.85rem', color: 'var(--text-primary)', margin: '0 0 10px 0' }}>
                                                        {breakEvenResult.recommendation}
                                                    </p>
                                                    <div style={{ display: 'flex', gap: '10px' }}>
                                                        <div style={{ flex: 1, padding: '8px', background: 'rgba(0,0,0,0.2)', borderRadius: '6px', textAlign: 'center' }}>
                                                            <div style={{ fontSize: '0.65rem', color: 'var(--text-muted)' }}>Mise hedge</div>
                                                            <div style={{ fontSize: '0.95rem', fontWeight: '700', color: 'var(--accent-gold)' }}>
                                                                {breakEvenResult.bestOption.perfectBreakEvenStake?.toLocaleString()} F
                                                            </div>
                                                        </div>
                                                        <div style={{ flex: 1, padding: '8px', background: 'rgba(0,0,0,0.2)', borderRadius: '6px', textAlign: 'center' }}>
                                                            <div style={{ fontSize: '0.65rem', color: 'var(--text-muted)' }}>Sc√©nario 1</div>
                                                            <div style={{ fontSize: '0.95rem', fontWeight: '700', color: breakEvenResult.bestOption.perfectScenario1 >= 0 ? '#10b981' : '#ef4444' }}>
                                                                {breakEvenResult.bestOption.perfectScenario1 >= 0 ? '+' : ''}{breakEvenResult.bestOption.perfectScenario1?.toLocaleString()} F
                                                            </div>
                                                        </div>
                                                        <div style={{ flex: 1, padding: '8px', background: 'rgba(0,0,0,0.2)', borderRadius: '6px', textAlign: 'center' }}>
                                                            <div style={{ fontSize: '0.65rem', color: 'var(--text-muted)' }}>Sc√©nario 2</div>
                                                            <div style={{ fontSize: '0.95rem', fontWeight: '700', color: breakEvenResult.bestOption.perfectScenario2 >= 0 ? '#10b981' : '#ef4444' }}>
                                                                {breakEvenResult.bestOption.perfectScenario2 >= 0 ? '+' : ''}{breakEvenResult.bestOption.perfectScenario2?.toLocaleString()} F
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            )}
                                            
                                            {/* Toutes les options */}
                                            {breakEvenResult.breakEvenResults?.length > 1 && (
                                                <div>
                                                    <div style={{ fontSize: '0.8rem', color: 'var(--text-muted)', marginBottom: '8px' }}>
                                                        Autres options analys√©es:
                                                    </div>
                                                    {breakEvenResult.breakEvenResults.filter(r => r.hedgeType !== breakEvenResult.bestOption?.hedgeType).map((result, idx) => (
                                                        <div key={idx} style={{
                                                            padding: '10px',
                                                            background: 'rgba(0,0,0,0.15)',
                                                            borderRadius: '8px',
                                                            marginBottom: '6px',
                                                            fontSize: '0.8rem'
                                                        }}>
                                                            <span style={{ fontWeight: '600' }}>{result.hedgeType}</span>
                                                            <span style={{ color: 'var(--text-muted)' }}> @{result.hedgeOdds?.toFixed(2)}</span>
                                                            <span style={{ marginLeft: '10px' }}>‚Üí Mise: {result.perfectBreakEvenStake?.toLocaleString()} F</span>
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}
                    <BottomNav />
                </>
            );
        };

        const CapitalPage = () => {
            const { user, requireAuth, navigate, API_BASE_URL, showNotification, apiCallWithAuth } = useApp();
            const [stats, setStats] = useState(null);
            const [history, setHistory] = useState([]);
            const [loading, setLoading] = useState(true);
            const [showAddModal, setShowAddModal] = useState(false);
            const [lastBalance, setLastBalance] = useState(null);
            const [generatingReco, setGeneratingReco] = useState(false);
            const [recommendations, setRecommendations] = useState(null);
            
            // √âtats pour le formulaire - g√©r√©s s√©par√©ment pour √©viter les re-renders
            const [formBalance, setFormBalance] = useState('');
            const [formMotif, setFormMotif] = useState('D√©p√¥t');
            const [formDescription, setFormDescription] = useState('');

            // Charger les donn√©es
            useEffect(() => {
                if (user) {
                    fetchData();
                } else {
                    // Mode d√©mo
                    const demoHistory = [
                        { id: 'demo_1', oldBalance: 0, newBalance: 10000, difference: 10000, motif: 'D√©p√¥t', description: 'D√©p√¥t initial', timestamp: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000) },
                        { id: 'demo_2', oldBalance: 10000, newBalance: 12500, difference: 2500, motif: 'B√©n√©fice', description: 'Gain pari', timestamp: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000) },
                        { id: 'demo_3', oldBalance: 12500, newBalance: 11000, difference: -1500, motif: 'Perte', description: 'Perte pari', timestamp: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },
                        { id: 'demo_4', oldBalance: 11000, newBalance: 14000, difference: 3000, motif: 'B√©n√©fice', description: 'Gain combin√©', timestamp: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000) },
                        { id: 'demo_5', oldBalance: 14000, newBalance: 13000, difference: -1000, motif: 'Perte', description: '', timestamp: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000) }
                    ];
                    setStats({
                        currentBalance: 13000,
                        totalGains: 5500,
                        totalLosses: 2500,
                        netProfit: 3000,
                        totalDeposits: 10000,
                        totalWithdrawals: 0,
                        entriesCount: 5
                    });
                    setHistory(demoHistory);
                    setLastBalance({ balance: 13000 });
                    setLoading(false);
                }
            }, [user]);

            const fetchData = async () => {
                try {
                    setLoading(true);
                    
                    const [statsRes, historyRes, lastRes] = await Promise.all([
                        apiCallWithAuth(`${API_BASE_URL}/balance-entries/stats`),
                        apiCallWithAuth(`${API_BASE_URL}/balance-entries/history?limit=50`),
                        apiCallWithAuth(`${API_BASE_URL}/balance-entries/last`)
                    ]);

                    if (statsRes.ok) {
                        const statsData = await statsRes.json();
                        setStats(statsData.stats);
                    }

                    if (historyRes.ok) {
                        const historyData = await historyRes.json();
                        setHistory(historyData.entries || []);
                    }

                    if (lastRes.ok) {
                        const lastData = await lastRes.json();
                        setLastBalance(lastData.lastBalance);
                    }

                } catch (error) {
                    console.error("Error fetching capital data:", error);
                    showNotification("Erreur lors du chargement", "error");
                } finally {
                    setLoading(false);
                }
            };

            const handleAddEntry = async () => {
                if (!formBalance || !formMotif) {
                    showNotification("Veuillez remplir tous les champs requis", "error");
                    return;
                }

                try {
                    const response = await apiCallWithAuth(
                        `${API_BASE_URL}/balance-entries/add`,
                        {
                            method: 'POST',
                            body: JSON.stringify({
                                newBalance: parseFloat(formBalance),
                                motif: formMotif,
                                description: formDescription
                            })
                        }
                    );

                    if (response.ok) {
                        const data = await response.json();
                        showNotification(`‚úÖ Solde mis √† jour: ${data.entry.newBalance.toLocaleString()} FCFA`, "success");
                        setShowAddModal(false);
                        setFormBalance('');
                        setFormMotif('D√©p√¥t');
                        setFormDescription('');
                        fetchData();
                    } else {
                        const error = await response.json();
                        showNotification(error.error || "Erreur lors de l'ajout", "error");
                    }
                } catch (error) {
                    console.error("Error adding entry:", error);
                    showNotification("Erreur de connexion", "error");
                }
            };

            // G√©n√©rer les recommandations IA
            const generateRecommendations = async () => {
                setGeneratingReco(true);
                try {
                    const response = await apiCallWithAuth(
                        `${API_BASE_URL}/capital/recommendations`,
                        {
                            method: 'POST',
                            body: JSON.stringify({
                                stats,
                                history: history.slice(0, 20)
                            })
                        }
                    );

                    if (response.ok) {
                        const data = await response.json();
                        setRecommendations(data.recommendations);
                        showNotification("‚úÖ Recommandations g√©n√©r√©es!", "success");
                    } else {
                        // Mode d√©mo
                        setRecommendations({
                            analysis: `üìä **Analyse de votre capital**\n\nVotre solde actuel est de ${(stats?.currentBalance || 0).toLocaleString()} FCFA.\n\n‚úÖ **Points positifs:**\n- Profit net positif de ${(stats?.netProfit || 0).toLocaleString()} FCFA\n- Bonne gestion des mises\n\n‚ö†Ô∏è **Recommandations:**\n- Limitez vos mises √† 5% du capital par pari\n- √âvitez de chasser vos pertes\n- Fixez-vous un objectif de profit quotidien\n\nüí° **Conseil:** Avec un capital de ${(stats?.currentBalance || 0).toLocaleString()} FCFA, vos mises ne devraient pas d√©passer ${Math.round((stats?.currentBalance || 0) * 0.05).toLocaleString()} FCFA par pari.`,
                            riskLevel: stats?.netProfit >= 0 ? 'low' : 'medium',
                            suggestedMaxBet: Math.round((stats?.currentBalance || 0) * 0.05)
                        });
                        showNotification("‚úÖ Recommandations g√©n√©r√©es (d√©mo)", "success");
                    }
                } catch (error) {
                    console.error("Error generating recommendations:", error);
                    // Fallback d√©mo
                    setRecommendations({
                        analysis: `Bas√© sur votre historique, voici mes recommandations:\n\n1. Votre capital actuel: ${(stats?.currentBalance || 0).toLocaleString()} FCFA\n2. Mise maximale recommand√©e: ${Math.round((stats?.currentBalance || 0) * 0.05).toLocaleString()} FCFA (5%)\n3. Continuez √† diversifier vos paris`,
                        riskLevel: 'medium',
                        suggestedMaxBet: Math.round((stats?.currentBalance || 0) * 0.05)
                    });
                } finally {
                    setGeneratingReco(false);
                }
            };

            const formatDate = (timestamp) => {
                if (!timestamp) return 'N/A';
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                
                if (diffDays === 0) return "Aujourd'hui";
                if (diffDays === 1) return "Hier";
                if (diffDays < 7) return `Il y a ${diffDays}j`;
                
                return date.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
            };

            const getMotifIcon = (motif) => {
                switch(motif) {
                    case 'D√©p√¥t': return 'üì•';
                    case 'Retrait': return 'üì§';
                    case 'B√©n√©fice': return 'üí∞';
                    case 'Perte': return 'üìâ';
                    default: return 'üíµ';
                }
            };

            const getMotifColor = (motif) => {
                switch(motif) {
                    case 'D√©p√¥t': return 'var(--accent-blue)';
                    case 'Retrait': return 'var(--accent-gold)';
                    case 'B√©n√©fice': return 'var(--accent-green)';
                    case 'Perte': return 'var(--accent-red)';
                    default: return 'var(--text-primary)';
                }
            };

            // Composant Graphique d'√©volution
            const BalanceChart = ({ data }) => {
                if (!data || data.length < 2) return null;

                // Inverser pour avoir l'ordre chronologique
                const chartData = [...data].reverse();
                const balances = chartData.map(d => d.newBalance);
                const maxBalance = Math.max(...balances);
                const minBalance = Math.min(...balances);
                const range = maxBalance - minBalance || 1;
                
                const width = 100;
                const height = 60;
                const padding = 5;
                
                // Cr√©er les points du graphique
                const points = chartData.map((d, i) => {
                    const x = padding + (i / (chartData.length - 1)) * (width - 2 * padding);
                    const y = height - padding - ((d.newBalance - minBalance) / range) * (height - 2 * padding);
                    return `${x},${y}`;
                }).join(' ');

                // Couleur bas√©e sur la tendance
                const trend = balances[balances.length - 1] >= balances[0];
                const lineColor = trend ? '#10b981' : '#ef4444';
                const fillColor = trend ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)';

                // Points pour le fill (ajouter les coins en bas)
                const fillPoints = `${padding},${height - padding} ${points} ${width - padding},${height - padding}`;

                return (
                    <div className="card" style={{ marginBottom: '16px', padding: '16px' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                            <h4 style={{ fontSize: '0.95rem', color: 'var(--text-primary)' }}>üìà √âvolution du solde</h4>
                            <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                {chartData.length} entr√©es
                            </span>
                        </div>
                        <svg viewBox={`0 0 ${width} ${height}`} style={{ width: '100%', height: '120px' }}>
                            {/* Grille horizontale */}
                            <line x1={padding} y1={height/3} x2={width-padding} y2={height/3} stroke="rgba(255,255,255,0.1)" strokeWidth="0.5"/>
                            <line x1={padding} y1={2*height/3} x2={width-padding} y2={2*height/3} stroke="rgba(255,255,255,0.1)" strokeWidth="0.5"/>
                            
                            {/* Zone remplie */}
                            <polygon points={fillPoints} fill={fillColor}/>
                            
                            {/* Ligne du graphique */}
                            <polyline
                                points={points}
                                fill="none"
                                stroke={lineColor}
                                strokeWidth="2"
                                strokeLinecap="round"
                                strokeLinejoin="round"
                            />
                            
                            {/* Points */}
                            {chartData.map((d, i) => {
                                const x = padding + (i / (chartData.length - 1)) * (width - 2 * padding);
                                const y = height - padding - ((d.newBalance - minBalance) / range) * (height - 2 * padding);
                                return (
                                    <circle key={i} cx={x} cy={y} r="1.5" fill={lineColor}/>
                                );
                            })}
                        </svg>
                        <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.75rem', color: 'var(--text-muted)', marginTop: '8px' }}>
                            <span>{formatDate(chartData[0]?.timestamp)}</span>
                            <span style={{ color: lineColor, fontWeight: '600' }}>
                                {trend ? '‚Üó' : '‚Üò'} {((balances[balances.length-1] - balances[0]) / balances[0] * 100).toFixed(1)}%
                            </span>
                            <span>{formatDate(chartData[chartData.length-1]?.timestamp)}</span>
                        </div>
                    </div>
                );
            };

            // Calculer la diff√©rence pr√©dite
            const predictedDifference = formBalance && lastBalance 
                ? parseFloat(formBalance) - lastBalance.balance
                : 0;

            return (
                <>
                    <Header showBack={false} title="Suivi du capital" />
                    <main className="main-content" style={{ paddingBottom: '100px' }}>
                        {loading ? (
                            <div style={{ 
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center',
                                justifyContent: 'center',
                                padding: '60px 20px',
                                minHeight: '60vh'
                            }}>
                                <div style={{
                                    fontSize: '2rem',
                                    fontWeight: 'bold',
                                    marginBottom: '24px',
                                    animation: 'pulse 1.5s ease-in-out infinite'
                                }}>
                                    <span style={{ color: 'var(--accent-gold)' }}>E</span>
                                    <span style={{ color: 'white' }}>-Cauri</span>
                                </div>
                                <div className="spinner"></div>
                                <p style={{ color: 'var(--text-muted)', marginTop: '16px' }}>Chargement...</p>
                            </div>
                        ) : (
                            <>
                                {/* Solde actuel */}
                                <div className="card animate-fade-in" style={{ marginBottom: '16px', textAlign: 'center', padding: '20px 16px' }}>
                                    <div style={{ color: 'var(--text-muted)', fontSize: '0.85rem', marginBottom: '8px' }}>
                                        Solde actuel
                                    </div>
                                    <div style={{ 
                                        fontSize: 'clamp(1.8rem, 8vw, 2.5rem)', 
                                        fontWeight: '700', 
                                        color: 'var(--accent-gold)',
                                        fontFamily: 'Space Mono, monospace',
                                        marginBottom: '16px',
                                        wordBreak: 'break-word'
                                    }}>
                                        {(stats?.currentBalance || 0).toLocaleString()} <span style={{ fontSize: 'clamp(0.9rem, 4vw, 1.2rem)' }}>FCFA</span>
                                    </div>
                                    <button 
                                        className="btn btn-primary" 
                                        style={{ width: '100%', maxWidth: '300px' }}
                                        onClick={() => setShowAddModal(true)}
                                    >
                                        ‚ûï Ajouter un solde
                                    </button>
                                </div>

                                {/* Graphique d'√©volution */}
                                {history.length >= 2 && <BalanceChart data={history} />}

                                {/* Statistiques - Grid responsive */}
                                <div style={{ 
                                    display: 'grid', 
                                    gridTemplateColumns: 'repeat(2, 1fr)', 
                                    gap: '10px',
                                    marginBottom: '16px'
                                }}>
                                    <div className="card" style={{ padding: '14px', background: 'rgba(16, 185, 129, 0.1)', border: '1px solid rgba(16, 185, 129, 0.3)' }}>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginBottom: '4px' }}>Gains</div>
                                        <div style={{ fontSize: 'clamp(1rem, 5vw, 1.3rem)', fontWeight: '600', color: 'var(--accent-green)' }}>
                                            +{(stats?.totalGains || 0).toLocaleString()} F
                                        </div>
                                    </div>
                                    <div className="card" style={{ padding: '14px', background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)' }}>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginBottom: '4px' }}>Pertes</div>
                                        <div style={{ fontSize: 'clamp(1rem, 5vw, 1.3rem)', fontWeight: '600', color: 'var(--accent-red)' }}>
                                            -{(stats?.totalLosses || 0).toLocaleString()} F
                                        </div>
                                    </div>
                                    <div className="card" style={{ padding: '14px', background: 'rgba(59, 130, 246, 0.1)', border: '1px solid rgba(59, 130, 246, 0.3)' }}>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginBottom: '4px' }}>D√©p√¥ts</div>
                                        <div style={{ fontSize: 'clamp(1rem, 5vw, 1.3rem)', fontWeight: '600', color: 'var(--accent-blue)' }}>
                                            +{(stats?.totalDeposits || 0).toLocaleString()} F
                                        </div>
                                    </div>
                                    <div className="card" style={{ padding: '14px', background: 'rgba(245, 158, 11, 0.1)', border: '1px solid rgba(245, 158, 11, 0.3)' }}>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.75rem', marginBottom: '4px' }}>Retraits</div>
                                        <div style={{ fontSize: 'clamp(1rem, 5vw, 1.3rem)', fontWeight: '600', color: 'var(--accent-gold)' }}>
                                            -{(stats?.totalWithdrawals || 0).toLocaleString()} F
                                        </div>
                                    </div>
                                </div>

                                {/* Profit net */}
                                <div className="card" style={{ 
                                    marginBottom: '16px',
                                    padding: '16px',
                                    background: stats?.netProfit >= 0 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)',
                                    border: stats?.netProfit >= 0 ? '1px solid rgba(16, 185, 129, 0.3)' : '1px solid rgba(239, 68, 68, 0.3)'
                                }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                        <div>
                                            <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem', marginBottom: '4px' }}>
                                                Profit net (Gains - Pertes)
                                            </div>
                                            <div style={{ 
                                                fontSize: 'clamp(1.4rem, 6vw, 1.8rem)', 
                                                fontWeight: '700',
                                                color: stats?.netProfit >= 0 ? 'var(--accent-green)' : 'var(--accent-red)',
                                                fontFamily: 'Space Mono, monospace'
                                            }}>
                                                {stats?.netProfit >= 0 ? '+' : ''}{(stats?.netProfit || 0).toLocaleString()} F
                                            </div>
                                        </div>
                                        <div style={{ fontSize: '2rem' }}>
                                            {stats?.netProfit >= 0 ? 'üìà' : 'üìâ'}
                                        </div>
                                    </div>
                                </div>

                                {/* Bouton Recommandations IA */}
                                <div className="card" style={{ marginBottom: '16px', padding: '16px' }}>
                                    <button 
                                        className="btn btn-secondary" 
                                        style={{ 
                                            width: '100%',
                                            background: 'linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(59, 130, 246, 0.2) 100%)',
                                            border: '1px solid rgba(139, 92, 246, 0.4)'
                                        }}
                                        onClick={generateRecommendations}
                                        disabled={generatingReco}
                                    >
                                        {generatingReco ? (
                                            <>üîÑ Analyse en cours...</>
                                        ) : (
                                            <>üß† Recommandations IA</>
                                        )}
                                    </button>
                                    
                                    {/* Afficher les recommandations */}
                                    {recommendations && (
                                        <div style={{ 
                                            marginTop: '16px', 
                                            padding: '16px', 
                                            background: 'rgba(0,0,0,0.2)', 
                                            borderRadius: '10px',
                                            fontSize: '0.9rem',
                                            lineHeight: '1.6'
                                        }}>
                                            <div style={{ 
                                                display: 'flex', 
                                                alignItems: 'center', 
                                                gap: '8px', 
                                                marginBottom: '12px',
                                                paddingBottom: '12px',
                                                borderBottom: '1px solid rgba(255,255,255,0.1)'
                                            }}>
                                                <span style={{ fontSize: '1.2rem' }}>üí°</span>
                                                <span style={{ fontWeight: '600', color: 'var(--accent-gold)' }}>Conseils personnalis√©s</span>
                                            </div>
                                            <div style={{ color: 'var(--text-secondary)', whiteSpace: 'pre-wrap' }}>
                                                {recommendations.analysis}
                                            </div>
                                            {recommendations.suggestedMaxBet && (
                                                <div style={{ 
                                                    marginTop: '12px', 
                                                    padding: '10px', 
                                                    background: 'rgba(245, 158, 11, 0.1)', 
                                                    borderRadius: '8px',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center'
                                                }}>
                                                    <span style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>Mise max recommand√©e:</span>
                                                    <span style={{ fontWeight: '700', color: 'var(--accent-gold)', fontFamily: 'Space Mono' }}>
                                                        {recommendations.suggestedMaxBet.toLocaleString()} F
                                                    </span>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>

                                {/* Historique */}
                                <div className="card" style={{ padding: '16px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
                                        <h3 style={{ fontSize: '1rem' }}>üìú Historique</h3>
                                        <span style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>
                                            {history.length} entr√©e{history.length > 1 ? 's' : ''}
                                        </span>
                                    </div>

                                    {history.length === 0 ? (
                                        <div style={{ textAlign: 'center', padding: '30px 20px', color: 'var(--text-muted)' }}>
                                            <div style={{ fontSize: '2.5rem', marginBottom: '12px' }}>üíº</div>
                                            <p>Aucune entr√©e pour le moment</p>
                                            <p style={{ fontSize: '0.8rem' }}>Ajoutez votre premier solde</p>
                                        </div>
                                    ) : (
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                                            {history.slice(0, 10).map((entry, index) => (
                                                <div key={entry.id} style={{
                                                    padding: '12px',
                                                    background: 'rgba(255,255,255,0.03)',
                                                    borderRadius: '10px',
                                                    border: '1px solid rgba(255,255,255,0.05)'
                                                }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                                                            <span style={{ fontSize: '1.3rem' }}>{getMotifIcon(entry.motif)}</span>
                                                            <div>
                                                                <div style={{ fontSize: '0.9rem', fontWeight: '600', color: getMotifColor(entry.motif) }}>
                                                                    {entry.motif}
                                                                </div>
                                                                <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>
                                                                    {formatDate(entry.timestamp)}
                                                                </div>
                                                            </div>
                                                        </div>
                                                        <div style={{ textAlign: 'right' }}>
                                                            <div style={{ 
                                                                fontSize: '1rem', 
                                                                fontWeight: '700',
                                                                color: entry.difference >= 0 ? 'var(--accent-green)' : 'var(--accent-red)',
                                                                fontFamily: 'Space Mono, monospace'
                                                            }}>
                                                                {entry.difference >= 0 ? '+' : ''}{entry.difference.toLocaleString()} F
                                                            </div>
                                                            <div style={{ fontSize: '0.7rem', color: 'var(--text-muted)' }}>
                                                                ‚Üí {entry.newBalance.toLocaleString()} F
                                                            </div>
                                                        </div>
                                                    </div>
                                                    {entry.description && (
                                                        <div style={{ 
                                                            fontSize: '0.75rem', 
                                                            color: 'var(--text-secondary)',
                                                            fontStyle: 'italic',
                                                            marginTop: '6px',
                                                            paddingTop: '6px',
                                                            borderTop: '1px solid rgba(255,255,255,0.05)'
                                                        }}>
                                                            {entry.description}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                            {history.length > 10 && (
                                                <div style={{ textAlign: 'center', padding: '10px', color: 'var(--text-muted)', fontSize: '0.85rem' }}>
                                                    ... et {history.length - 10} autre{history.length - 10 > 1 ? 's' : ''} entr√©e{history.length - 10 > 1 ? 's' : ''}
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            </>
                        )}
                    </main>
                    <BottomNav />
                    
                    {/* Modal d'ajout - HORS du flux de render principal */}
                    {showAddModal && (
                        <div style={{
                            position: 'fixed',
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            background: 'rgba(0,0,0,0.9)',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            zIndex: 2000,
                            padding: '16px'
                        }} onClick={(e) => {
                            if (e.target === e.currentTarget) setShowAddModal(false);
                        }}>
                            <div className="card" style={{ 
                                width: '100%', 
                                maxWidth: '400px',
                                maxHeight: '90vh',
                                overflowY: 'auto',
                                padding: '20px'
                            }} onClick={(e) => e.stopPropagation()}>
                                <h3 style={{ marginBottom: '8px', color: 'var(--accent-gold)' }}>üí∞ Ajouter un solde</h3>
                                <p style={{ color: 'var(--text-muted)', fontSize: '0.85rem', marginBottom: '20px' }}>
                                    Dernier solde: <strong style={{ color: 'var(--accent-gold)' }}>{(lastBalance?.balance || 0).toLocaleString()} FCFA</strong>
                                </p>

                                {/* Montant */}
                                <div style={{ marginBottom: '16px' }}>
                                    <label style={{ display: 'block', marginBottom: '8px', color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                        Nouveau solde (FCFA) <span style={{ color: 'var(--accent-red)' }}>*</span>
                                    </label>
                                    <input
                                        type="number"
                                        inputMode="numeric"
                                        className="input"
                                        placeholder="Ex: 55000"
                                        defaultValue={formBalance}
                                        onBlur={(e) => setFormBalance(e.target.value)}
                                        onKeyUp={(e) => {
                                            if (e.key === 'Enter') {
                                                setFormBalance(e.target.value);
                                            }
                                        }}
                                        style={{ width: '100%', fontSize: '1.1rem', fontWeight: '600' }}
                                        autoFocus
                                    />
                                    {formBalance && parseFloat(formBalance) !== (lastBalance?.balance || 0) && (
                                        <div style={{ 
                                            marginTop: '6px', 
                                            padding: '8px 12px',
                                            background: (parseFloat(formBalance) - (lastBalance?.balance || 0)) > 0 
                                                ? 'rgba(16, 185, 129, 0.1)' 
                                                : 'rgba(239, 68, 68, 0.1)',
                                            borderRadius: '6px',
                                            fontSize: '0.85rem',
                                            color: (parseFloat(formBalance) - (lastBalance?.balance || 0)) > 0 
                                                ? 'var(--accent-green)' 
                                                : 'var(--accent-red)'
                                        }}>
                                            Diff√©rence: {(parseFloat(formBalance) - (lastBalance?.balance || 0)) > 0 ? '+' : ''}
                                            {(parseFloat(formBalance) - (lastBalance?.balance || 0)).toLocaleString()} FCFA
                                        </div>
                                    )}
                                </div>

                                {/* Motif */}
                                <div style={{ marginBottom: '16px' }}>
                                    <label style={{ display: 'block', marginBottom: '8px', color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                        Motif <span style={{ color: 'var(--accent-red)' }}>*</span>
                                    </label>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                                        {['D√©p√¥t', 'Retrait', 'B√©n√©fice', 'Perte'].map(motif => (
                                            <button
                                                key={motif}
                                                type="button"
                                                className={`btn ${formMotif === motif ? 'btn-primary' : 'btn-secondary'}`}
                                                onClick={() => setFormMotif(motif)}
                                                style={{ padding: '10px 8px', fontSize: '0.85rem' }}
                                            >
                                                {getMotifIcon(motif)} {motif}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Description */}
                                <div style={{ marginBottom: '20px' }}>
                                    <label style={{ display: 'block', marginBottom: '8px', color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                        Description (optionnelle)
                                    </label>
                                    <input
                                        type="text"
                                        className="input"
                                        placeholder="Ex: D√©p√¥t via Mobile Money"
                                        defaultValue={formDescription}
                                        onBlur={(e) => setFormDescription(e.target.value)}
                                        style={{ width: '100%' }}
                                    />
                                </div>

                                <div style={{ display: 'flex', gap: '12px' }}>
                                    <button 
                                        type="button"
                                        className="btn btn-secondary" 
                                        style={{ flex: 1 }} 
                                        onClick={() => {
                                            setShowAddModal(false);
                                            setFormBalance('');
                                            setFormMotif('D√©p√¥t');
                                            setFormDescription('');
                                        }}
                                    >
                                        Annuler
                                    </button>
                                    <button 
                                        type="button"
                                        className="btn btn-primary" 
                                        style={{ flex: 1 }} 
                                        onClick={() => {
                                            // R√©cup√©rer les valeurs des inputs directement
                                            const balanceInput = document.querySelector('input[type="number"]');
                                            const descInput = document.querySelectorAll('input[type="text"]')[0];
                                            if (balanceInput) setFormBalance(balanceInput.value);
                                            if (descInput) setFormDescription(descInput.value);
                                            
                                            setTimeout(() => handleAddEntry(), 50);
                                        }}
                                    >
                                        Confirmer
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </>
            );
        };
        const RecommendationsPage = () => {
            const { user, navigate, API_BASE_URL, showNotification } = useApp();
            const [recommendations, setRecommendations] = useState(null);
            const [userStats, setUserStats] = useState(null);
            const [loading, setLoading] = useState(false);
            const [generating, setGenerating] = useState(false);

            // Charger les recommandations existantes
            useEffect(() => {
                const fetchRecommendations = async () => {
                    if (!user) return;
                    
                    setLoading(true);
                    try {
                        const token = localStorage.getItem('authToken');
                        const response = await fetch(`${API_BASE_URL}/user/recommendations`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            if (data.recommendations?.length > 0) {
                                setRecommendations(data.recommendations[0]);
                            }
                        }
                    } catch (error) {
                        console.warn("Could not fetch recommendations:", error);
                    } finally {
                        setLoading(false);
                    }
                };

                fetchRecommendations();
            }, [user]);

            const generateRecommendations = async () => {
                setGenerating(true);
                showNotification("G√©n√©ration des recommandations en cours...", "info");

                try {
                    const token = localStorage.getItem('authToken');
                    const response = await fetch(`${API_BASE_URL}/user/recommendations/generate`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    const data = await response.json();

                    if (response.ok) {
                        setRecommendations(data.recommendations);
                        setUserStats(data.userStats);
                        showNotification("Recommandations g√©n√©r√©es avec succ√®s!", "success");
                    } else {
                        throw new Error(data.error || "Erreur lors de la g√©n√©ration");
                    }
                } catch (error) {
                    showNotification(`Erreur: ${error.message}`, "error");
                    // Fallback avec des recommandations de d√©mo
                    setRecommendations({
                        analysis: {
                            strengths: ["Utilisation de l'IA pour les analyses", "Bonne discipline de mise"],
                            weaknesses: ["Taux de r√©ussite √† am√©liorer sur les matchs nuls"],
                            riskProfile: "moderate",
                            trend: "stable"
                        },
                        recommendations: [
                            {
                                category: "strategy",
                                priority: "high",
                                title: "Diversifiez vos paris",
                                description: "Vos performances sur les BTTS sont excellentes mais vous n√©gligez les Double Chance.",
                                actionable: "Int√©grez 2-3 paris Double Chance par semaine"
                            },
                            {
                                category: "bankroll",
                                priority: "medium",
                                title: "Ajustez vos mises",
                                description: "Vos mises sont parfois trop √©lev√©es par rapport √† votre capital.",
                                actionable: "Ne d√©passez pas 5% de votre capital par pari"
                            }
                        ],
                        optimalSettings: {
                            suggestedMaxBetPercentage: 5,
                            suggestedMinBet: 100,
                            preferredOptionTypes: ["BTTS", "DOUBLE_CHANCE", "TOTALS"]
                        },
                        motivationalMessage: "Continuez sur cette lanc√©e, vous progressez bien !"
                    });
                } finally {
                    setGenerating(false);
                }
            };

            if (!user) {
                navigate('login');
                return null;
            }

            const getPriorityColor = (priority) => {
                switch (priority) {
                    case 'high': return 'var(--accent-red)';
                    case 'medium': return 'var(--accent-gold)';
                    case 'low': return 'var(--accent-green)';
                    default: return 'var(--text-muted)';
                }
            };

            const getCategoryIcon = (category) => {
                switch (category) {
                    case 'bankroll': return 'üí∞';
                    case 'strategy': return 'üìä';
                    case 'option_types': return 'üéØ';
                    case 'timing': return '‚è±Ô∏è';
                    case 'psychology': return 'üß†';
                    default: return 'üìã';
                }
            };

            return (
                <>
                    <Header showBack={true} title="Recommandations IA" />
                    <main className="main-content">
                        {/* Stats utilisateur */}
                        {userStats && (
                            <div className="card animate-fade-in" style={{ marginBottom: '16px' }}>
                                <h4 style={{ marginBottom: '12px', color: 'var(--accent-gold)' }}>üìä Vos statistiques</h4>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '12px', textAlign: 'center' }}>
                                    <div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.2rem', color: 'var(--accent-gold)' }}>
                                            {(userStats.winRate || 0).toFixed(1)}%
                                        </div>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.7rem' }}>Taux r√©ussite</div>
                                    </div>
                                    <div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.2rem' }}>
                                            {userStats.totalPredictions || 0}
                                        </div>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.7rem' }}>Pr√©dictions</div>
                                    </div>
                                    <div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1rem', color: 'var(--accent-green)' }}>
                                            {(userStats.currentBalance || 0).toLocaleString()} F
                                        </div>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.7rem' }}>Capital</div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Bouton g√©n√©rer */}
                        <button 
                            className="btn btn-primary animate-fade-in" 
                            style={{ width: '100%', marginBottom: '20px' }}
                            onClick={generateRecommendations}
                            disabled={generating}
                        >
                            {generating ? (
                                <>
                                    <span className="spinner" style={{ width: '20px', height: '20px' }}></span>
                                    Analyse en cours...
                                </>
                            ) : (
                                <>
                                    <Icons.Brain />
                                    G√©n√©rer mes recommandations
                                </>
                            )}
                        </button>

                        {loading && (
                            <div style={{ textAlign: 'center', padding: '40px' }}>
                                <div className="spinner"></div>
                            </div>
                        )}

                        {/* Analyse */}
                        {recommendations?.analysis && (
                            <div className="card animate-fade-in delay-1" style={{ marginBottom: '16px' }}>
                                <h4 style={{ marginBottom: '12px' }}>üîç Analyse de votre profil</h4>

                                {/* Profil de risque et tendance */}
                                <div style={{ display: 'flex', gap: '12px', marginBottom: '16px', flexWrap: 'wrap' }}>
                                    <span style={{
                                        padding: '4px 12px',
                                        borderRadius: '20px',
                                        fontSize: '0.8rem',
                                        background: recommendations.analysis.riskProfile === 'conservative' 
                                            ? 'rgba(16, 185, 129, 0.2)' 
                                            : recommendations.analysis.riskProfile === 'aggressive'
                                                ? 'rgba(239, 68, 68, 0.2)'
                                                : 'rgba(245, 158, 11, 0.2)',
                                        color: recommendations.analysis.riskProfile === 'conservative' 
                                            ? 'var(--accent-green)' 
                                            : recommendations.analysis.riskProfile === 'aggressive'
                                                ? 'var(--accent-red)'
                                                : 'var(--accent-gold)'
                                    }}>
                                        Profil: {recommendations.analysis.riskProfile}
                                    </span>
                                    <span style={{
                                        padding: '4px 12px',
                                        borderRadius: '20px',
                                        fontSize: '0.8rem',
                                        background: 'rgba(59, 130, 246, 0.2)',
                                        color: 'var(--accent-blue)'
                                    }}>
                                        Tendance: {recommendations.analysis.trend}
                                    </span>
                                </div>

                                {/* Points forts */}
                                {recommendations.analysis.strengths?.length > 0 && (
                                    <div style={{ marginBottom: '12px' }}>
                                        <h5 style={{ color: 'var(--accent-green)', marginBottom: '8px', fontSize: '0.9rem' }}>
                                            ‚úÖ Points forts
                                        </h5>
                                        {recommendations.analysis.strengths.map((s, i) => (
                                            <p key={i} style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', marginLeft: '16px' }}>
                                                ‚Ä¢ {s}
                                            </p>
                                        ))}
                                    </div>
                                )}

                                {/* Points faibles */}
                                {recommendations.analysis.weaknesses?.length > 0 && (
                                    <div>
                                        <h5 style={{ color: 'var(--accent-red)', marginBottom: '8px', fontSize: '0.9rem' }}>
                                            ‚ö†Ô∏è Points √† am√©liorer
                                        </h5>
                                        {recommendations.analysis.weaknesses.map((w, i) => (
                                            <p key={i} style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', marginLeft: '16px' }}>
                                                ‚Ä¢ {w}
                                            </p>
                                        ))}
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Recommandations */}
                        {recommendations?.recommendations?.length > 0 && (
                            <div className="animate-fade-in delay-2">
                                <h4 style={{ marginBottom: '12px' }}>üí° Recommandations personnalis√©es</h4>
                                {recommendations.recommendations.map((rec, index) => (
                                    <div key={index} className="card" style={{ marginBottom: '12px' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '8px' }}>
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                <span>{getCategoryIcon(rec.category)}</span>
                                                <h5 style={{ fontSize: '0.95rem' }}>{rec.title}</h5>
                                            </div>
                                            <span style={{
                                                padding: '2px 8px',
                                                borderRadius: '10px',
                                                fontSize: '0.7rem',
                                                background: `${getPriorityColor(rec.priority)}20`,
                                                color: getPriorityColor(rec.priority)
                                            }}>
                                                {rec.priority?.toUpperCase()}
                                            </span>
                                        </div>
                                        <p style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', marginBottom: '8px' }}>
                                            {rec.description}
                                        </p>
                                        {rec.actionable && (
                                            <div style={{
                                                background: 'rgba(245, 158, 11, 0.1)',
                                                padding: '8px 12px',
                                                borderRadius: '8px',
                                                borderLeft: '3px solid var(--accent-gold)'
                                            }}>
                                                <span style={{ color: 'var(--accent-gold)', fontSize: '0.8rem', fontWeight: '600' }}>
                                                    üìå Action: 
                                                </span>
                                                <span style={{ color: 'var(--text-primary)', fontSize: '0.85rem' }}>
                                                    {rec.actionable}
                                                </span>
                                            </div>
                                        )}
                                    </div>
                                ))}
                            </div>
                        )}

                        {/* Param√®tres optimaux */}
                        {recommendations?.optimalSettings && (
                            <div className="card animate-fade-in delay-3" style={{ marginTop: '16px' }}>
                                <h4 style={{ marginBottom: '12px', color: 'var(--accent-gold)' }}>‚öôÔ∏è Param√®tres recommand√©s</h4>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
                                    <div>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>% max par pari</div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.1rem' }}>
                                            {recommendations.optimalSettings.suggestedMaxBetPercentage || 5}%
                                        </div>
                                    </div>
                                    <div>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem' }}>Mise minimum</div>
                                        <div style={{ fontFamily: 'Space Mono', fontSize: '1.1rem' }}>
                                            {(recommendations.optimalSettings.suggestedMinBet || 100).toLocaleString()} F
                                        </div>
                                    </div>
                                </div>
                                {recommendations.optimalSettings.preferredOptionTypes?.length > 0 && (
                                    <div style={{ marginTop: '12px' }}>
                                        <div style={{ color: 'var(--text-muted)', fontSize: '0.8rem', marginBottom: '4px' }}>
                                            Types de paris recommand√©s:
                                        </div>
                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                                            {recommendations.optimalSettings.preferredOptionTypes.map((type, i) => (
                                                <span key={i} style={{
                                                    padding: '4px 10px',
                                                    borderRadius: '15px',
                                                    fontSize: '0.8rem',
                                                    background: 'rgba(16, 185, 129, 0.2)',
                                                    color: 'var(--accent-green)'
                                                }}>
                                                    {type}
                                                </span>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Message de motivation */}
                        {recommendations?.motivationalMessage && (
                            <div className="animate-fade-in delay-4" style={{
                                marginTop: '20px',
                                padding: '16px',
                                background: 'rgba(139, 92, 246, 0.1)',
                                border: '1px solid rgba(139, 92, 246, 0.3)',
                                borderRadius: '12px',
                                textAlign: 'center'
                            }}>
                                <span style={{ fontSize: '1.5rem' }}>üí™</span>
                                <p style={{ color: '#a78bfa', marginTop: '8px', fontStyle: 'italic' }}>
                                    {recommendations.motivationalMessage}
                                </p>
                            </div>
                        )}

                        {/* Attribution */}
                        <p className="animate-fade-in delay-5" style={{
                            marginTop: '20px',
                            color: 'var(--text-muted)',
                            fontSize: '0.75rem',
                            textAlign: 'center'
                        }}>
                            üîÆ Analyse g√©n√©r√©e par DeepSeek Reasoner
                        </p>
                    </main>
                    <BottomNav />
                </>
            );
        };

        const FormationsPage = () => {
            const { user, navigate } = useApp();

            if (!user) {
                navigate('login');
                return null;
            }

            return (
                <>
                    <Header showBack={true} title="Formations" />
                    <main className="main-content">
                        <div className="card card-clickable animate-fade-in" onClick={() => navigate('formation-detail')}>
                            <div style={{ display: 'flex', gap: '16px' }}>
                                <div style={{ 
                                    width: '80px', 
                                    height: '80px', 
                                    borderRadius: '12px', 
                                    background: 'var(--gradient-gold)',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }}>
                                    <Icons.Book />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <h3>Deviens un parieur pro</h3>
                                    <p style={{ color: 'var(--text-muted)', fontSize: '0.9rem', marginTop: '4px' }}>
                                        Les fondamentaux des paris sportifs
                                    </p>
                                    <div style={{ marginTop: '8px', color: 'var(--accent-gold)', fontSize: '0.85rem' }}>
                                        3 chapitres ‚Ä¢ 60 min
                                    </div>
                                </div>
                            </div>
                        </div>
                    </main>
                    <BottomNav />
                </>
            );
        };

        const FormationDetailPage = () => {
            const { navigate } = useApp();

            const chapters = [
                { id: 1, title: 'Les bases des paris sportifs', duration: '15 min' },
                { id: 2, title: 'Gestion de bankroll', duration: '20 min' },
                { id: 3, title: 'Analyser les cotes', duration: '25 min' }
            ];

            return (
                <>
                    <Header showBack={true} title="Formation" />
                    <main className="main-content">
                        <h2 className="section-title animate-fade-in">Deviens un parieur pro</h2>
                        <p className="section-subtitle animate-fade-in delay-1">
                            Apprenez les fondamentaux pour devenir un parieur rentable
                        </p>

                        {chapters.map((chapter, index) => (
                            <div 
                                key={chapter.id}
                                className={`card card-clickable animate-fade-in delay-${index + 2}`}
                                onClick={() => navigate('chapter-detail')}
                            >
                                <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                                    <div style={{ 
                                        width: '48px', 
                                        height: '48px', 
                                        borderRadius: '50%', 
                                        background: 'var(--bg-secondary)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        fontFamily: 'Space Mono',
                                        fontWeight: '700',
                                        color: 'var(--accent-gold)'
                                    }}>
                                        {chapter.id}
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <h4>{chapter.title}</h4>
                                        <span style={{ color: 'var(--text-muted)', fontSize: '0.85rem' }}>
                                            {chapter.duration}
                                        </span>
                                    </div>
                                    <Icons.Play />
                                </div>
                            </div>
                        ))}
                    </main>
                    <BottomNav />
                </>
            );
        };

        const ChapterDetailPage = () => {
            return (
                <>
                    <Header showBack={true} title="Chapitre 1" />
                    <main className="main-content">
                        <div className="animate-fade-in" style={{ 
                            background: 'var(--bg-card)', 
                            borderRadius: '16px', 
                            aspectRatio: '16/9',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            marginBottom: '20px'
                        }}>
                            <div style={{ 
                                width: '64px', 
                                height: '64px', 
                                borderRadius: '50%',
                                background: 'var(--gradient-gold)',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                cursor: 'pointer'
                            }}>
                                <Icons.Play />
                            </div>
                        </div>

                        <h2 className="section-title animate-fade-in delay-1">Les bases des paris sportifs</h2>
                        
                        <div className="animate-fade-in delay-2" style={{ color: 'var(--text-secondary)', lineHeight: '1.7' }}>
                            <p style={{ marginBottom: '16px' }}>
                                Dans ce chapitre, vous apprendrez les fondamentaux des paris sportifs : 
                                comprendre les cotes, les diff√©rents types de paris, et comment √©valuer les opportunit√©s.
                            </p>
                            <p>
                                Une bonne compr√©hension de ces bases est essentielle pour devenir un parieur rentable sur le long terme.
                            </p>
                        </div>
                    </main>
                    <BottomNav />
                </>
            );
        };

        // ============== ROUTER ==============

        const Router = () => {
            const { currentPage } = useApp();

            const pages = {
                'home': HomePage,
                'login': LoginPage,
                'outils': OutilsPage,
                'matchs': MatchsPage,
                'balance-input': BalanceInputPage,
                'strategy': StrategyPage,
                'pronostics': PronosticsPage,
                'cashout': CashoutPage,
                'coverage-strategy': CoverageStrategyPage,
                'capital': CapitalPage,
                'recommendations': RecommendationsPage,
                'formations': FormationsPage,
                'formation-detail': FormationDetailPage,
                'chapter-detail': ChapterDetailPage,
            };

            const PageComponent = pages[currentPage] || HomePage;
            return <PageComponent />;
        };

        // ============== APP ==============

        const App = () => {
            const appContext = useApp();
            
            return (
                <>
                    <Router />
                    {appContext?.notification && (
                        <Notification 
                            message={appContext.notification.message} 
                            type={appContext.notification.type} 
                        />
                    )}
                    {/* Loader global avec message */}
                    <GlobalLoader message={appContext?.loadingMessage} />
                </>
            );
        };

        // ============== RENDER ==============

        const Root = () => (
            <AppProvider>
                <div className="app-container">
                    <App />
                </div>
            </AppProvider>
        );

        ReactDOM.createRoot(document.getElementById('root')).render(<Root />);
    </script>
</body>
</html>
